#This patch file is from Qualcomm Innovation Center, Inc. and is provided under the following license:
#
#Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
#SPDX-License-Identifier: BSD-3-Clause-Clear
From 52d2df322f9683e31e015209d9dc973b6ab97caa Mon Sep 17 00:00:00 2001
From: Devanshi Bansal <quic_devanshi@quicinc.com>
Date: Wed, 17 Jul 2024 14:14:39 +0530
Subject: [PATCH] Add sdm backend

Change-Id: I6659b163166dfd533bf822eb9ea5b48015dbd74a
Signed-off-by: Devanshi Bansal <quic_devanshi@quicinc.com>
---
 compositor/main.c                             |   65 +
 include/libweston/libweston.h                 |    1 +
 libweston/backend-sdm/fb.c                    |  636 ++++++
 libweston/backend-sdm/kms.c                   |  165 ++
 libweston/backend-sdm/meson.build             |   71 +
 libweston/backend-sdm/modes.c                 |  213 ++
 libweston/backend-sdm/sdm-gbm.c               |  286 +++
 libweston/backend-sdm/sdm-internal.h          |  519 +++++
 .../sdm-service/sdm_color_mode_intf.h         |   34 +
 .../sdm-service/sdm_color_mode_intf_impl.cpp  |  464 ++++
 .../sdm-service/sdm_color_mode_intf_impl.h    |  108 +
 .../backend-sdm/sdm-service/sdm_display.cpp   | 1747 +++++++++++++++
 .../backend-sdm/sdm-service/sdm_display.h     |  311 +++
 .../sdm_display_buffer_allocator.cpp          |  433 ++++
 .../sdm_display_buffer_allocator.h            |   78 +
 .../sdm_display_buffer_sync_handler.cpp       |   86 +
 .../sdm_display_buffer_sync_handler.h         |   49 +
 .../sdm-service/sdm_display_connect.cpp       |  592 ++++++
 .../sdm-service/sdm_display_connect.h         |  278 +++
 .../sdm-service/sdm_display_debugger.cpp      |  285 +++
 .../sdm-service/sdm_display_debugger.h        |  100 +
 .../sdm-service/sdm_display_interface.h       |  241 +++
 .../sdm_display_socket_handler.cpp            |   46 +
 .../sdm-service/sdm_display_socket_handler.h  |   46 +
 libweston/backend-sdm/sdm-service/uevent.c    |  135 ++
 libweston/backend-sdm/sdm-service/uevent.h    |   40 +
 libweston/backend-sdm/sdm.c                   | 1888 +++++++++++++++++
 libweston/backend-sdm/state-propose.c         |  174 ++
 libweston/compositor.c                        |    1 +
 libweston/launcher-direct.c                   |   25 +-
 libweston/meson.build                         |   12 +-
 meson.build                                   |   16 +-
 meson_options.txt                             |   13 +-
 33 files changed, 9145 insertions(+), 13 deletions(-)
 create mode 100644 libweston/backend-sdm/fb.c
 create mode 100644 libweston/backend-sdm/kms.c
 create mode 100644 libweston/backend-sdm/meson.build
 create mode 100644 libweston/backend-sdm/modes.c
 create mode 100644 libweston/backend-sdm/sdm-gbm.c
 create mode 100644 libweston/backend-sdm/sdm-internal.h
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_color_mode_intf.h
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_color_mode_intf_impl.cpp
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_color_mode_intf_impl.h
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display.cpp
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display.h
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_buffer_allocator.cpp
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_buffer_allocator.h
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_buffer_sync_handler.cpp
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_buffer_sync_handler.h
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_connect.cpp
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_connect.h
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_debugger.cpp
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_debugger.h
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_interface.h
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_socket_handler.cpp
 create mode 100644 libweston/backend-sdm/sdm-service/sdm_display_socket_handler.h
 create mode 100644 libweston/backend-sdm/sdm-service/uevent.c
 create mode 100644 libweston/backend-sdm/sdm-service/uevent.h
 create mode 100644 libweston/backend-sdm/sdm.c
 create mode 100644 libweston/backend-sdm/state-propose.c

diff --git a/compositor/main.c b/compositor/main.c
index 322f2ff..cdd6968 100644
--- a/compositor/main.c
+++ b/compositor/main.c
@@ -2617,6 +2617,69 @@ load_pipewire(struct weston_compositor *c, struct weston_config *wc)
 	}
 }
 
+static int
+load_sdm_backend(struct weston_compositor *c,
+		 int *argc, char **argv, struct weston_config *wc)
+{
+	struct weston_drm_backend_config config = {{ 0, }};
+	struct weston_config_section *section;
+	struct wet_compositor *wet = to_wet_compositor(c);
+	bool without_input = false;
+	int ret = 0;
+
+	wet->drm_use_current_mode = false;
+
+	section = weston_config_get_section(wc, "core", NULL, NULL);
+	weston_config_section_get_bool(section, "use-pixman", &config.use_pixman,
+				       false);
+
+	const struct weston_option options[] = {
+		{ WESTON_OPTION_STRING, "seat", 0, &config.seat_id },
+		{ WESTON_OPTION_INTEGER, "tty", 0, &config.tty },
+		{ WESTON_OPTION_STRING, "drm-device", 0, &config.specific_device },
+		{ WESTON_OPTION_BOOLEAN, "current-mode", 0, &wet->drm_use_current_mode },
+		{ WESTON_OPTION_BOOLEAN, "use-pixman", 0, &config.use_pixman },
+		{ WESTON_OPTION_BOOLEAN, "continue-without-input", false, &without_input },
+	};
+
+	parse_options(options, ARRAY_LENGTH(options), argc, argv);
+
+	section = weston_config_get_section(wc, "core", NULL, NULL);
+	weston_config_section_get_string(section,
+					 "gbm-format", &config.gbm_format,
+					 NULL);
+	weston_config_section_get_uint(section, "pageflip-timeout",
+	                               &config.pageflip_timeout, 0);
+	weston_config_section_get_bool(section, "pixman-shadow",
+				       &config.use_pixman_shadow, true);
+
+	if (without_input)
+		c->require_input = !without_input;
+
+	config.base.struct_version = WESTON_DRM_BACKEND_CONFIG_VERSION;
+	config.base.struct_size = sizeof(struct weston_drm_backend_config);
+	config.configure_device = configure_input_device;
+
+	wet->heads_changed_listener.notify = drm_heads_changed;
+	weston_compositor_add_heads_changed_listener(c,
+						&wet->heads_changed_listener);
+
+	ret = weston_compositor_load_backend(c, WESTON_BACKEND_SDM,
+					     &config.base);
+
+	/* remoting */
+	load_remoting(c, wc);
+
+	/* pipewire */
+	load_pipewire(c, wc);
+
+	free(config.gbm_format);
+	free(config.seat_id);
+	free(config.specific_device);
+
+	return ret;
+}
+
 static int
 load_drm_backend(struct weston_compositor *c,
 		 int *argc, char **argv, struct weston_config *wc)
@@ -3148,6 +3211,8 @@ load_backend(struct weston_compositor *compositor, const char *backend,
 		return load_fbdev_backend(compositor, argc, argv, config);
 	else if (strstr(backend, "drm-backend.so"))
 		return load_drm_backend(compositor, argc, argv, config);
+	else if (strstr(backend, "sdm-backend.so"))
+		return load_sdm_backend(compositor, argc, argv, config);
 	else if (strstr(backend, "x11-backend.so"))
 		return load_x11_backend(compositor, argc, argv, config);
 	else if (strstr(backend, "wayland-backend.so"))
diff --git a/include/libweston/libweston.h b/include/libweston/libweston.h
index 0086e67..31bfda8 100644
--- a/include/libweston/libweston.h
+++ b/include/libweston/libweston.h
@@ -1867,6 +1867,7 @@ weston_compositor_add_destroy_listener_once(struct weston_compositor *compositor
 
 enum weston_compositor_backend {
 	WESTON_BACKEND_DRM,
+        WESTON_BACKEND_SDM,
 	WESTON_BACKEND_FBDEV,
 	WESTON_BACKEND_HEADLESS,
 	WESTON_BACKEND_RDP,
diff --git a/libweston/backend-sdm/fb.c b/libweston/backend-sdm/fb.c
new file mode 100644
index 0000000..99ebe18
--- /dev/null
+++ b/libweston/backend-sdm/fb.c
@@ -0,0 +1,636 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2017, 2018 Collabora, Ltd.
+ * Copyright © 2017, 2018 General Electric Company
+ * Copyright (c) 2018 DisplayLink (UK) Ltd.
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ *
+ */
+
+#include "config.h"
+#include <stdint.h>
+#include <libweston/libweston.h>
+#include <libweston/pixel-formats.h>
+#include <libweston/linux-dmabuf.h>
+#include "shared/helpers.h"
+#include "sdm-internal.h"
+#include "linux-dmabuf.h"
+#include "gbm-buffer-backend.h"
+#include <gbm.h>
+#include <gbm_priv.h>
+
+static uint32_t drm_fb_get_planes_number(uint32_t format)
+{
+	uint32_t planes_num;
+	switch (format) {
+	case GBM_FORMAT_YCbCr_420_SP:
+	case GBM_FORMAT_YCbCr_422_SP:
+	case GBM_FORMAT_YCbCr_420_SP_VENUS:
+	case GBM_FORMAT_NV12:
+	case GBM_FORMAT_YCrCb_420_SP:
+	case GBM_FORMAT_YCrCb_422_SP:
+	case GBM_FORMAT_YCrCb_420_SP_VENUS:
+	case GBM_FORMAT_YCbCr_420_P010_VENUS:
+	case GBM_FORMAT_P010:
+		planes_num = 2;
+		break;
+	default:
+		planes_num = 1;
+		break;
+	}
+	return planes_num;
+}
+
+static void
+drm_fb_destroy(struct drm_fb *fb)
+{
+	if (fb->fb_id != 0)
+		drmModeRmFB(fb->fd, fb->fb_id);
+	if (fb->ion_fd > 0)
+		close(fb->ion_fd);
+	weston_buffer_reference(&fb->buffer_ref, NULL);
+	weston_buffer_release_reference(&fb->buffer_release_ref, NULL);
+	free(fb);
+}
+
+static void
+drm_fb_destroy_dumb(struct drm_fb *fb)
+{
+	struct drm_mode_destroy_dumb destroy_arg;
+
+	assert(fb->type == BUFFER_PIXMAN_DUMB);
+
+	if (fb->map && fb->size > 0)
+		munmap(fb->map, fb->size);
+
+	memset(&destroy_arg, 0, sizeof(destroy_arg));
+	destroy_arg.handle = fb->handles[0];
+	drmIoctl(fb->fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_arg);
+
+	drm_fb_destroy(fb);
+}
+
+static int
+drm_fb_addfb(struct drm_backend *b, struct drm_fb *fb)
+{
+    int ret = -EINVAL;
+    uint64_t mods[4] = { };
+    size_t i;
+
+    /* If we have a modifier set, we must only use the WithModifiers
+     * entrypoint; we cannot import it through legacy ioctls. */
+    if (b->fb_modifiers && fb->modifier != DRM_FORMAT_MOD_INVALID) {
+	    /* KMS demands that if a modifier is set, it must be the same
+	     * for all planes. */
+	    for (i = 0; i < ARRAY_LENGTH(mods) && fb->handles[i]; i++)
+			mods[i] = fb->modifier;
+		ret = drmModeAddFB2WithModifiers(fb->fd, fb->width, fb->height,
+			    fb->format->format,
+			    fb->handles, fb->strides,
+			    fb->offsets, mods, &fb->fb_id,
+			    DRM_MODE_FB_MODIFIERS);
+	    return ret;
+    }
+
+	ret = drmModeAddFB2(fb->fd, fb->width, fb->height, fb->format->format,
+			    fb->handles, fb->strides, fb->offsets, &fb->fb_id,
+			    0);
+
+	if (ret == 0)
+		return 0;
+
+	/* Legacy AddFB can't always infer the format from depth/bpp alone, so
+	 * check if our format is one of the lucky ones. */
+	if (!fb->format->depth || !fb->format->bpp)
+		return ret;
+
+	/* Cannot fall back to AddFB for multi-planar formats either. */
+	if (fb->handles[1] || fb->handles[2] || fb->handles[3])
+		return ret;
+
+	ret = drmModeAddFB(fb->fd, fb->width, fb->height,
+			   fb->format->depth, fb->format->bpp,
+			   fb->strides[0], fb->handles[0], &fb->fb_id);
+	return ret;
+}
+
+struct drm_fb *
+drm_fb_create_dumb(struct drm_backend *b, int width, int height,
+		   uint32_t format)
+{
+	struct drm_fb *fb;
+	int ret;
+
+	struct drm_mode_create_dumb create_arg;
+	struct drm_mode_destroy_dumb destroy_arg;
+	struct drm_mode_map_dumb map_arg;
+
+	fb = zalloc(sizeof *fb);
+	if (!fb)
+		return NULL;
+	fb->refcnt = 1;
+
+	fb->format = pixel_format_get_info(format);
+	if (!fb->format) {
+		weston_log("failed to look up format 0x%lx\n",
+			   (unsigned long) format);
+		goto err_fb;
+	}
+
+	if (!fb->format->depth || !fb->format->bpp) {
+		weston_log("format 0x%lx is not compatible with dumb buffers\n",
+			   (unsigned long) format);
+		goto err_fb;
+	}
+
+	memset(&create_arg, 0, sizeof create_arg);
+	create_arg.bpp = fb->format->bpp;
+	create_arg.width = width;
+	create_arg.height = height;
+
+	ret = drmIoctl(b->drm.fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_arg);
+	if (ret)
+		goto err_fb;
+
+	fb->type = BUFFER_PIXMAN_DUMB;
+	fb->modifier = DRM_FORMAT_MOD_INVALID;
+	fb->handles[0] = create_arg.handle;
+	fb->strides[0] = create_arg.pitch;
+	fb->num_planes = 1;
+	fb->size = create_arg.size;
+	fb->width = width;
+	fb->height = height;
+	fb->fd = b->drm.fd;
+
+	if (drm_fb_addfb(b, fb) != 0) {
+		weston_log("failed to create kms fb: %s\n", strerror(errno));
+		goto err_bo;
+	}
+
+	memset(&map_arg, 0, sizeof map_arg);
+	map_arg.handle = fb->handles[0];
+	ret = drmIoctl(fb->fd, DRM_IOCTL_MODE_MAP_DUMB, &map_arg);
+	if (ret)
+		goto err_add_fb;
+
+	fb->map = mmap(NULL, fb->size, PROT_WRITE,
+		       MAP_SHARED, b->drm.fd, map_arg.offset);
+	if (fb->map == MAP_FAILED)
+		goto err_add_fb;
+
+	return fb;
+
+err_add_fb:
+	drmModeRmFB(b->drm.fd, fb->fb_id);
+err_bo:
+	memset(&destroy_arg, 0, sizeof(destroy_arg));
+	destroy_arg.handle = create_arg.handle;
+	drmIoctl(b->drm.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_arg);
+err_fb:
+	free(fb);
+	return NULL;
+}
+
+struct drm_fb *
+drm_fb_ref(struct drm_fb *fb)
+{
+	fb->refcnt++;
+	return fb;
+}
+
+#ifdef BUILD_DRM_GBM
+static void
+drm_fb_destroy_gbm(struct gbm_bo *bo, void *data)
+{
+	struct drm_fb *fb = data;
+
+	drm_fb_destroy(fb);
+}
+
+static void
+drm_fb_destroy_dmabuf(struct drm_fb *fb)
+{
+	/* We deliberately do not close the GEM handles here; GBM manages
+	 * their lifetime through the BO. */
+	if (fb->bo)
+		gbm_bo_destroy(fb->bo);
+	drm_fb_destroy(fb);
+}
+
+static struct drm_fb *
+drm_fb_get_from_dmabuf(struct linux_dmabuf_buffer *dmabuf,
+		       struct drm_backend *backend, bool is_opaque)
+{
+	struct drm_fb *fb;
+	struct gbm_import_fd_data import_legacy = {
+		.width = dmabuf->attributes.width,
+		.height = dmabuf->attributes.height,
+		.format = dmabuf->attributes.format,
+		.stride = dmabuf->attributes.stride[0],
+		.fd = dmabuf->attributes.fd[0],
+	};
+#ifdef HAVE_GBM_FD_IMPORT
+	struct gbm_import_fd_modifier_data import_mod = {
+		.width = dmabuf->attributes.width,
+		.height = dmabuf->attributes.height,
+		.format = dmabuf->attributes.format,
+		.num_fds = dmabuf->attributes.n_planes,
+		.modifier = dmabuf->attributes.modifier[0],
+	};
+#endif /* HAVE_GBM_FD_IMPORT */
+
+#ifdef HAVE_GBM_MODIFIERS
+	int i;
+#endif
+
+
+	fb = zalloc(sizeof *fb);
+	if (fb == NULL)
+		return NULL;
+
+	fb->refcnt = 1;
+	fb->type = BUFFER_DMABUF;
+
+#ifdef HAVE_GBM_FD_IMPORT
+	static_assert(ARRAY_LENGTH(import_mod.fds) ==
+		      ARRAY_LENGTH(dmabuf->attributes.fd),
+		      "GBM and linux_dmabuf FD size must match");
+	static_assert(sizeof(import_mod.fds) == sizeof(dmabuf->attributes.fd),
+		      "GBM and linux_dmabuf FD size must match");
+	memcpy(import_mod.fds, dmabuf->attributes.fd, sizeof(import_mod.fds));
+
+	static_assert(ARRAY_LENGTH(import_mod.strides) ==
+		      ARRAY_LENGTH(dmabuf->attributes.stride),
+		      "GBM and linux_dmabuf stride size must match");
+	static_assert(sizeof(import_mod.strides) ==
+		      sizeof(dmabuf->attributes.stride),
+		      "GBM and linux_dmabuf stride size must match");
+	memcpy(import_mod.strides, dmabuf->attributes.stride,
+	       sizeof(import_mod.strides));
+
+	static_assert(ARRAY_LENGTH(import_mod.offsets) ==
+		      ARRAY_LENGTH(dmabuf->attributes.offset),
+		      "GBM and linux_dmabuf offset size must match");
+	static_assert(sizeof(import_mod.offsets) ==
+		      sizeof(dmabuf->attributes.offset),
+		      "GBM and linux_dmabuf offset size must match");
+	memcpy(import_mod.offsets, dmabuf->attributes.offset,
+	       sizeof(import_mod.offsets));
+#endif /* NOT HAVE_GBM_FD_IMPORT */
+
+	/* The legacy FD-import path does not allow us to supply modifiers,
+	 * multiple planes, or buffer offsets. */
+	if (dmabuf->attributes.modifier[0] != DRM_FORMAT_MOD_INVALID ||
+	    dmabuf->attributes.n_planes > 1 ||
+	    dmabuf->attributes.offset[0] > 0) {
+#ifdef HAVE_GBM_FD_IMPORT
+		fb->bo = gbm_bo_import(backend->gbm, GBM_BO_IMPORT_FD_MODIFIER,
+				       &import_mod,
+				       GBM_BO_USE_SCANOUT);
+#else /* NOT HAVE_GBM_FD_IMPORT */
+		drm_debug(backend, "\t\t\t[dmabuf] Unsupported use of modifiers.\n");
+		goto err_free;
+#endif /* NOT HAVE_GBM_FD_IMPORT */
+	} else {
+		fb->bo = gbm_bo_import(backend->gbm, GBM_BO_IMPORT_FD,
+				       &import_legacy,
+				       GBM_BO_USE_SCANOUT);
+	}
+
+	if (!fb->bo)
+		goto err_free;
+
+	fb->width = dmabuf->attributes.width;
+	fb->height = dmabuf->attributes.height;
+	fb->modifier = dmabuf->attributes.modifier[0];
+	fb->size = 0;
+	fb->fd = backend->drm.fd;
+	fb->ion_fd = gbm_bo_get_fd(fb->bo);
+	static_assert(ARRAY_LENGTH(fb->strides) ==
+		      ARRAY_LENGTH(dmabuf->attributes.stride),
+		      "drm_fb and dmabuf stride size must match");
+	static_assert(sizeof(fb->strides) == sizeof(dmabuf->attributes.stride),
+		      "drm_fb and dmabuf stride size must match");
+	memcpy(fb->strides, dmabuf->attributes.stride, sizeof(fb->strides));
+	static_assert(ARRAY_LENGTH(fb->offsets) ==
+		      ARRAY_LENGTH(dmabuf->attributes.offset),
+		      "drm_fb and dmabuf offset size must match");
+	static_assert(sizeof(fb->offsets) == sizeof(dmabuf->attributes.offset),
+		      "drm_fb and dmabuf offset size must match");
+	memcpy(fb->offsets, dmabuf->attributes.offset, sizeof(fb->offsets));
+
+	fb->format = pixel_format_get_info(dmabuf->attributes.format);
+	if (!fb->format) {
+		weston_log("couldn't look up format info for 0x%lx\n",
+			   (unsigned long) dmabuf->attributes.format);
+		goto err_free;
+	}
+
+	if (is_opaque)
+		fb->format = pixel_format_get_opaque_substitute(fb->format);
+
+#ifdef HAVE_GBM_MODIFIERS
+	fb->num_planes = dmabuf->attributes.n_planes;
+	for (i = 0; i < dmabuf->attributes.n_planes; i++) {
+		union gbm_bo_handle handle;
+
+	        handle = gbm_bo_get_handle_for_plane(fb->bo, i);
+		if (handle.s32 == -1)
+			goto err_free;
+		fb->handles[i] = handle.u32;
+	}
+#else /* NOT HAVE_GBM_MODIFIERS */
+	{
+		union gbm_bo_handle handle;
+
+	        handle = gbm_bo_get_handle(fb->bo);
+
+		if (handle.s32 == -1)
+			goto err_free;
+		fb->handles[0] = handle.u32;
+
+		fb->num_planes = drm_fb_get_planes_number(fb->format->format);
+		if (fb->num_planes == 2) {
+			fb->strides[1] = fb->strides[0];
+			fb->handles[1] = fb->handles[0];
+		}
+	}
+#endif /* NOT HAVE_GBM_MODIFIERS */
+
+	if (drm_fb_addfb(backend, fb) != 0) {
+		weston_log("[%s]:failed to create kms fb: %s\n", __func__,
+				strerror(errno));
+		weston_log("[%s] fmt(%s:0x%x) num_planes(%d)\n", __FUNCTION__,
+				fb->format->drm_format_name, fb->format->format,
+				fb->num_planes);
+		for (int i = 0; i < fb->num_planes; i++) {
+			weston_log("[%s] fb strides[%d] = %d, handles[%d] = %d,\
+					offset[%d] = %d\n", __FUNCTION__,
+					i, fb->strides[i],
+					i, fb->handles[i],
+					i, fb->offsets[i]);
+		}
+		goto err_free;
+	}
+
+	return fb;
+
+err_free:
+	if (fb->ion_fd > 0) {
+		close(fb->ion_fd);
+	}
+	drm_fb_destroy_dmabuf(fb);
+	return NULL;
+}
+
+struct drm_fb *
+drm_fb_get_from_bo(struct gbm_bo *bo, struct drm_backend *backend,
+		   bool is_opaque, enum drm_fb_type type)
+{
+	struct drm_fb *fb = gbm_bo_get_user_data(bo);
+#ifdef HAVE_GBM_MODIFIERS
+	int i;
+#endif
+	if (fb) {
+		assert(fb->type == type);
+		return drm_fb_ref(fb);
+	}
+
+	fb = zalloc(sizeof *fb);
+	if (fb == NULL)
+		return NULL;
+
+	fb->type = type;
+	fb->refcnt = 1;
+	fb->bo = bo;
+	fb->fd = backend->drm.fd;
+
+	fb->width = gbm_bo_get_width(bo);
+	fb->height = gbm_bo_get_height(bo);
+	fb->format = pixel_format_get_info(gbm_bo_get_format(bo));
+	fb->ion_fd = gbm_bo_get_fd(bo);
+
+#ifdef HAVE_GBM_MODIFIERS
+	fb->modifier = gbm_bo_get_modifier(bo);
+	fb->num_planes = gbm_bo_get_plane_count(bo);
+	for (i = 0; i < fb->num_planes; i++) {
+		fb->strides[i] = gbm_bo_get_stride_for_plane(bo, i);
+		fb->handles[i] = gbm_bo_get_handle_for_plane(bo, i).u32;
+		fb->offsets[i] = gbm_bo_get_offset(bo, i);
+	}
+#else
+	fb->strides[0] = gbm_bo_get_stride(bo);
+	fb->handles[0] = gbm_bo_get_handle(bo).u32;
+	fb->modifier = DRM_FORMAT_MOD_INVALID;
+	fb->num_planes = drm_fb_get_planes_number(fb->format->format);
+	if (fb->num_planes == 2) {
+		fb->strides[1] = fb->strides[0];
+		fb->handles[1] = fb->handles[0];
+	}
+
+#endif
+
+	fb->size = fb->strides[0] * fb->height;
+	if (!fb->format) {
+		weston_log("couldn't look up format 0x%lx\n",
+			   (unsigned long) gbm_bo_get_format(bo));
+		goto err_free;
+	}
+
+	if (is_opaque)
+		fb->format = pixel_format_get_opaque_substitute(fb->format);
+
+	if (drm_fb_addfb(backend, fb) != 0) {
+		weston_log("failed to create kms fb: %s\n",
+				strerror(errno));
+		weston_log("[%s] fmt(%s:0x%x) num_planes(%d)\n", __FUNCTION__,
+				fb->format->drm_format_name, fb->format->format,
+				fb->num_planes);
+		for (int i = 0; i < fb->num_planes; i++) {
+			weston_log("[%s] fb strides[%d] = %d, handles[%d] = %d,\
+					offset[%d] = %d\n", __FUNCTION__,
+					i, fb->strides[i],
+					i, fb->handles[i],
+					i, fb->offsets[i]);
+		}
+		goto err_free;
+	}
+
+	gbm_bo_set_user_data(bo, fb, drm_fb_destroy_gbm);
+
+	return fb;
+
+err_free:
+	if (fb->ion_fd > 0) {
+		close(fb->ion_fd);
+	}
+	free(fb);
+	return NULL;
+}
+
+static void
+drm_fb_set_buffer(struct drm_fb *fb, struct weston_buffer *buffer,
+		  struct weston_buffer_release *buffer_release)
+{
+	assert(fb->buffer_ref.buffer == NULL);
+	weston_buffer_reference(&fb->buffer_ref, buffer);
+	weston_buffer_release_reference(&fb->buffer_release_ref,
+					buffer_release);
+}
+#endif
+
+void
+drm_fb_unref(struct drm_fb *fb)
+{
+	if (!fb)
+		return;
+
+	assert(fb->refcnt > 0);
+	if (--fb->refcnt > 0)
+		return;
+
+	switch (fb->type) {
+	case BUFFER_PIXMAN_DUMB:
+		drm_fb_destroy_dumb(fb);
+		break;
+	case BUFFER_PIXMAN_GBM:
+		break;
+#ifdef BUILD_DRM_GBM
+	case BUFFER_CURSOR:
+	case BUFFER_CLIENT:
+		gbm_bo_destroy(fb->bo);
+		break;
+	case BUFFER_GBM_SURFACE:
+		gbm_surface_release_buffer(fb->gbm_surface, fb->bo);
+		break;
+	case BUFFER_DMABUF:
+		drm_fb_destroy_dmabuf(fb);
+		break;
+#endif
+	default:
+		assert(NULL);
+		break;
+	}
+}
+
+#ifdef BUILD_DRM_GBM
+bool
+drm_can_scanout_dmabuf(struct weston_compositor *ec,
+		       struct linux_dmabuf_buffer *dmabuf)
+{
+	struct drm_fb *fb;
+	struct drm_backend *b = to_drm_backend(ec);
+	bool ret = false;
+
+	fb = drm_fb_get_from_dmabuf(dmabuf, b, true);
+	if (fb)
+		ret = true;
+
+	drm_fb_unref(fb);
+	drm_debug(b, "[dmabuf] dmabuf %p, import test %s\n", dmabuf,
+		      ret ? "succeeded" : "failed");
+	return ret;
+}
+
+struct drm_fb *
+drm_fb_get_from_view(struct drm_output *output, struct weston_view *ev)
+{
+	struct drm_backend *b = to_drm_backend(output->base.compositor);
+	struct weston_buffer *buffer = ev->surface->buffer_ref.buffer;
+	bool is_opaque = weston_view_is_opaque(ev, &ev->transform.boundingbox);
+	struct linux_dmabuf_buffer *dmabuf;
+	struct drm_fb *fb = NULL;
+	struct gbm_bo *bo = NULL;
+	struct gbm_buffer *gbmbuf;
+
+	if (ev->alpha != 1.0f)
+		return NULL;
+
+	if (!drm_view_transform_supported(ev, &output->base))
+		return NULL;
+
+	if (ev->surface->protection_mode == WESTON_SURFACE_PROTECTION_MODE_ENFORCED &&
+	    ev->surface->desired_protection > output->base.current_protection)
+		return NULL;
+
+	if (!buffer)
+		return NULL;
+
+	if (wl_shm_buffer_get(buffer->resource))
+		return NULL;
+
+	/* GBM is used for dmabuf import as well as from client wl_buffer. */
+	if (!b->gbm)
+		return NULL;
+
+	dmabuf = linux_dmabuf_buffer_get(buffer->resource);
+	if (dmabuf) {
+		//simple-dmabuf-egl will use this
+		fb = drm_fb_get_from_dmabuf(dmabuf, b, is_opaque);
+		if (!fb)
+			return NULL;
+	} else if (gbmbuf = gbm_buffer_get(buffer->resource)) {
+		//gstreamer will use this for buffer sharing
+		struct gbm_buf_info gbmbuf_info = {
+			.fd = gbmbuf->fd,
+			.metadata_fd = gbmbuf->metadata_fd,
+			.width = gbmbuf->width,
+			.height = gbmbuf->height,
+			.format = gbmbuf->format
+		};
+		struct weston_surface *es = ev->surface;
+
+		bo = gbm_bo_import(b->gbm, GBM_BO_IMPORT_GBM_BUF_TYPE,
+					&gbmbuf_info, GBM_BO_USE_SCANOUT);
+	} else {
+		//simple-egl will use WL_BUFFER
+		bo = gbm_bo_import(b->gbm, GBM_BO_IMPORT_WL_BUFFER,
+				   buffer->resource, GBM_BO_USE_SCANOUT);
+	}
+
+	if (!dmabuf) {
+		if (!bo) {
+			return NULL;
+		}
+
+		fb = drm_fb_get_from_bo(bo, b, is_opaque, BUFFER_CLIENT);
+		if (!fb || !fb->format) {
+			gbm_bo_destroy(bo);
+			return NULL;
+		}
+	}
+
+	drm_debug(b, "\t\t\t[view] view %p format: %s\n",
+		  ev, fb->format->drm_format_name);
+	drm_fb_set_buffer(fb, buffer,
+			  ev->surface->buffer_release_ref.buffer_release);
+	return fb;
+}
+
+#endif
diff --git a/libweston/backend-sdm/kms.c b/libweston/backend-sdm/kms.c
new file mode 100644
index 0000000..da161a6
--- /dev/null
+++ b/libweston/backend-sdm/kms.c
@@ -0,0 +1,165 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2017, 2018 Collabora, Ltd.
+ * Copyright © 2017, 2018 General Electric Company
+ * Copyright (c) 2018 DisplayLink (UK) Ltd.
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ *
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#include "config.h"
+
+#include <stdint.h>
+#include <libweston/libweston.h>
+#include "shared/helpers.h"
+#include "sdm-internal.h"
+#include "pixel-formats.h"
+#include "presentation-time-server-protocol.h"
+
+extern int display_id;
+
+struct drm_property_enum_info dpms_state_enums[] = {
+	[WDRM_DPMS_STATE_OFF] = {
+		.name = "Off",
+	},
+	[WDRM_DPMS_STATE_ON] = {
+		.name = "On",
+	},
+	[WDRM_DPMS_STATE_STANDBY] = {
+		.name = "Standby",
+	},
+	[WDRM_DPMS_STATE_SUSPEND] = {
+		.name = "Suspend",
+	},
+};
+
+struct drm_property_enum_info content_protection_enums[] = {
+	[WDRM_CONTENT_PROTECTION_UNDESIRED] = {
+		.name = "Undesired",
+	},
+	[WDRM_CONTENT_PROTECTION_DESIRED] = {
+		.name = "Desired",
+	},
+	[WDRM_CONTENT_PROTECTION_ENABLED] = {
+		.name = "Enabled",
+	},
+};
+
+void
+drm_output_update_msc(struct drm_output *output, unsigned int seq)
+{
+	uint64_t msc_hi = output->base.msc >> 32;
+
+	if (seq < (output->base.msc & 0xffffffff))
+		msc_hi++;
+
+	output->base.msc = (msc_hi << 32) + seq;
+}
+
+int
+on_drm_input(int fd, uint32_t mask, void *data)
+{
+	//SDM takes care of vsync
+	return 1;
+}
+
+int
+init_kms_caps(struct drm_backend *b)
+{
+	uint64_t cap;
+	int ret;
+	clockid_t clk_id;
+
+	weston_log("using %s\n", b->drm.filename);
+
+	ret = drmGetCap(b->drm.fd, DRM_CAP_TIMESTAMP_MONOTONIC, &cap);
+	if (ret == 0 && cap == 1)
+		clk_id = CLOCK_MONOTONIC;
+	else
+		clk_id = CLOCK_REALTIME;
+
+	if (weston_compositor_set_presentation_clock(b->compositor, clk_id) < 0) {
+		weston_log("Error: failed to set presentation clock %d.\n",
+			   clk_id);
+		return -1;
+	}
+
+	ret = drmGetCap(b->drm.fd, DRM_CAP_CURSOR_WIDTH, &cap);
+	if (ret == 0)
+		b->cursor_width = cap;
+	else
+		b->cursor_width = 64;
+
+	ret = drmGetCap(b->drm.fd, DRM_CAP_CURSOR_HEIGHT, &cap);
+	if (ret == 0)
+		b->cursor_height = cap;
+	else
+		b->cursor_height = 64;
+
+	if (!getenv("WESTON_DISABLE_UNIVERSAL_PLANES")) {
+		ret = drmSetClientCap(b->drm.fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+		b->universal_planes = (ret == 0);
+	}
+	weston_log("DRM: %s universal planes\n",
+		   b->universal_planes ? "supports" : "does not support");
+
+	if (b->universal_planes && !getenv("WESTON_DISABLE_ATOMIC")) {
+		ret = drmGetCap(b->drm.fd, DRM_CAP_CRTC_IN_VBLANK_EVENT, &cap);
+		if (ret != 0)
+			cap = 0;
+		ret = drmSetClientCap(b->drm.fd, DRM_CLIENT_CAP_ATOMIC, 1);
+		b->atomic_modeset = ((ret == 0) && (cap == 1));
+	}
+	weston_log("DRM: %s atomic modesetting\n",
+		   b->atomic_modeset ? "supports" : "does not support");
+
+	ret = drmGetCap(b->drm.fd, DRM_CAP_ADDFB2_MODIFIERS, &cap);
+	if (ret == 0)
+		b->fb_modifiers = cap;
+	else
+		b->fb_modifiers = 0;
+
+	/*
+	 * KMS support for hardware planes cannot properly synchronize
+	 * without nuclear page flip. Without nuclear/atomic, hw plane
+	 * and cursor plane updates would either tear or cause extra
+	 * waits for vblanks which means dropping the compositor framerate
+	 * to a fraction. For cursors, it's not so bad, so they are
+	 * enabled.
+	 */
+	if (!b->atomic_modeset || getenv("WESTON_FORCE_RENDERER"))
+		b->sprites_are_broken = true;
+
+	ret = drmSetClientCap(b->drm.fd, DRM_CLIENT_CAP_ASPECT_RATIO, 1);
+	b->aspect_ratio_supported = (ret == 0);
+	weston_log("DRM: %s picture aspect ratio\n",
+		   b->aspect_ratio_supported ? "supports" : "does not support");
+
+	return 0;
+}
diff --git a/libweston/backend-sdm/meson.build b/libweston/backend-sdm/meson.build
new file mode 100644
index 0000000..860e76c
--- /dev/null
+++ b/libweston/backend-sdm/meson.build
@@ -0,0 +1,71 @@
+if not get_option('backend-sdm')
+	subdir_done()
+endif
+
+srcs_drm = [
+	'sdm.c',
+	'fb.c',
+	'modes.c',
+	'kms.c',
+	'state-propose.c',
+	'sdm-service/sdm_display_buffer_allocator.cpp',
+	'sdm-service/sdm_display_buffer_allocator.h',
+	'sdm-service/sdm_display_buffer_sync_handler.cpp',
+	'sdm-service/sdm_display_buffer_sync_handler.h',
+	'sdm-service/sdm_display_connect.cpp',
+	'sdm-service/sdm_display_connect.h',
+	'sdm-service/sdm_display.cpp',
+	'sdm-service/sdm_display.h',
+	'sdm-service/sdm_color_mode_intf.h',
+	'sdm-service/sdm_color_mode_intf_impl.h',
+	'sdm-service/sdm_color_mode_intf_impl.cpp',
+	'sdm-service/sdm_display_debugger.cpp',
+	'sdm-service/sdm_display_debugger.h',
+	'sdm-service/sdm_display_socket_handler.cpp',
+	'sdm-service/sdm_display_socket_handler.h',
+	'sdm-service/uevent.c',
+	'sdm-service/uevent.h',
+	linux_dmabuf_unstable_v1_protocol_c,
+	linux_dmabuf_unstable_v1_server_protocol_h,
+	gbm_buffer_backend_protocol_c,
+	gbm_buffer_backend_server_protocol_h,
+	presentation_time_server_protocol_h,
+]
+
+deps_drm = [
+	dep_libdl,
+	dep_libweston_private,
+	dep_session_helper,
+	dep_libdrm,
+	dep_libinput_backend,
+	dependency('libudev', version: '>= 136'),
+	dep_property,
+	dep_glib,
+]
+
+dep_gbm = dependency('gbm', required: false)
+if not dep_gbm.found()
+	error('sdm-backend with GL renderer requires gbm which was not found. Or, you can use \'-Drenderer-gl=false\'.')
+endif
+deps_drm += dep_gbm
+srcs_drm += 'sdm-gbm.c'
+config_h.set('BUILD_DRM_GBM', '1')
+
+if get_option('disable-power-key')
+	config_h.set('DISABLE_POWER_KEY', '1')
+endif
+
+plugin_drm = shared_library(
+	'sdm-backend',
+	srcs_drm,
+	include_directories: common_inc,
+	c_args : ['-Wall'],
+	cpp_args : ['-Wall'],
+	dependencies: deps_drm,
+	name_prefix: '',
+	install: true,
+	install_dir: dir_module_libweston
+)
+env_modmap += 'sdm-backend.so=@0@;'.format(plugin_drm.full_path())
+
+install_headers(backend_drm_h, subdir: dir_include_libweston_install)
diff --git a/libweston/backend-sdm/modes.c b/libweston/backend-sdm/modes.c
new file mode 100644
index 0000000..f7446e7
--- /dev/null
+++ b/libweston/backend-sdm/modes.c
@@ -0,0 +1,213 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2017, 2018 Collabora, Ltd.
+ * Copyright © 2017, 2018 General Electric Company
+ * Copyright (c) 2018 DisplayLink (UK) Ltd.
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ *
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#include "config.h"
+
+#include "sdm-internal.h"
+
+static const char *const aspect_ratio_as_string[] = {
+	[WESTON_MODE_PIC_AR_NONE] = "",
+	[WESTON_MODE_PIC_AR_4_3] = " 4:3",
+	[WESTON_MODE_PIC_AR_16_9] = " 16:9",
+	[WESTON_MODE_PIC_AR_64_27] = " 64:27",
+	[WESTON_MODE_PIC_AR_256_135] = " 256:135",
+};
+
+static const char *
+aspect_ratio_to_string(enum weston_mode_aspect_ratio ratio)
+{
+	if (ratio < 0 || ratio >= ARRAY_LENGTH(aspect_ratio_as_string) ||
+	    !aspect_ratio_as_string[ratio])
+		return " (unknown aspect ratio)";
+
+	return aspect_ratio_as_string[ratio];
+}
+
+/**
+ * Destroys a mode, and removes it from the list.
+ */
+static void
+drm_output_destroy_mode(struct drm_backend *backend, struct drm_mode *mode)
+{
+	if (mode->blob_id)
+		drmModeDestroyPropertyBlob(backend->drm.fd, mode->blob_id);
+	wl_list_remove(&mode->base.link);
+	free(mode);
+}
+
+/** Destroy a list of drm_modes
+ *
+ * @param backend The backend for releasing mode property blobs.
+ * @param mode_list The list linked by drm_mode::base.link.
+ */
+void
+drm_mode_list_destroy(struct drm_backend *backend, struct wl_list *mode_list)
+{
+	struct drm_mode *mode, *next;
+
+	wl_list_for_each_safe(mode, next, mode_list, base.link)
+		drm_output_destroy_mode(backend, mode);
+}
+
+void
+drm_output_print_modes(struct drm_output *output)
+{
+	struct weston_mode *m;
+	struct drm_mode *dm;
+	const char *aspect_ratio;
+
+	wl_list_for_each(m, &output->base.mode_list, link) {
+		dm = to_drm_mode(m);
+
+		aspect_ratio = aspect_ratio_to_string(m->aspect_ratio);
+		weston_log_continue(STAMP_SPACE "%dx%d@%.1f%s%s%s, %.1f MHz\n",
+				    m->width, m->height, m->refresh / 1000.0,
+				    aspect_ratio,
+				    m->flags & WL_OUTPUT_MODE_PREFERRED ?
+				    ", preferred" : "",
+				    m->flags & WL_OUTPUT_MODE_CURRENT ?
+				    ", current" : "",
+				    dm->mode_info.clock / 1000.0);
+	}
+}
+
+/**
+ * Find the closest-matching mode for a given target
+ *
+ * Given a target mode, find the most suitable mode amongst the output's
+ * current mode list to use, preferring the current mode if possible, to
+ * avoid an expensive mode switch.
+ *
+ * @param output DRM output
+ * @param target_mode Mode to attempt to match
+ * @returns Pointer to a mode from the output's mode list
+ */
+struct drm_mode *
+drm_output_choose_mode(struct drm_output *output,
+		       struct weston_mode *target_mode)
+{
+	struct drm_mode *tmp_mode = NULL, *mode_fall_back = NULL, *mode;
+	enum weston_mode_aspect_ratio src_aspect = WESTON_MODE_PIC_AR_NONE;
+	enum weston_mode_aspect_ratio target_aspect = WESTON_MODE_PIC_AR_NONE;
+	struct drm_backend *b;
+
+	b = to_drm_backend(output->base.compositor);
+	target_aspect = target_mode->aspect_ratio;
+	src_aspect = output->base.current_mode->aspect_ratio;
+	if (output->base.current_mode->width == target_mode->width &&
+	    output->base.current_mode->height == target_mode->height &&
+	    (output->base.current_mode->refresh == target_mode->refresh ||
+	     target_mode->refresh == 0)) {
+		if (!b->aspect_ratio_supported || src_aspect == target_aspect)
+			return to_drm_mode(output->base.current_mode);
+	}
+
+	wl_list_for_each(mode, &output->base.mode_list, base.link) {
+
+		src_aspect = mode->base.aspect_ratio;
+		if (mode->mode_info.hdisplay == target_mode->width &&
+		    mode->mode_info.vdisplay == target_mode->height) {
+			if (mode->base.refresh == target_mode->refresh ||
+			    target_mode->refresh == 0) {
+				if (!b->aspect_ratio_supported ||
+				    src_aspect == target_aspect)
+					return mode;
+				else if (!mode_fall_back)
+					mode_fall_back = mode;
+			} else if (!tmp_mode) {
+				tmp_mode = mode;
+			}
+		}
+	}
+
+	if (mode_fall_back)
+		return mode_fall_back;
+
+	return tmp_mode;
+}
+
+int
+drm_output_set_mode(struct weston_output *base,
+		    enum weston_drm_backend_output_mode mode,
+		    const char *modeline)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_mode *current;
+	int width, height, refresh;
+
+	struct drm_head *head = to_drm_head(weston_output_get_first_head(base));
+	output->display_id = head->connector_id;
+
+	if (output->virtual_output)
+		return -1;
+
+        struct DisplayConfigInfo display_config;
+        display_config.x_pixels        = 0;
+        display_config.y_pixels        = 0;
+        display_config.x_dpi           = 0.0f;
+        display_config.y_dpi           = 0.0f;
+        display_config.fps             = 0;
+        display_config.vsync_period_ns = 0;
+        display_config.is_yuv          = false;
+
+        int rc = GetDisplayConfiguration(output->display_id, &display_config);
+        if (rc != 0) {
+            width   = display_config.x_pixels;
+            height  = display_config.y_pixels;
+            refresh = display_config.fps*1000;
+        } else { /* default 1080p, 60 fps */
+            width   = 1920;
+            height  = 1080;
+            refresh = 60*1000;
+        }
+
+	current = zalloc(sizeof(struct drm_mode));
+	if (!current)
+		return -1;
+
+	current->base.width = width;
+	current->base.height = height;
+	current->base.refresh = refresh;
+
+	output->base.current_mode = &current->base;
+	output->base.current_mode->flags |= WL_OUTPUT_MODE_CURRENT;
+
+	wl_list_insert(output->base.mode_list.prev, &current->base.link);
+	/* Set native_ fields, so weston_output_mode_switch_to_native() works */
+	output->base.native_mode = output->base.current_mode;
+	output->base.native_scale = output->base.current_scale;
+
+	return 0;
+}
diff --git a/libweston/backend-sdm/sdm-gbm.c b/libweston/backend-sdm/sdm-gbm.c
new file mode 100644
index 0000000..8206397
--- /dev/null
+++ b/libweston/backend-sdm/sdm-gbm.c
@@ -0,0 +1,286 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2017, 2018 Collabora, Ltd.
+ * Copyright © 2017, 2018 General Electric Company
+ * Copyright (c) 2018 DisplayLink (UK) Ltd.
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ *
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#include "config.h"
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <dlfcn.h>
+
+#include "sdm-internal.h"
+#include "pixman-renderer.h"
+#include "pixel-formats.h"
+#include "renderer-gl/gl-renderer.h"
+#include "shared/weston-egl-ext.h"
+#include "linux-dmabuf.h"
+#include "linux-explicit-synchronization.h"
+
+struct gl_renderer_interface *gl_renderer;
+
+static struct gbm_device *
+create_gbm_device(int fd)
+{
+	struct gbm_device *gbm;
+
+	gl_renderer = weston_load_module("gl-renderer.so",
+					 "gl_renderer_interface");
+	if (!gl_renderer)
+		return NULL;
+
+	gbm = gbm_create_device(fd);
+
+	return gbm;
+}
+
+/* When initializing EGL, if the preferred buffer format isn't available
+ * we may be able to substitute an ARGB format for an XRGB one.
+ *
+ * This returns 0 if substitution isn't possible, but 0 might be a
+ * legitimate format for other EGL platforms, so the caller is
+ * responsible for checking for 0 before calling gl_renderer->create().
+ *
+ * This works around https://bugs.freedesktop.org/show_bug.cgi?id=89689
+ * but it's entirely possible we'll see this again on other implementations.
+ */
+static uint32_t
+fallback_format_for(uint32_t format)
+{
+	const struct pixel_format_info *pf;
+
+	pf = pixel_format_get_info_by_opaque_substitute(format);
+	if (!pf)
+		return 0;
+
+	return pf->format;
+}
+
+static int
+drm_backend_create_gl_renderer(struct drm_backend *b)
+{
+	uint32_t format[3] = {
+		b->gbm_format,
+		fallback_format_for(b->gbm_format),
+		0,
+	};
+	struct gl_renderer_display_options options = {
+		.egl_platform = EGL_PLATFORM_GBM_KHR,
+		.egl_native_display = b->gbm,
+		.egl_surface_type = EGL_WINDOW_BIT,
+		.drm_formats = format,
+		.drm_formats_count = 2,
+	};
+
+	if (format[1])
+		options.drm_formats_count = 3;
+
+	if (gl_renderer->display_create(b->compositor, &options) < 0)
+		return -1;
+
+	return 0;
+}
+
+int
+init_egl(struct drm_backend *b)
+{
+	b->gbm = create_gbm_device(b->drm.fd);
+
+	if (!b->gbm)
+		return -1;
+
+	if (drm_backend_create_gl_renderer(b) < 0) {
+		gbm_device_destroy(b->gbm);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void
+create_gbm_surface(struct gbm_device *gbm, struct drm_output *output)
+{
+	struct weston_mode *mode = output->base.current_mode;
+
+	/* We may allocate with no modifiers in the following situations:
+	 *
+	 * 1. old GBM version, so HAVE_GBM_MODIFIERS is false;
+	 * 2. the KMS driver does not support modifiers;
+	 * 3. if allocating with modifiers failed, what can happen when the KMS
+	 *    display device supports modifiers but the GBM driver does not,
+	 *    e.g. the old i915 Mesa driver.
+	 */
+	if (!output->gbm_surface)
+		output->gbm_surface = gbm_surface_create(gbm,
+							 mode->width, mode->height,
+							 output->gbm_format,
+							 output->gbm_bo_flags);
+}
+
+/* Init output state that depends on gl or gbm */
+int
+drm_output_init_egl(struct drm_output *output, struct drm_backend *b)
+{
+	uint32_t format[2] = {
+		output->gbm_format,
+		fallback_format_for(output->gbm_format),
+	};
+	struct gl_renderer_output_options options = {
+		.drm_formats = format,
+		.drm_formats_count = 1,
+	};
+
+	assert(output->gbm_surface == NULL);
+	create_gbm_surface(b->gbm, output);
+	if (!output->gbm_surface) {
+		weston_log("failed to create gbm surface\n");
+		return -1;
+	}
+
+	if (options.drm_formats[1])
+		options.drm_formats_count = 2;
+	options.window_for_legacy = (EGLNativeWindowType) output->gbm_surface;
+	options.window_for_platform = output->gbm_surface;
+	if (gl_renderer->output_window_create(&output->base, &options) < 0) {
+		weston_log("failed to create gl renderer output state\n");
+		gbm_surface_destroy(output->gbm_surface);
+		output->gbm_surface = NULL;
+		return -1;
+	}
+
+	return 0;
+}
+
+void
+drm_output_fini_egl(struct drm_output *output)
+{
+	gl_renderer->output_destroy(&output->base);
+	gbm_surface_destroy(output->gbm_surface);
+	output->gbm_surface = NULL;
+}
+
+struct drm_fb *
+drm_output_render_gl(struct drm_output *output, pixman_region32_t *damage)
+{
+	struct drm_backend *b = to_drm_backend(output->base.compositor);
+	struct gbm_bo *bo;
+	struct drm_fb *ret;
+
+	output->base.compositor->renderer->repaint_output(&output->base,
+							  damage);
+
+	bo = gbm_surface_lock_front_buffer(output->gbm_surface);
+	if (!bo) {
+		weston_log("failed to lock front buffer: %s\n",
+			   strerror(errno));
+		return NULL;
+	}
+
+	/* The renderer always produces an opaque image. */
+	ret = drm_fb_get_from_bo(bo, b, true, BUFFER_GBM_SURFACE);
+	if (!ret) {
+		weston_log("failed to get drm_fb for bo\n");
+		gbm_surface_release_buffer(output->gbm_surface, bo);
+		return NULL;
+	}
+	ret->gbm_surface = output->gbm_surface;
+
+	return ret;
+}
+
+static void
+switch_to_gl_renderer(struct drm_backend *b)
+{
+	struct drm_output *output;
+	bool dmabuf_support_inited;
+	bool linux_explicit_sync_inited;
+
+	if (!b->use_pixman)
+		return;
+
+	dmabuf_support_inited = !!b->compositor->renderer->import_dmabuf;
+	linux_explicit_sync_inited =
+		b->compositor->capabilities & WESTON_CAP_EXPLICIT_SYNC;
+
+	weston_log("Switching to GL renderer\n");
+
+	b->gbm = create_gbm_device(b->drm.fd);
+	if (!b->gbm) {
+		weston_log("Failed to create gbm device. "
+			   "Aborting renderer switch\n");
+		return;
+	}
+
+	wl_list_for_each(output, &b->compositor->output_list, base.link)
+		pixman_renderer_output_destroy(&output->base);
+
+	b->compositor->renderer->destroy(b->compositor);
+
+	if (drm_backend_create_gl_renderer(b) < 0) {
+		gbm_device_destroy(b->gbm);
+		weston_log("Failed to create GL renderer. Quitting.\n");
+		/* FIXME: we need a function to shutdown cleanly */
+		assert(0);
+	}
+
+	wl_list_for_each(output, &b->compositor->output_list, base.link)
+		drm_output_init_egl(output, b);
+
+	b->use_pixman = 0;
+
+	if (!dmabuf_support_inited && b->compositor->renderer->import_dmabuf) {
+		if (linux_dmabuf_setup(b->compositor) < 0)
+			weston_log("Error: initializing dmabuf "
+				   "support failed.\n");
+	}
+
+	if (!linux_explicit_sync_inited &&
+	    (b->compositor->capabilities & WESTON_CAP_EXPLICIT_SYNC)) {
+		if (linux_explicit_synchronization_setup(b->compositor) < 0)
+			weston_log("Error: initializing explicit "
+				   " synchronization support failed.\n");
+	}
+}
+
+void
+renderer_switch_binding(struct weston_keyboard *keyboard,
+			const struct timespec *time, uint32_t key, void *data)
+{
+	struct drm_backend *b =
+		to_drm_backend(keyboard->seat->compositor);
+
+	switch_to_gl_renderer(b);
+}
diff --git a/libweston/backend-sdm/sdm-internal.h b/libweston/backend-sdm/sdm-internal.h
new file mode 100644
index 0000000..fbb1029
--- /dev/null
+++ b/libweston/backend-sdm/sdm-internal.h
@@ -0,0 +1,519 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2017, 2018 Collabora, Ltd.
+ * Copyright © 2017, 2018 General Electric Company
+ * Copyright (c) 2018 DisplayLink (UK) Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ * Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ *
+ */
+
+#ifndef DRM_INTERNAL_H_
+#define DRM_INTERNAL_H_
+
+#include "config.h"
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/input.h>
+#include <linux/vt.h>
+#include <assert.h>
+#include <sys/mman.h>
+#include <time.h>
+
+#include <xf86drm.h>
+#include <xf86drmMode.h>
+#include <drm_fourcc.h>
+
+#ifdef BUILD_DRM_GBM
+#include <gbm.h>
+#endif
+#include <libudev.h>
+
+#include <libweston/libweston.h>
+#include <libweston/backend-drm.h>
+#include <libweston/weston-log.h>
+#include "shared/helpers.h"
+#include "libinput-seat.h"
+#include "backend.h"
+#include "libweston-internal.h"
+
+#include "sdm-service/sdm_display_interface.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * A small wrapper to print information into the 'drm-backend' debug scope.
+ *
+ * The following conventions are used to print variables:
+ *
+ *  - fixed uint32_t values, including Weston object IDs such as weston_output
+ *    IDs, DRM object IDs such as CRTCs or properties, and GBM/DRM formats:
+ *      "%lu (0x%lx)" (unsigned long) value, (unsigned long) value
+ *
+ *  - fixed uint64_t values, such as DRM property values (including object IDs
+ *    when used as a value):
+ *      "%llu (0x%llx)" (unsigned long long) value, (unsigned long long) value
+ *
+ *  - non-fixed-width signed int:
+ *      "%d" value
+ *
+ *  - non-fixed-width unsigned int:
+ *      "%u (0x%x)" value, value
+ *
+ *  - non-fixed-width unsigned long:
+ *      "%lu (0x%lx)" value, value
+ *
+ * Either the integer or hexadecimal forms may be omitted if it is known that
+ * one representation is not useful (e.g. width/height in hex are rarely what
+ * you want).
+ *
+ * This is to avoid implicit widening or narrowing when we use fixed-size
+ * types: uint32_t can be resolved by either unsigned int or unsigned long
+ * on a 32-bit system but only unsigned int on a 64-bit system, with uint64_t
+ * being unsigned long long on a 32-bit system and unsigned long on a 64-bit
+ * system. To avoid confusing side effects, we explicitly cast to the widest
+ * possible type and use a matching format specifier.
+ */
+#define drm_debug(b, ...) \
+	weston_log_scope_printf((b)->debug, __VA_ARGS__)
+
+#define MAX_CLONED_CONNECTORS 4
+
+/**
+ * Represents the values of an enum-type KMS property
+ */
+struct drm_property_enum_info {
+	const char *name; /**< name as string (static, not freed) */
+	bool valid; /**< true if value is supported; ignore if false */
+	uint64_t value; /**< raw value */
+};
+
+enum wdrm_content_protection_state {
+	WDRM_CONTENT_PROTECTION_UNDESIRED = 0,
+	WDRM_CONTENT_PROTECTION_DESIRED,
+	WDRM_CONTENT_PROTECTION_ENABLED,
+	WDRM_CONTENT_PROTECTION__COUNT
+};
+
+enum wdrm_hdcp_content_type {
+	WDRM_HDCP_CONTENT_TYPE0 = 0,
+	WDRM_HDCP_CONTENT_TYPE1,
+	WDRM_HDCP_CONTENT_TYPE__COUNT
+};
+
+enum wdrm_dpms_state {
+	WDRM_DPMS_STATE_OFF = 0,
+	WDRM_DPMS_STATE_ON,
+	WDRM_DPMS_STATE_STANDBY, /* unused */
+	WDRM_DPMS_STATE_SUSPEND, /* unused */
+	WDRM_DPMS_STATE__COUNT
+};
+
+struct drm_backend {
+	struct weston_backend base;
+	struct weston_compositor *compositor;
+
+	struct udev *udev;
+	struct wl_event_source *drm_source;
+
+	struct udev_monitor *udev_monitor;
+	struct wl_event_source *udev_drm_source;
+
+	struct {
+		int id;
+		int fd;
+		char *filename;
+		dev_t devnum;
+	} drm;
+	struct gbm_device *gbm;
+	struct wl_listener session_listener;
+	uint32_t gbm_format;
+
+	/* we need these parameters in order to not fail drmModeAddFB2()
+	 * due to out of bounds dimensions, and then mistakenly set
+	 * sprites_are_broken:
+	 */
+	int min_width, max_width;
+	int min_height, max_height;
+
+	void *repaint_data;
+
+	bool state_invalid;
+
+	/* CRTC IDs not used by any enabled output. */
+	struct wl_array unused_crtcs;
+
+	bool sprites_are_broken;
+	bool cursors_are_broken;
+
+	bool universal_planes;
+	bool atomic_modeset;
+
+	bool use_pixman;
+	bool use_pixman_shadow;
+
+	struct udev_input input;
+
+	int32_t cursor_width;
+	int32_t cursor_height;
+
+	uint32_t pageflip_timeout;
+
+	bool shutting_down;
+
+	bool aspect_ratio_supported;
+
+	bool fb_modifiers;
+
+	struct weston_log_scope *debug;
+
+	/* SDM data */
+	struct DisplayConfigInfo display_config;
+};
+
+struct drm_mode {
+	struct weston_mode base;
+	drmModeModeInfo mode_info;
+	uint32_t blob_id;
+};
+
+enum drm_fb_type {
+	BUFFER_INVALID = 0, /**< never used */
+	BUFFER_CLIENT, /**< directly sourced from client */
+	BUFFER_DMABUF, /**< imported from linux_dmabuf client */
+	BUFFER_PIXMAN_DUMB, /**< internal Pixman rendering */
+	BUFFER_PIXMAN_GBM,  /**< internal Pixman rendering with GBM */
+	BUFFER_GBM_SURFACE, /**< internal EGL rendering */
+	BUFFER_CURSOR, /**< internal cursor buffer */
+};
+
+struct drm_fb {
+	enum drm_fb_type type;
+
+	int refcnt;
+
+	uint32_t fb_id, size;
+	uint32_t handles[4];
+	uint32_t strides[4];
+	uint32_t offsets[4];
+	int num_planes;
+	const struct pixel_format_info *format;
+	uint64_t modifier;
+	int width, height;
+	int fd;
+
+	int ion_fd;
+
+	struct weston_buffer_reference buffer_ref;
+	struct weston_buffer_release_reference buffer_release_ref;
+
+	/* Used by gbm fbs */
+	struct gbm_bo *bo;
+	struct gbm_surface *gbm_surface;
+
+	/* Used by dumb fbs */
+	void *map;
+};
+
+struct sdm_layer {
+	struct wl_list link; /* drm_output::sdm_layer_list */
+	struct weston_view *view;
+	struct weston_buffer_reference buffer_ref;
+	bool is_cursor;
+	bool is_skip;
+	bool is_scanout;
+	struct gbm_bo *bo;
+	struct drm_fb *fb;
+	uint32_t composition_type; /* type: enum SDM_COMPOSITION_XXXXX */
+	pixman_region32_t overlap;
+	int acquire_fence_fd;
+	int release_fence_fd;
+};
+
+struct drm_head {
+	struct weston_head base;
+	struct drm_backend *backend;
+
+	uint32_t connector_id;
+
+	struct backlight *backlight;
+
+	drmModeModeInfo inherited_mode;	/**< Original mode on the connector */
+	uint32_t inherited_crtc_id;	/**< Original CRTC assignment */
+};
+
+struct drm_output {
+	struct weston_output base;
+	struct drm_backend *backend;
+
+	bool page_flip_pending;
+	bool atomic_complete_pending;
+	bool destroy_pending;
+	bool disable_pending;
+	bool dpms_off_pending;
+
+	uint32_t gbm_cursor_handle[2];
+	struct drm_fb *gbm_cursor_fb[2];
+	struct drm_plane *cursor_plane;
+	struct weston_view *cursor_view;
+	int current_cursor;
+
+	struct gbm_surface *gbm_surface;
+	uint32_t gbm_format;
+	uint32_t gbm_bo_flags;
+
+	struct drm_fb *next_fb, *current_fb;
+
+	struct gbm_bo *dumb_bo[2];
+	pixman_image_t *image[2];
+	int current_image;
+	pixman_region32_t previous_damage;
+
+	struct vaapi_recorder *recorder;
+	struct wl_listener recorder_frame_listener;
+
+	struct wl_event_source *pageflip_timer;
+
+	int vblank_ev_fd;
+	struct wl_event_source *vblank_ev_source;
+	struct {
+		unsigned int frame;
+		unsigned int sec;
+		unsigned int usec;
+	} last_vblank;
+
+	bool virtual_output;
+
+	submit_frame_cb virtual_submit_frame;
+
+	int view_count; //counts number of sdm layers created
+	struct wl_list sdm_layer_list;  /* sdm_layer::link      */
+	struct wl_list prev_sdm_layer_list;  /* prev_sdm_layer::link  */
+	enum dpms_enum dpms; //tracks dpms level of output
+	int display_id;
+	int retire_fence_fd;
+};
+
+static inline struct drm_head *
+to_drm_head(struct weston_head *base)
+{
+	return container_of(base, struct drm_head, base);
+}
+
+static inline struct drm_output *
+to_drm_output(struct weston_output *base)
+{
+	return container_of(base, struct drm_output, base);
+}
+
+static inline struct drm_backend *
+to_drm_backend(struct weston_compositor *base)
+{
+	return container_of(base->backend, struct drm_backend, base);
+}
+
+static inline struct drm_mode *
+to_drm_mode(struct weston_mode *base)
+{
+	return container_of(base, struct drm_mode, base);
+}
+
+void
+sdm_weston_transformed_rect(struct drm_output *output,
+				 pixman_box32_t *tbox, pixman_box32_t box);
+
+void
+sdm_weston_global_transform_rect(struct weston_view *ev,
+				pixman_box32_t *box, float *x1, float *y1,
+				float *x2, float *y2);
+
+static inline bool
+drm_view_transform_supported(struct weston_view *ev, struct weston_output *output)
+{
+	struct weston_buffer_viewport *viewport = &ev->surface->buffer_viewport;
+
+	/* This will incorrectly disallow cases where the combination of
+	 * buffer and view transformations match the output transform.
+	 * Fixing this requires a full analysis of the transformation
+	 * chain. */
+	if (ev->transform.enabled &&
+	    ev->transform.matrix.type >= WESTON_MATRIX_TRANSFORM_ROTATE)
+		return false;
+
+	if (viewport->buffer.transform != output->transform)
+		return false;
+
+	return true;
+}
+
+int
+drm_mode_ensure_blob(struct drm_backend *backend, struct drm_mode *mode);
+
+void
+drm_mode_list_destroy(struct drm_backend *backend, struct wl_list *mode_list);
+
+void
+drm_output_print_modes(struct drm_output *output);
+
+int
+drm_output_set_mode(struct weston_output *base,
+		    enum weston_drm_backend_output_mode mode,
+		    const char *modeline);
+
+extern struct drm_property_enum_info dpms_state_enums[];
+extern struct drm_property_enum_info content_protection_enums[];
+extern struct drm_property_enum_info hdcp_content_type_enums[];
+
+int
+init_kms_caps(struct drm_backend *b);
+
+void
+drm_output_update_msc(struct drm_output *output, unsigned int seq);
+void
+drm_output_update_complete(struct drm_output *output, uint32_t flags,
+			   unsigned int sec, unsigned int usec);
+int
+on_drm_input(int fd, uint32_t mask, void *data);
+
+struct drm_fb *
+drm_fb_ref(struct drm_fb *fb);
+void
+drm_fb_unref(struct drm_fb *fb);
+
+struct drm_fb *
+drm_fb_create_dumb(struct drm_backend *b, int width, int height,
+		   uint32_t format);
+struct drm_fb *
+drm_fb_get_from_bo(struct gbm_bo *bo, struct drm_backend *backend,
+		   bool is_opaque, enum drm_fb_type type);
+
+#ifdef BUILD_DRM_GBM
+extern struct drm_fb *
+drm_fb_get_from_view(struct drm_output *state, struct weston_view *ev);
+extern bool
+drm_can_scanout_dmabuf(struct weston_compositor *ec,
+		       struct linux_dmabuf_buffer *dmabuf);
+#else
+static inline struct drm_fb *
+drm_fb_get_from_view(struct drm_output *output, struct weston_view *ev)
+{
+	weston_log("Not built with BUILD_DRM_GBM set\n");
+	return NULL;
+}
+
+static inline bool
+drm_can_scanout_dmabuf(struct weston_compositor *ec,
+		       struct linux_dmabuf_buffer *dmabuf)
+{
+	return false;
+}
+#endif
+
+void
+destroy_sdm_layer(struct sdm_layer *layer);
+
+void
+drm_assign_planes(struct weston_output *output_base, void *repaint_data);
+
+int
+parse_gbm_format(const char *s, uint32_t default_value, uint32_t *gbm_format);
+
+extern struct gl_renderer_interface *gl_renderer;
+
+#ifdef BUILD_DRM_VIRTUAL
+extern int
+drm_backend_init_virtual_output_api(struct weston_compositor *compositor);
+#else
+inline static int
+drm_backend_init_virtual_output_api(struct weston_compositor *compositor)
+{
+	return 0;
+}
+#endif
+
+#ifdef BUILD_DRM_GBM
+int
+init_egl(struct drm_backend *b);
+
+int
+drm_output_init_egl(struct drm_output *output, struct drm_backend *b);
+
+void
+drm_output_fini_egl(struct drm_output *output);
+
+struct drm_fb *
+drm_output_render_gl(struct drm_output *output, pixman_region32_t *damage);
+
+void
+renderer_switch_binding(struct weston_keyboard *keyboard,
+			const struct timespec *time, uint32_t key, void *data);
+#else
+inline static int
+init_egl(struct drm_backend *b)
+{
+	weston_log("Compiled without GBM/EGL support\n");
+	return -1;
+}
+
+inline static int
+drm_output_init_egl(struct drm_output *output, struct drm_backend *b)
+{
+	return -1;
+}
+
+inline static void
+drm_output_fini_egl(struct drm_output *output)
+{
+}
+
+inline static struct drm_fb *
+drm_output_render_gl(struct drm_output *output, pixman_region32_t *damage)
+{
+	return NULL;
+}
+
+inline static void
+renderer_switch_binding(struct weston_keyboard *keyboard,
+			const struct timespec *time, uint32_t key, void *data)
+{
+	weston_log("Compiled without GBM/EGL support\n");
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/libweston/backend-sdm/sdm-service/sdm_color_mode_intf.h b/libweston/backend-sdm/sdm-service/sdm_color_mode_intf.h
new file mode 100644
index 0000000..e912cbb
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_color_mode_intf.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#ifndef __SDM_COLOR_MODE_INTF_H__
+#define __SDM_COLOR_MODE_INTF_H__
+
+#include <color_metadata.h>
+
+namespace sdm {
+
+class SDMColorModeIntf {
+ public:
+  virtual ~SDMColorModeIntf() {}
+  virtual DisplayError Init() = 0;
+  virtual DisplayError DeInit() = 0;
+  virtual bool IsModeSupported(ColorPrimaries primary, GammaTransfer transfer,
+                                          RenderIntent intent) = 0;
+  virtual DisplayError SetColorModeWithRenderIntent(ColorMode mode, bool hdr_present) = 0;
+  virtual DisplayError SetColorTransform(const float *matrix) = 0;
+};
+
+class SDMColorModeIntfFactory {
+ public:
+  std::unique_ptr<SDMColorModeIntf> GetSDMColorModeIntf(DisplayType display_type,
+                                                DisplayInterface *display_intf);
+};
+
+extern "C" SDMColorModeIntfFactory *GetSDMColorModeIntfFactory();
+
+}  // namespace sdm
+
+#endif  // __SDM_COLOR_MODE_INTF_H__
\ No newline at end of file
diff --git a/libweston/backend-sdm/sdm-service/sdm_color_mode_intf_impl.cpp b/libweston/backend-sdm/sdm-service/sdm_color_mode_intf_impl.cpp
new file mode 100644
index 0000000..c22a302
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_color_mode_intf_impl.cpp
@@ -0,0 +1,464 @@
+/*
+ * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Changes from Qualcomm Innovation Center, Inc are provided under the following license:
+ *
+ * Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#include <utils/constants.h>
+#include "display_properties.h"
+#include <algorithm>
+
+#include "sdm-service/sdm_display_debugger.h"
+#include "sdm-service/sdm_color_mode_intf_impl.h"
+
+#define __CLASS__ "SDMColorModeImpl"
+
+#define DEFAULT_RENDER_INTENT kRenderIntentColorimetric
+#define DEFAULT_DYNAMIC_RANGE kSdrType
+
+namespace sdm {
+
+#define MAX_PROP_STR_SIZE 64
+
+static SDMColorModeIntfFactory color_mode_intf_factory_;
+
+SDMColorModeIntfFactory *GetSDMColorModeIntfFactory() { return &color_mode_intf_factory_; }
+
+std::unique_ptr<SDMColorModeIntf> SDMColorModeIntfFactory::GetSDMColorModeIntf(
+                    DisplayType display_type, DisplayInterface *display_intf) {
+  if (display_type == kBuiltIn) {
+    return std::unique_ptr<SDMColorModeIntf>(new SDMColorModeImplStc(display_intf));
+  }
+
+  if (display_type == kPluggable) {
+    return std::unique_ptr<SDMColorModeIntf>(new SDMColorModeImpl(display_intf));
+  }
+
+  return std::unique_ptr<SDMColorModeIntf>();
+}
+
+SDMColorModeImpl::SDMColorModeImpl(DisplayInterface *display_intf) : display_intf_(display_intf) {}
+
+DisplayError SDMColorModeImpl::Init() {
+  PopulateColorModes();
+  return kErrorNone;
+}
+
+DisplayError SDMColorModeImpl::DeInit() {
+  color_mode_map_.clear();
+  return kErrorNone;
+}
+
+bool SDMColorModeImpl::IsModeSupported(ColorPrimaries primary, GammaTransfer transfer,
+                                        RenderIntent intent) {
+  if (color_mode_map_.find(primary) == color_mode_map_.end()) {
+    return false;
+  }
+
+  if (color_mode_map_[primary].find(transfer) == color_mode_map_[primary].end()) {
+    return false;
+  }
+
+  if (color_mode_map_[primary][transfer].find(intent) ==
+                                      color_mode_map_[primary][transfer].end()) {
+    return false;
+  }
+
+  return true;
+}
+
+DisplayError SDMColorModeImpl::GetValidColorMode(ColorPrimaries primary, GammaTransfer transfer,
+                          RenderIntent *intent, DynamicRangeType *dynamic_range) {
+  if (color_mode_map_.find(primary) == color_mode_map_.end()) {
+    DLOGE("Could not find color primary: %d", primary);
+    return kErrorNotSupported;
+  }
+
+  if (color_mode_map_[primary].find(transfer) == color_mode_map_[primary].end()) {
+    DLOGE("Could not find transfer %d in primary %d", transfer, primary);
+    return kErrorNotSupported;
+  }
+
+  if (color_mode_map_[primary][transfer].find(*intent) ==
+                                      color_mode_map_[primary][transfer].end()) {
+    // Fall back to default render intent if current render intent is not supported
+    DLOGW("Could not find intent %d, checking for intent %d in primary %d, transfer %d",
+                                      *intent, DEFAULT_RENDER_INTENT, primary, transfer);
+    *intent = DEFAULT_RENDER_INTENT;
+
+    if (color_mode_map_[primary][transfer].find(*intent) ==
+                                      color_mode_map_[primary][transfer].end()) {
+      DLOGE("Failed to find intent %d in primary %d, transfer %d",
+                                  *intent, primary, transfer);
+      return kErrorNotSupported;
+    }
+  }
+
+  if (color_mode_map_[primary][transfer][*intent].find(*dynamic_range) ==
+                              color_mode_map_[primary][transfer][*intent].end()) {
+    // Fall back to default dynamic range if current render intent is not supported
+    DLOGW("Could not find range %d, checking for range %d in intent %d, primary %d, transfer %d",
+                              *dynamic_range, DEFAULT_DYNAMIC_RANGE, *intent, primary, transfer);
+    *dynamic_range = DEFAULT_DYNAMIC_RANGE;
+
+    if (color_mode_map_[primary][transfer][*intent].find(*dynamic_range) ==
+                            color_mode_map_[primary][transfer][*intent].end()) {
+      DLOGE("Failed to find range %d, in intent %d, primary %d, transfer %d",
+                                  *dynamic_range, *intent, primary, transfer);
+      return kErrorNotSupported;
+    }
+  }
+  return kErrorNone;
+}
+
+DisplayError SDMColorModeImpl::SetColorModeWithRenderIntent(ColorMode color_mode,
+                                                            bool hdr_present) {
+  if (current_color_mode_.gamut == color_mode.gamut &&
+      current_color_mode_.gamma == color_mode.gamma &&
+      current_color_mode_.intent == color_mode.intent &&
+      ((hdr_present && (curr_dynamic_range_ == kHdrType)) ||
+      (!hdr_present && (curr_dynamic_range_ == kSdrType)))) {
+      return kErrorNone;
+  }
+
+  ColorPrimaries primary = color_mode.gamut;
+  GammaTransfer transfer = color_mode.gamma;
+  RenderIntent intent = color_mode.intent;
+  DynamicRangeType dynamic_range = hdr_present ? kHdrType : kSdrType;
+
+  DisplayError error = GetValidColorMode(primary, transfer, &intent, &dynamic_range);
+  if (error != kErrorNone) {
+    return error;
+  }
+
+  std::string mode_string = color_mode_map_[primary][transfer][intent][dynamic_range];
+  DLOGI("Applying color mode: %s", mode_string.c_str());
+
+  error = display_intf_->SetColorMode(mode_string);
+  if (error != kErrorNone) {
+    DLOGE("Failed to apply mode: gamut = %d, gamma = %d, intent = %d, range = %d, name = %s\
+      , err %d", primary, transfer, intent, dynamic_range, mode_string.c_str(), error);
+    return kErrorNotSupported;
+  }
+
+  // Overwrite the intent in case default intent was applied
+  color_mode.intent = intent;
+
+  current_color_mode_ = color_mode;
+  curr_dynamic_range_ = dynamic_range;
+  DLOGV_IF(kTagClient, "Successfully applied mode: gamut = %d, gamma = %d, intent = %d, "
+      "range = %d, name = %s", primary, transfer, intent, dynamic_range, mode_string.c_str());
+  return kErrorNone;
+}
+
+void SDMColorModeImpl::PopulateColorModes() {
+  uint32_t color_mode_count = 0;
+  // SDM returns modes which have attributes defining mode and rendering intent
+  DisplayError error = display_intf_->GetColorModeCount(&color_mode_count);
+  if (error != kErrorNone || (color_mode_count == 0)) {
+    DLOGW("GetColorModeCount failed, use native color mode");
+    color_mode_map_[ColorPrimaries_BT709_5][Transfer_sRGB][kRenderIntentNative][kSdrType] =
+                                                        "hal_native_identity";
+    return;
+  }
+
+  DLOGV_IF(kTagClient, "Color Modes supported count = %d", color_mode_count);
+
+  std::vector<std::string> color_modes(color_mode_count);
+  error = display_intf_->GetColorModes(&color_mode_count, &color_modes);
+  for (uint32_t i = 0; i < color_mode_count; i++) {
+    std::string &mode_string = color_modes.at(i);
+    DLOGV_IF(kTagClient, "Color Mode[%d] = %s", i, mode_string.c_str());
+    AttrVal attr;
+    error = display_intf_->GetColorModeAttr(mode_string, &attr);
+    std::string color_gamut = kNative, dynamic_range = kSdr, pic_quality = kStandard, transfer;
+    int int_render_intent = -1;
+    if (!attr.empty()) {
+      for (auto &it : attr) {
+        if (it.first.find(kColorGamutAttribute) != std::string::npos) {
+          color_gamut = it.second;
+        } else if (it.first.find(kDynamicRangeAttribute) != std::string::npos) {
+          dynamic_range = it.second;
+        } else if (it.first.find(kPictureQualityAttribute) != std::string::npos) {
+          pic_quality = it.second;
+        } else if (it.first.find(kGammaTransferAttribute) != std::string::npos) {
+          transfer = it.second;
+        } else if (it.first.find(kRenderIntentAttribute) != std::string::npos) {
+          int_render_intent = std::stoi(it.second);
+        }
+      }
+
+      if (int_render_intent < 0 || int_render_intent > MAX_EXTENDED_RENDER_INTENT) {
+        DLOGW("Invalid render intent %d for mode %s", int_render_intent, mode_string.c_str());
+        continue;
+      }
+      DLOGV_IF(kTagClient,
+               "color_gamut : %s, dynamic_range : %s, pic_quality : %s, "
+               "render_intent : %d",
+               color_gamut.c_str(), dynamic_range.c_str(), pic_quality.c_str(), int_render_intent);
+
+      RenderIntent intent = static_cast<RenderIntent>(int_render_intent + 1);
+      if (color_gamut == kNative) {
+        color_mode_map_[ColorPrimaries_BT709_5][Transfer_sRGB][kRenderIntentNative][kSdrType]
+          = mode_string;
+      }
+
+      if (color_gamut == kSrgb && dynamic_range == kSdr) {
+        color_mode_map_[ColorPrimaries_BT709_5][Transfer_sRGB][intent][kSdrType] = mode_string;
+      }
+
+      if (color_gamut == kDcip3 && dynamic_range == kSdr) {
+        color_mode_map_[ColorPrimaries_DCIP3][Transfer_sRGB][intent][kSdrType] = mode_string;
+      }
+      if (color_gamut == kDcip3 && dynamic_range == kHdr) {
+        if (display_intf_->IsSupportSsppTonemap()) {
+          color_mode_map_[ColorPrimaries_DCIP3][Transfer_sRGB][intent][kHdrType] = mode_string;
+        } else if (pic_quality == kStandard) {
+          color_mode_map_[ColorPrimaries_BT2020][Transfer_SMPTE_ST2084][intent][kHdrType]
+            = mode_string;
+          color_mode_map_[ColorPrimaries_BT2020][Transfer_HLG][intent][kHdrType] = mode_string;
+        }
+      } else if (color_gamut == kBt2020) {
+        if (transfer == kSt2084) {
+          color_mode_map_[ColorPrimaries_BT2020][Transfer_SMPTE_ST2084][kRenderIntentColorimetric]\
+            [kHdrType] = mode_string;
+        } else if (transfer == kHlg) {
+          color_mode_map_[ColorPrimaries_BT2020][Transfer_HLG][kRenderIntentColorimetric][kHdrType]
+            = mode_string;
+        } else if (transfer == kSrgb) {
+          color_mode_map_[ColorPrimaries_BT2020][Transfer_sRGB][kRenderIntentColorimetric][kHdrType]
+            = mode_string;
+        }
+      }
+    } else {
+      // Look at the mode names, if no attributes are found
+      if (mode_string.find("hal_native") != std::string::npos) {
+        color_mode_map_[ColorPrimaries_BT709_5][Transfer_sRGB][kRenderIntentNative][kSdrType]
+          = mode_string;
+      }
+    }
+  }
+}
+
+#undef __CLASS__
+#define __CLASS__ "SDMColorModeImplStc"
+
+SDMColorModeImplStc::SDMColorModeImplStc(DisplayInterface *display_intf) :
+  display_intf_(display_intf) {}
+
+DisplayError SDMColorModeImplStc::Init() {
+  DisplayError error = display_intf_->GetStcColorModes(&stc_mode_list_);
+  if (error != kErrorNone) {
+    DLOGW("Failed to get Stc color modes, error %d", error);
+    stc_mode_list_.list.clear();
+  } else {
+    DLOGI("Stc mode count %zu", stc_mode_list_.list.size());
+  }
+
+  PopulateColorModes();
+  return kErrorNone;
+}
+
+DisplayError SDMColorModeImplStc::DeInit() {
+  stc_mode_list_.list.clear();
+  color_mode_map_.clear();
+  return kErrorNone;
+}
+
+DisplayError SDMColorModeImplStc::SetColorTransform(const float *matrix) {
+  if (!matrix) {
+    DLOGE("Invalid parameters : matrix %pK", matrix);
+    return kErrorParameters;
+  }
+  double color_matrix[kColorTransformMatrixCount] = {0};
+  CopyColorTransformMatrix(matrix, color_matrix);
+
+  DisplayError error = display_intf_->SetColorTransform(kColorTransformMatrixCount, color_matrix);
+  if (error != kErrorNone) {
+    DLOGE("Failed to set Color Transform Matrix");
+    error = kErrorNotSupported;
+  }
+  CopyColorTransformMatrix(matrix, color_matrix_);
+  return error;
+}
+
+DisplayError SDMColorModeImplStc::RestoreColorTransform() {
+  DisplayError error = display_intf_->SetColorTransform(kColorTransformMatrixCount, color_matrix_);
+  if (error != kErrorNone) {
+    DLOGE("Failed to set Color Transform");
+    return kErrorParameters;
+  }
+
+  return kErrorNone;
+}
+
+void SDMColorModeImplStc::PopulateColorModes() {
+  bool allow_tonemap_native = 0;
+  char property[MAX_PROP_STR_SIZE] = {0};
+
+  SdmDisplayDebugger::Get()->GetProperty(ALLOW_TONEMAP_NATIVE, property);
+  if (!(std::string(property)==std::string("1"))) {
+      allow_tonemap_native = true;
+  }
+
+  if (!stc_mode_list_.list.size()) {
+    snapdragoncolor::ColorMode color_mode = {};
+    color_mode.intent = snapdragoncolor::kNative;
+    color_mode.gamut = allow_tonemap_native ? ColorPrimaries_BT709_5 : ColorPrimaries_Max;
+    color_mode.gamma = allow_tonemap_native ? Transfer_sRGB : Transfer_Max;
+    color_mode_map_[ColorPrimaries_BT709_5][Transfer_sRGB][kRenderIntentNative][kSdrType] =
+      color_mode;
+    DLOGI("No color mode supported, add Native mode");
+    return;
+  }
+
+  for (uint32_t i = 0; i < stc_mode_list_.list.size(); i++) {
+    snapdragoncolor::ColorMode stc_mode = stc_mode_list_.list[i];
+    if (stc_mode.intent == snapdragoncolor::kNative) {
+      // Setting Max for native mode gamut and gamma
+      stc_mode.gamut = allow_tonemap_native ? ColorPrimaries_BT709_5 : ColorPrimaries_Max;
+      stc_mode.gamma = allow_tonemap_native ? Transfer_sRGB : Transfer_Max;
+      color_mode_map_[ColorPrimaries_BT709_5][Transfer_sRGB][kRenderIntentNative][kSdrType] =
+        stc_mode;
+      DLOGI("Color mode NATIVE supported");
+    } else {
+      ColorPrimaries gamut = static_cast<ColorPrimaries>(stc_mode.gamut);
+      GammaTransfer gamma = static_cast<GammaTransfer>(stc_mode.gamma);
+      RenderIntent intent = static_cast<RenderIntent>(stc_mode.intent);
+      DynamicRangeType dynamic_range = kSdrType;
+      if (std::find(stc_mode.hw_assets.begin(), stc_mode.hw_assets.end(),
+                    snapdragoncolor::kPbHdrBlob) != stc_mode.hw_assets.end()) {
+        dynamic_range = kHdrType;
+      }
+
+      color_mode_map_[gamut][gamma][intent][dynamic_range] = stc_mode;
+      DLOGI("Add into map: gamut %d, gamma %d, render_intent %d, dynamic_range %d", gamut, gamma,
+            intent, dynamic_range);
+    }
+  }
+}
+
+bool SDMColorModeImplStc::IsModeSupported(ColorPrimaries primary, GammaTransfer transfer,
+                                        RenderIntent intent) {
+  if (color_mode_map_.find(primary) == color_mode_map_.end()) {
+    return false;
+  }
+
+  if (color_mode_map_[primary].find(transfer) == color_mode_map_[primary].end()) {
+    return false;
+  }
+
+  if (color_mode_map_[primary][transfer].find(intent) ==
+                                      color_mode_map_[primary][transfer].end()) {
+    return false;
+  }
+
+  return true;
+}
+
+DisplayError SDMColorModeImplStc::GetValidColorMode(ColorPrimaries primary, GammaTransfer transfer,
+                          RenderIntent *intent, DynamicRangeType *dynamic_range) {
+  if (color_mode_map_.find(primary) == color_mode_map_.end()) {
+    DLOGE("Could not find color primary: %d", primary);
+    return kErrorNotSupported;
+  }
+
+  if (color_mode_map_[primary].find(transfer) == color_mode_map_[primary].end()) {
+    DLOGE("Could not find transfer %d in primary %d", transfer, primary);
+    return kErrorNotSupported;
+  }
+
+  if (color_mode_map_[primary][transfer].find(*intent) ==
+                                      color_mode_map_[primary][transfer].end()) {
+    // Fall back to default render intent if current render intent is not supported
+    DLOGW("Could not find intent %d, checking for intent %d in primary %d, transfer %d",
+                                      *intent, DEFAULT_RENDER_INTENT, primary, transfer);
+    *intent = DEFAULT_RENDER_INTENT;
+
+    if (color_mode_map_[primary][transfer].find(*intent) ==
+                                      color_mode_map_[primary][transfer].end()) {
+      DLOGE("Failed to find intent %d in primary %d, transfer %d",
+                                  *intent, primary, transfer);
+      return kErrorNotSupported;
+    }
+  }
+
+  if (color_mode_map_[primary][transfer][*intent].find(*dynamic_range) ==
+                              color_mode_map_[primary][transfer][*intent].end()) {
+    // Fall back to default dynamic range if current render intent is not supported
+    DLOGW("Could not find range %d, checking for range %d in intent %d, primary %d, transfer %d",
+                              *dynamic_range, DEFAULT_DYNAMIC_RANGE, *intent, primary, transfer);
+    *dynamic_range = DEFAULT_DYNAMIC_RANGE;
+
+    if (color_mode_map_[primary][transfer][*intent].find(*dynamic_range) ==
+                            color_mode_map_[primary][transfer][*intent].end()) {
+      DLOGE("Failed to find range %d, in intent %d, primary %d, transfer %d",
+                                  *dynamic_range, *intent, primary, transfer);
+      return kErrorNotSupported;
+    }
+  }
+  return kErrorNone;
+}
+
+DisplayError SDMColorModeImplStc::SetColorModeWithRenderIntent(ColorMode color_mode,
+                                                                bool hdr_present) {
+  if (current_color_mode_.gamut == color_mode.gamut &&
+      current_color_mode_.gamma == color_mode.gamma &&
+      current_color_mode_.intent == color_mode.intent &&
+      ((hdr_present && (curr_dynamic_range_ == kHdrType)) ||
+      (!hdr_present && (curr_dynamic_range_ == kSdrType)))) {
+    return kErrorNone;
+  }
+
+  ColorPrimaries primary = color_mode.gamut;
+  GammaTransfer transfer = color_mode.gamma;
+  RenderIntent intent = color_mode.intent;
+  DynamicRangeType dynamic_range = hdr_present ? kHdrType : kSdrType;
+
+  DisplayError error = GetValidColorMode(primary, transfer, &intent, &dynamic_range);
+  if (error != kErrorNone) {
+    return error;
+  }
+
+  snapdragoncolor::ColorMode stc_mode = color_mode_map_[primary][transfer][intent][dynamic_range];
+  DLOGI("Applying Stc mode (gamut %d gamma %d intent %d hw_assets.size %d)",
+      stc_mode.gamut, stc_mode.gamma, stc_mode.intent, stc_mode.hw_assets.size());
+
+  error = display_intf_->SetStcColorMode(stc_mode);
+  if (error != kErrorNone) {
+      DLOGE("Failed to apply Stc color mode: gamut %d gamma %d intent %d err %d",
+          stc_mode.gamut, stc_mode.gamma, stc_mode.intent, error);
+      return kErrorNotSupported;
+  }
+
+  // Overwrite the intent in case default intent was applied
+  color_mode.intent = intent;
+
+  current_color_mode_ = color_mode;
+  curr_dynamic_range_ = dynamic_range;
+  DLOGV_IF(kTagClient, "Successfully applied mode: gamut = %d, gamma = %d, intent = %d, "
+      "range = %d", primary, transfer, intent, dynamic_range);
+  return kErrorNone;
+}
+
+} // namespace sdm
\ No newline at end of file
diff --git a/libweston/backend-sdm/sdm-service/sdm_color_mode_intf_impl.h b/libweston/backend-sdm/sdm-service/sdm_color_mode_intf_impl.h
new file mode 100644
index 0000000..fc49bbc
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_color_mode_intf_impl.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Changes from Qualcomm Innovation Center, Inc are provided under the following license:
+ *
+ * Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#ifndef __SDM_COLOR_MODE_INTF_IMPL_H__
+#define __SDM_COLOR_MODE_INTF_IMPL_H__
+
+#include <private/color_params.h>
+#include <core/display_interface.h>
+#include <color_metadata.h>
+#include <map>
+
+#include "sdm-service/sdm_color_mode_intf.h"
+
+namespace sdm {
+
+/* Color Mode implementation class for external/pluggable displays */
+class SDMColorModeImpl : public SDMColorModeIntf {
+ public:
+  ~SDMColorModeImpl() {}
+  explicit SDMColorModeImpl(DisplayInterface *display_intf);
+  DisplayError Init();
+  DisplayError DeInit();
+  bool IsModeSupported(ColorPrimaries primary, GammaTransfer transfer,
+                                          RenderIntent intent);
+  DisplayError SetColorModeWithRenderIntent(ColorMode mode, bool hdr_present);
+
+  //TBD: Set Color Transform is not supported on External display
+  DisplayError SetColorTransform(const float *matrix) { return kErrorNone; }
+
+ private:
+  void PopulateColorModes();
+  DisplayError GetValidColorMode(ColorPrimaries primary, GammaTransfer transfer,
+                          RenderIntent *intent, DynamicRangeType *dynamic_range);
+
+
+  DisplayInterface *display_intf_ = NULL;
+  ColorMode current_color_mode_ = {};
+  DynamicRangeType curr_dynamic_range_ = kSdrType;
+
+  typedef std::map<DynamicRangeType, std::string> DynamicRangeMap;
+  typedef std::map<RenderIntent, DynamicRangeMap> RenderIntentMap;
+  typedef std::map<GammaTransfer, RenderIntentMap> TransferMap;
+  std::map<ColorPrimaries, TransferMap> color_mode_map_ = {};
+};
+
+/* Color Mode implementation class for internal/builtin displays */
+class SDMColorModeImplStc : public SDMColorModeIntf {
+ public:
+  ~SDMColorModeImplStc() {}
+  explicit SDMColorModeImplStc(DisplayInterface *display_intf);
+  DisplayError Init();
+  DisplayError DeInit();
+  DisplayError SetColorModeWithRenderIntent(ColorMode mode, bool hdr_present);
+  bool IsModeSupported(ColorPrimaries primary, GammaTransfer transfer,
+                                          RenderIntent intent);
+  DisplayError SetColorTransform(const float *matrix);
+
+ private:
+  template <class T>
+  void CopyColorTransformMatrix(const T *input_matrix, double *output_matrix) {
+    for (uint32_t i = 0; i < kColorTransformMatrixCount; i++) {
+      output_matrix[i] = static_cast<double>(input_matrix[i]);
+    }
+  }
+  DisplayError RestoreColorTransform();
+  void PopulateColorModes();
+  DisplayError GetValidColorMode(ColorPrimaries primary, GammaTransfer transfer,
+                          RenderIntent *intent, DynamicRangeType *dynamic_range);
+
+  static const uint32_t kColorTransformMatrixCount = 16;
+  double color_matrix_[kColorTransformMatrixCount] = {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
+                                                      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0};
+  DisplayInterface *display_intf_ = NULL;
+  ColorMode current_color_mode_ = {};
+  DynamicRangeType curr_dynamic_range_ = kSdrType;
+  snapdragoncolor::ColorModeList stc_mode_list_;
+  typedef std::map<DynamicRangeType, snapdragoncolor::ColorMode> DynamicRangeMap;
+  typedef std::map<RenderIntent, DynamicRangeMap> RenderIntentMap;
+  typedef std::map<GammaTransfer, RenderIntentMap> TransferMap;
+  std::map<ColorPrimaries, TransferMap> color_mode_map_ = {};
+};
+
+}  // namespace sdm
+
+#endif  // __SDM_COLOR_MODE_INTF_IMPL_H__
\ No newline at end of file
diff --git a/libweston/backend-sdm/sdm-service/sdm_display.cpp b/libweston/backend-sdm/sdm-service/sdm_display.cpp
new file mode 100644
index 0000000..09af7f7
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display.cpp
@@ -0,0 +1,1747 @@
+/*
+* Copyright (c) 2017, 2021 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center, Inc. are provided under the following license:
+ *
+ * Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#include <assert.h>
+#include <stdarg.h>
+#include <linux/limits.h>
+#include <string>
+#include <vector>
+#include <algorithm>
+#include <map>
+#include <ostream>
+#include <fstream>
+#include <utility>
+#include <bitset>
+#include <math.h>
+#include <time.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <pthread.h>
+#include <sys/prctl.h>
+#include <sys/resource.h>
+
+#include "sdm-service/sdm_display.h"
+#include "sdm-service/uevent.h"
+
+#include "sdm-internal.h"
+
+#define __CLASS__ "SdmDisplay"
+extern "C" void NotifyOnRefresh(struct drm_output *);
+
+vblank_cb_t vblank_cb_;
+
+namespace sdm {
+#define GET_GPU_TARGET_SLOT(max_layers) ((max_layers) - 1)
+/* Cursor is fixed in (gpu_target_index-1) slot in SDM */
+#define GET_CURSOR_SLOT(max_layers) ((max_layers) - 2)
+#define LEN_LOCAL 2048
+
+#define SDM_DISPLAY_DUMP_LAYER_STACK 0
+
+#define SDM_DEAFULT_NULL_DISPLAY_WIDTH 1920
+#define SDM_DEAFULT_NULL_DISPLAY_HEIGHT 1080
+#define SDM_DEAFULT_NULL_DISPLAY_FPS 60
+#define SDM_DEAFULT_NULL_DISPLAY_X_DPI 25.4
+#define SDM_DEAFULT_NULL_DISPLAY_Y_DPI 25.4
+#define SDM_DEAFULT_NULL_DISPLAY_IS_YUV false
+
+#define MAX_PROP_STR_SIZE 64
+#define SDM_NULL_DISPLAY_RESOLUTON_PROP_NAME "weston.sdm.default.resolution"
+#define SDM_DISABLE_HDR_HANDLING "vendor.display.disable_hdr"
+
+std::atomic<uint64_t> SdmDisplay::next_id_(1);
+SdmDisplay::SdmDisplay(DisplayType type, CoreInterface *core_intf,
+                                         SdmDisplayBufferAllocator *buffer_allocator) {
+    display_type_ = type;
+    core_intf_    = core_intf;
+    buffer_allocator_ = buffer_allocator;
+    drm_output_   = NULL;
+    vblank_cb_    = NULL;
+}
+
+SdmDisplay::~SdmDisplay() {
+    FreeLayerStack();
+}
+
+const char * SdmDisplay::FourccToString(uint32_t fourcc)
+{
+    static __thread char s[4];
+    uint32_t fmt = htole32(fourcc);
+
+    memcpy(s, &fmt, 4);
+
+    return s;
+}
+
+DisplayError SdmDisplay::CreateDisplay(uint32_t display_id) {
+    DisplayError error = kErrorNone;
+    struct DisplayHdrInfo display_hdr_info = {};
+
+    char property[MAX_PROP_STR_SIZE] = {0};
+    SdmDisplayDebugger::Get()->GetProperty(SDM_DISABLE_HDR_HANDLING, property);
+    if (!(std::string(property)==std::string("1"))) {
+        disable_hdr_handling_ = 0;
+    }
+
+    error = core_intf_->CreateDisplay(display_id, this, &display_intf_);
+
+    if (error != kErrorNone) {
+        DLOGE("Display creation failed. Error = %d", error);
+
+        return error;
+    }
+
+    GetHdrInfo(&display_hdr_info);
+    if (display_hdr_info.hdr_supported) {
+        DLOGI("Display Device supports HDR functionality");
+    } else {
+        DLOGI("Display Device doesn't support HDR functionality");
+    }
+
+    error = display_intf_->SetHDRSupportOnClient(false);
+    if (error != kErrorNone) {
+        DLOGW("Failed to Disable HDR Support on Client");
+    }
+
+    SDMColorModeIntfFactory *color_mode_factory = GetSDMColorModeIntfFactory();
+    color_mode_intf_ = color_mode_factory->GetSDMColorModeIntf(display_type_,
+                                                            display_intf_);
+    if (color_mode_intf_) {
+        error = color_mode_intf_->Init();
+        if (error != kErrorNone) {
+            DLOGW("Failed to initialize color mode intf, error %d !", error);
+            color_mode_intf_ = nullptr;
+        }
+    } else {
+        DLOGW("Display %d-%d, failed to creare color mode intf!!", display_id_, display_type_);
+    }
+
+    std::bitset<kClientCapabilityMax> client_capabilities =
+                                 std::bitset<kClientCapabilityMax>().set();
+    client_capabilities.reset(kPunchholeSupported);
+
+    error = display_intf_->SetClientTargetCapability(client_capabilities);
+    if (error != kErrorNone) {
+        DLOGW("Failed to populate client capabilities");
+    }
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::DestroyDisplay() {
+    DisplayError error = kErrorNone;
+
+    error = core_intf_->DestroyDisplay(display_intf_);
+    display_intf_ = NULL;
+
+    if (color_mode_intf_) {
+        error = color_mode_intf_->DeInit();
+        color_mode_intf_ = nullptr;
+    }
+    return error;
+}
+
+DisplayError SdmDisplay::VSync(const DisplayEventVSync &vsync) {
+    if (vblank_cb_) {
+      vblank_cb_(display_id_, vsync.timestamp, drm_output_);
+    } else {
+      DLOGE("vsync not registered");
+    }
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::VSync(int fd, unsigned int sequence, unsigned int tv_sec,
+                               unsigned int tv_usec, void *data) {
+
+    DLOGW("Not implemented\n");
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::PFlip(int fd, unsigned int sequence, unsigned int tv_sec,
+                               unsigned int tv_usec, void *data) {
+
+    DLOGW("Not implemented");
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::Refresh() {
+    if (client_event_handler_) {
+        client_event_handler_->Refresh();
+    }
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::CECMessage(char *message) {
+    DLOGW("Not implemented");
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::SetDisplayState(DisplayState state, bool teardown,
+                                         shared_ptr<Fence> *release_fence) {
+    DisplayError error;
+
+    error = display_intf_->SetDisplayState(state, teardown, release_fence);
+    if (error != kErrorNone) {
+        DLOGE("function failed. Error = %d", error);
+        return error;
+    }
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::HistogramEvent(int /* fd */, uint32_t /* blob_fd */) {
+  return kErrorNone;
+}
+
+void SdmDisplay::RefreshWithCachedLayerstack()
+{
+    DisplayError error = kErrorNone;
+    layer_stack_ = prev_layer_stack_;
+    error = display_intf_->Prepare(&layer_stack_);
+    if (error != kErrorNone) {
+        DLOGE("Prepare failed with error %d", error);
+        return;
+    }
+
+    error = display_intf_->Commit(&layer_stack_);
+    if (error != kErrorNone) {
+        DLOGE("Commit failed with error %d", error);
+        return;
+    } else{
+        PostCommit();
+        NotifyOnRefresh(prev_output_);
+    }
+}
+
+void SdmDisplay::HandlePanelDead()
+{
+    uint32_t i = 0;
+    //TODO(user): extend for multi display if needed. currently handle for primary display.
+    if (display_type_ != kPrimary) {
+      DLOGE("Current display is not primary");
+      return;
+    }
+
+    esd_reset_panel_ = true;
+    shared_ptr<Fence> *release_fence;
+    DisplayError error = kErrorNone;
+
+    DisplayState last_display_state = {};
+    error = display_intf_->GetDisplayState(&last_display_state);
+    if (error != kErrorNone) {
+        DLOGE("Failed to get last display state with error %d", error);
+        return;
+    }
+
+    error = SetDisplayState(kStateOff, true, release_fence);
+    if (error != kErrorNone) {
+        DLOGE("Failed to power off the display with error %d", error);
+        return;
+    }
+
+    error = SetDisplayState(last_display_state, false, release_fence);
+    if (error != kErrorNone) {
+        DLOGE("Failed to SetDisplayState with error %d", error);
+        return;
+    }
+
+    do {
+        error = display_intf_->SetVSyncState(true);
+        if (error != kErrorNone) {
+            usleep(1000);
+            i++;
+        }
+    } while (error && i < 16);
+
+    if (error) {
+        DLOGE("Failed to SetVSyncState  with error %d", error);
+    }
+
+    RefreshWithCachedLayerstack();
+    esd_reset_panel_ = false;
+}
+
+ColorMode SdmDisplay::GetBestHDRColorMode(ColorPrimaries layer_gamut,
+                                                GammaTransfer layer_gamma) {
+  ColorMode hdr_mode = {.gamut = layer_gamut,
+                      .gamma = layer_gamma,
+                      .intent = kRenderIntentColorimetric};
+
+  if (color_mode_intf_->IsModeSupported(hdr_mode.gamut, hdr_mode.gamma, hdr_mode.intent)) {
+    return hdr_mode;
+  }
+
+  // Fallback to Gamma HDR if HLG not present
+  hdr_mode.gamma = Transfer_SMPTE_ST2084;
+  if (color_mode_intf_->IsModeSupported(hdr_mode.gamut, hdr_mode.gamma, hdr_mode.intent)) {
+    return hdr_mode;
+  }
+
+  hdr_mode.gamut = ColorPrimaries_Max;
+  hdr_mode.gamma = Transfer_Max;
+  return hdr_mode;
+}
+
+ColorMode SdmDisplay::SelectBestColorSpace(bool isHdrSupported) {
+    ColorMode best_color_mode = {.gamut = ColorPrimaries_BT709_5,
+                                .gamma = Transfer_sRGB,
+                                .intent = kRenderIntentColorimetric};
+    ColorMode best_hdr_mode = {.gamut = ColorPrimaries_Max,
+                                .gamma = Transfer_Max,
+                                .intent = kRenderIntentColorimetric};
+
+    for (uint32_t i = 0; i < layer_stack_.layers.size(); i++) {
+        struct Layer *layer = nullptr;
+        struct LayerBuffer buffer = {};
+        layer = layer_stack_.layers.at(i);
+        buffer = layer->input_buffer;
+
+        if (layer->flags.skip) {
+            continue;
+        }
+
+        ColorMode color_mode = {.intent = kRenderIntentColorimetric};
+        color_mode.gamut = buffer.color_metadata.colorPrimaries;
+        color_mode.gamma = buffer.color_metadata.transfer;
+
+        switch (color_mode.gamut) {
+            case ColorPrimaries_DCIP3:
+                best_color_mode.gamut = ColorPrimaries_DCIP3;
+                best_color_mode.gamma = Transfer_sRGB;
+                break;
+            case ColorPrimaries_BT2020:
+                best_color_mode.gamut = ColorPrimaries_DCIP3;
+                best_color_mode.gamma = Transfer_sRGB;
+
+                if (!isHdrSupported) {
+                    continue;
+                }
+
+                // Prioritize Mode with PQ Gamma over HLG as
+                // conversion PQ->HLG is unsupported use case
+                if (color_mode.gamma == Transfer_HLG &&
+                    best_hdr_mode.gamma == Transfer_SMPTE_ST2084) {
+                    continue;
+                }
+                best_hdr_mode = GetBestHDRColorMode(color_mode.gamut, color_mode.gamma);
+                break;
+            default:
+                break;
+        }
+    }
+
+    if (best_hdr_mode.gamut != ColorPrimaries_Max && best_hdr_mode.gamma != Transfer_Max) {
+        return best_hdr_mode;
+    }
+
+    // Handle case where external displays only support sRGB or BT2020
+    if (best_color_mode.gamut == ColorPrimaries_DCIP3) {
+      if (color_mode_intf_->IsModeSupported(best_color_mode.gamut, best_color_mode.gamma,
+                                            best_color_mode.intent)) {
+        return best_color_mode;
+      }
+
+      best_color_mode.gamut = ColorPrimaries_BT2020;
+      best_color_mode.gamma = Transfer_sRGB;
+      if (color_mode_intf_->IsModeSupported(best_color_mode.gamut, best_color_mode.gamma,
+                                            best_color_mode.intent)) {
+        return best_color_mode;
+      }
+
+      // Fallback to sRGB if both Display_BT2020 and Display_P3 not supported
+      best_color_mode.gamut = ColorPrimaries_BT709_5;
+    }
+
+    // Switch to Native if sRGB mode not present
+    if (!color_mode_intf_->IsModeSupported(best_color_mode.gamut, best_color_mode.gamma,
+                                            best_color_mode.intent)) {
+      best_color_mode.intent = kRenderIntentNative;
+    }
+
+    return best_color_mode;
+}
+
+DisplayError SdmDisplay::HandleEvent(DisplayEvent event) {
+    switch (event) {
+        case kPanelDeadEvent:
+            HandlePanelDead();
+            break;
+        default:
+            DLOGW("Unknown event: %d", event);
+            break;
+    }
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::SetVSyncState(bool VSyncState, struct drm_output *output) {
+    DisplayError error;
+
+    if (!output) {
+        DLOGE("No output to set VSync");
+	return kErrorNone;
+    }
+
+    drm_output_ = output;
+    error = display_intf_->SetVSyncState(VSyncState);
+    if (error != kErrorNone) {
+        DLOGE("VSync state setting failed. Error = %d", error);
+        return error;
+    }
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::SetPanelBrightness(float brightness) {
+    return display_intf_->SetPanelBrightness(brightness);
+}
+
+DisplayError SdmDisplay::GetPanelBrightness(float *brightness) {
+    return display_intf_->GetPanelBrightness(brightness);
+}
+
+DisplayError SdmDisplay::GetDisplayConfiguration(struct DisplayConfigInfo *display_config) {
+    DisplayError error = kErrorNone;
+    DisplayConfigVariableInfo disp_config;
+    uint32_t active_index = 0;
+
+    error = display_intf_->GetActiveConfig(&active_index);
+
+    if (error != kErrorNone) {
+        DLOGE("Active Index not found. Error = %d", error);
+        return error;
+    }
+
+    error = display_intf_->GetConfig(active_index, &disp_config);
+
+    if (error != kErrorNone) {
+        DLOGE("Display Configuration failed. Error = %d", error);
+        return error;
+    }
+
+    display_config->x_pixels     = disp_config.x_pixels;
+    display_config->y_pixels     = disp_config.y_pixels;
+    display_config->x_dpi        = disp_config.x_dpi;
+    display_config->y_dpi        = disp_config.y_dpi;
+    display_config->fps          = disp_config.fps;
+    display_config->vsync_period_ns = disp_config.vsync_period_ns;
+    display_config->is_yuv       = disp_config.is_yuv;
+    fps_                         = disp_config.fps;
+    display_config->is_connected = true;
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::RegisterCb(int display_id, vblank_cb_t vbcb) {
+    DisplayError error = kErrorNone;
+
+    vblank_cb_   = vbcb;
+    display_id_  = display_id;
+
+    return error;
+}
+
+int SdmDisplay::OnMinHdcpEncryptionLevelChange(uint32_t min_enc_level) {
+  DisplayError error = display_intf_->OnMinHdcpEncryptionLevelChange(min_enc_level);
+  if (error != kErrorNone) {
+    DLOGE("Failed. Error = %d", error);
+    return -1;
+  }
+
+  return 0;
+}
+
+DisplayError SdmDisplay::FreeLayerStack() {
+  /* block main thread execution until async commit finishes */
+  if (display_intf_)
+    display_intf_->DestroyLayer();
+
+  for (uint32_t i = 0; i < layer_stack_.layers.size(); i++) {
+    Layer *layer = layer_stack_.layers.at(i);
+
+    layer->visible_regions.erase(layer->visible_regions.begin(),
+                layer->visible_regions.end());
+    layer->dirty_regions.erase(layer->dirty_regions.begin(),
+                layer->dirty_regions.end());
+
+    delete layer;
+  }
+  layer_stack_ = {};
+
+  return kErrorNone;
+}
+
+DisplayError SdmDisplay::FreeLayerGeometry(struct LayerGeometry *glayer) {
+    if (glayer->dirty_regions.count)
+        free(glayer->dirty_regions.rects);
+    if (glayer->visible_regions.count)
+        free(glayer->visible_regions.rects);
+
+    free(glayer);
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::AllocLayerStackMemory(struct drm_output *output) {
+    for (size_t i = 0; i < output->view_count; i++) {
+         Layer *layer = new Layer();
+         layer_stack_.layers.push_back(layer);
+    }
+
+    return kErrorNone;
+}
+
+void SdmDisplay::InitializeLayerIds() {
+    for (auto &layer: layer_stack_.layers) {
+         layer->layer_id = next_id_++;
+    }
+}
+
+static void SetRect(sdm::LayerRect *dst, struct Rect *src)
+{
+    dst->left = src->left;
+    dst->top = src->top;
+    dst->right = src->right;
+    dst->bottom = src->bottom;
+}
+
+DisplayError SdmDisplay::PopulateLayerGeometryOnToLayerStack(struct drm_output *output,
+                                                             uint32_t index,
+                                                             struct LayerGeometry *glayer,
+                                                             bool is_skip) {
+    DisplayError error = kErrorNone;
+    sdm::Layer *layer = layer_stack_.layers.at(index);
+    struct LayerGeometry *layer_geometry = glayer;
+    LayerBuffer *layer_buffer, &layer_buffer_ = layer->input_buffer;
+    layer_buffer = &layer_buffer_;
+
+    /* 1. Fill buffer information */
+    *layer_buffer = sdm::LayerBuffer();
+    layer_buffer->format = GetSDMFormat(layer_geometry->format, layer_geometry->flags);
+    layer_buffer->width = layer_geometry->width;
+    layer_buffer->height = layer_geometry->height;
+    layer_buffer->unaligned_width = layer_geometry->unaligned_width;
+    layer_buffer->unaligned_height = layer_geometry->unaligned_height;
+    /* TODO (user): Obtain metadata and then */
+    // TODO: (user)  if (SetMetaData(metadatar layer) != kErrorNone) {
+    // TODO: (user)      return kErrorUndefined;
+    // TODO: (user)  }
+
+    if (index != layer_stack_.layers.size()-1)
+        layer_buffer->planes[0].fd = layer_geometry->ion_fd;
+
+    /* TODO: Below information should be set according to the real user scenario */
+    layer_buffer->flags.secure = layer_geometry->flags.secure_present;
+    layer_buffer->flags.video = layer_geometry->flags.video_present;
+    layer_buffer->flags.hdr = layer_geometry->flags.hdr_present;
+
+    layer_buffer->color_metadata = layer_geometry->color_metadata;
+
+    layer_buffer->flags.macro_tile = false;
+    layer_buffer->flags.interlace = false;
+    layer_buffer->flags.secure_display = false;
+    layer_buffer->flags.secure_camera = false;
+    /* 2. Fill layer information */
+    if (layer_geometry->composition == SDM_COMPOSITION_FB_TARGET)
+        layer->composition = sdm::kCompositionGPUTarget;
+    else
+        layer->composition = sdm::kCompositionGPU;
+
+    SetRect(&layer->src_rect, &layer_geometry->src_rect);
+    SetRect(&layer->dst_rect, &layer_geometry->dst_rect);
+
+    for (uint32_t i = 0; i < layer_geometry->visible_regions.count; i++) {
+         SetRect(&layer->visible_regions.at(i), &layer_geometry->visible_regions.rects[i]);
+    }
+
+    for (uint32_t i = 0; i < layer_geometry->dirty_regions.count; i++) {
+         SetRect(&layer->dirty_regions.at(i), &layer_geometry->dirty_regions.rects[i]);
+    }
+
+    layer->blending = GetSDMBlending(layer_geometry->blending);
+    layer->plane_alpha = layer_geometry->plane_alpha;
+
+    layer->transform.flip_horizontal =
+              ((layer_geometry->transform & SDM_TRANSFORM_FLIP_H) > 0);
+    layer->transform.flip_vertical =
+              ((layer_geometry->transform & SDM_TRANSFORM_FLIP_V) > 0);
+    layer->transform.rotation =
+              ((layer_geometry->transform & SDM_TRANSFORM_90) ? 90.0f : 0.0f);
+
+    layer->frame_rate = fps_;
+    layer->solid_fill_color = 0;
+
+    layer->flags.skip = is_skip;
+    if (is_skip)
+       layer_stack_.flags.skip_present = is_skip;
+    if (layer_buffer->flags.video)
+       layer_stack_.flags.video_present = true;
+    if (layer_buffer->flags.hdr)
+       layer_stack_.flags.hdr_present = 1;
+    if (layer_buffer->flags.secure)
+        layer_stack_.flags.secure_present = true;
+    layer->flags.updating = true;
+    layer->flags.solid_fill = false;
+    layer->flags.cursor = false;
+    layer->flags.single_buffer = false;
+
+    return error;
+}
+
+DisplayError SdmDisplay::AllocateMemoryForLayerGeometry(struct \
+                                drm_output *output,
+                                uint32_t index,
+                                struct LayerGeometry \
+                                *glayer) {
+    /* Configure each layer */
+    uint32_t num_visible_rects = 0;
+    uint32_t num_dirty_rects = 0;
+
+    if (index < output->view_count) {
+     if (glayer == NULL) {
+          DLOGE("no layer geometry for the display!\n");
+          return kErrorParameters;
+     }
+     /* It's permissive the visible/dirty region can be NULL */
+     num_visible_rects = glayer->visible_regions.count;
+     for (uint32_t j = 0; j < num_visible_rects; j++) {
+          LayerRect visible_rect {};
+          layer_stack_.layers.at(index)->visible_regions.push_back(visible_rect);
+     }
+
+     num_dirty_rects = glayer->dirty_regions.count;
+     for (uint32_t j = 0; j < num_dirty_rects; j++) {
+          LayerRect dirty_rect {};
+          layer_stack_.layers.at(index)->dirty_regions.push_back(dirty_rect);
+     }
+    }
+
+    return kErrorNone;
+}
+
+DisplayError SdmDisplay::AddGeometryLayerToLayerStack(struct drm_output *output, uint32_t index,
+                                                      struct LayerGeometry *glayer, bool is_skip)
+{
+    DisplayError error = kErrorNone;
+
+    AllocateMemoryForLayerGeometry(output, index, glayer);
+    error = PopulateLayerGeometryOnToLayerStack(output, index, glayer, is_skip);
+
+    return error;
+}
+
+int SdmDisplay::PrepareFbLayerGeometry(struct drm_output *output,
+                        struct LayerGeometry **fb_glayer) {
+    struct LayerGeometry *fb_layer = NULL;
+    *fb_glayer = fb_layer = reinterpret_cast<struct LayerGeometry *> \
+                              (zalloc(sizeof *fb_layer));
+    if (!fb_layer) {
+        DLOGE("fb_layer is NULL\n");
+        return -1;
+    }
+
+    int32_t mode_width = output->base.current_mode->width;
+    int32_t mode_height = output->base.current_mode->height;
+    fb_layer->width = mode_width;
+    fb_layer->height = mode_height;
+    fb_layer->unaligned_width = mode_width;
+    fb_layer->unaligned_height = mode_height;
+
+    fb_layer->format = GetMappedFormatFromGbm(output->gbm_format);
+    fb_layer->composition = SDM_COMPOSITION_FB_TARGET;
+
+    fb_layer->src_rect.left = (float)0.0;
+    fb_layer->src_rect.top = (float)0.0;
+    fb_layer->src_rect.right = (float)mode_width;
+    fb_layer->src_rect.bottom = (float)mode_height;
+    fb_layer->dst_rect.left = (float)0.0;
+    fb_layer->dst_rect.top = (float)0.0;
+    fb_layer->dst_rect.right = (float)mode_width;
+    fb_layer->dst_rect.bottom = (float)mode_height;
+
+    fb_layer->visible_regions.rects = reinterpret_cast<struct Rect *> \
+                              (zalloc(sizeof(struct Rect)));
+    if (fb_layer->visible_regions.rects == NULL) {
+        DLOGE("out of memory for allocating fb visible region\n");
+        return -1;
+    }
+    fb_layer->visible_regions.rects[0] = fb_layer->dst_rect;
+    fb_layer->visible_regions.count = 1;
+
+    fb_layer->dirty_regions.rects = reinterpret_cast<struct Rect *> \
+                              (zalloc(sizeof(struct Rect)));
+    if (fb_layer->dirty_regions.rects == NULL) {
+        DLOGE("out of memory for allocating fb dirty region\n");
+        return -1;
+    }
+
+    fb_layer->dirty_regions.rects[0] = fb_layer->dst_rect;
+    fb_layer->dirty_regions.count = 1;
+
+    fb_layer->blending = SDM_BLENDING_PREMULTIPLIED;
+    /*
+     * output->base.width/height should be already transformed, so just
+     * keep no transform for output.
+     */
+    fb_layer->transform = SDM_TRANSFORM_NORMAL;
+    fb_layer->plane_alpha = 0xFF;
+
+    fb_layer->flags.skip = 0;
+    fb_layer->flags.is_cursor = 0;
+    fb_layer->flags.has_ubwc_buf = false;
+
+    return 0;
+}
+
+int SdmDisplayInterface::GetDrmMasterFd() {
+    DRMMaster *master = nullptr;
+    int ret = DRMMaster::GetInstance(&master);
+    int fd;
+
+    if (ret < 0) {
+        DLOGE("Failed to acquire DRMMaster instance");
+        return kErrorNotSupported;
+        }
+    master->GetHandle(&fd);
+    return fd;
+}
+
+
+void SdmDisplayInterface::SetDrmMasterFd(int fd) {
+    DRMMaster::SetHandle(fd);
+}
+
+int SdmDisplay::PrepareNormalLayerGeometry(struct drm_output *output,
+                         struct LayerGeometry **glayer,
+                         struct sdm_layer *sdm_layer) {
+    struct LayerGeometry *layer;
+    struct weston_view *ev = sdm_layer->view;
+    struct weston_surface *es = ev->surface;
+    bool is_cursor = sdm_layer->is_cursor;
+    uint32_t format = GBM_FORMAT_XBGR8888;
+    pixman_region32_t r;
+
+    *glayer = layer = reinterpret_cast<struct LayerGeometry *> \
+                           (zalloc(sizeof *layer));
+    if (!layer) {
+        DLOGE("layer is NULL\n");
+        return -1;
+    }
+
+    /* Prepare layer buffer information */
+    layer->width = es->width;
+    layer->height = es->height;
+    layer->unaligned_width = es->width;
+    layer->unaligned_height = es->height;
+    layer->fb_id = -1;
+    layer->format = SDM_BUFFER_FORMAT_RGBX_8888;
+
+    if (sdm_layer->fb && sdm_layer->fb->bo) {
+        struct gbm_bo *bo = sdm_layer->fb->bo;
+        if (bo == NULL) {
+            DLOGE("fail to import gbm bo!\n");
+            return -1;
+        } else {
+            uint32_t width, height;
+
+            //save gbm bo in sdm layer for future reference.
+            sdm_layer->bo = bo;
+
+            width = gbm_bo_get_width(bo);
+            height = gbm_bo_get_height(bo);
+            format = gbm_bo_get_format(bo);
+
+            uint32_t alignedWidth = 0;
+            uint32_t alignedHeight = 0;
+            uint32_t secure_status = 0;
+            uint32_t ubwc_status = 0;
+            void *prm = reinterpret_cast<void *> (&layer->color_metadata);
+
+            gbm_perform(GBM_PERFORM_GET_BO_ALIGNED_WIDTH, bo, &alignedWidth);
+            gbm_perform(GBM_PERFORM_GET_BO_ALIGNED_HEIGHT, bo, &alignedHeight);
+            gbm_perform(GBM_PERFORM_GET_SECURE_BUFFER_STATUS, bo, &secure_status);
+            gbm_perform(GBM_PERFORM_GET_METADATA, bo, GBM_METADATA_GET_COLOR_METADATA, prm);
+            gbm_perform(GBM_PERFORM_GET_UBWC_STATUS, bo, &ubwc_status);
+
+            // Override buffer width/height to reflect aligned width and aligned height.
+            layer->width = alignedWidth;
+            layer->height = alignedHeight;
+            layer->unaligned_width = width;
+            layer->unaligned_height = height;
+            layer->ion_fd = sdm_layer->fb->ion_fd;
+            layer->flags.secure_present = secure_status;
+            layer->flags.has_ubwc_buf = ubwc_status;
+
+            bool hdr_layer = layer->color_metadata.colorPrimaries == ColorPrimaries_BT2020 &&
+                             (layer->color_metadata.transfer == Transfer_SMPTE_ST2084 ||
+                             layer->color_metadata.transfer == Transfer_HLG);
+
+            // Set to true if incoming layer has HDR support and Display supports HDR functionality
+            if (!disable_hdr_handling_) {
+                layer->flags.hdr_present = hdr_layer;
+            }
+        }
+    }
+
+    if (NeedConvertGbmFormat(ev, format))
+        format = ConvertToOpaqueGbmFormat(format);
+    layer->format = GetMappedFormatFromGbm(format);
+
+    /* Get src/dst rect */
+    ComputeSrcDstRect(output, ev, &layer->src_rect, &layer->dst_rect);
+    /* Get visible rects */
+    if (GetVisibleRegion(output, ev, &sdm_layer->overlap, &layer->visible_regions))
+        return -1;
+    /*
+     * Get dirty rects. It's not surprised a view has null damage region, that means
+     * the buffer content of view is not changed since last frame, eg. cursor.
+     */
+    if (ComputeDirtyRegion(ev, &layer->dirty_regions))
+        return -1;
+
+    /* Set no transform for view since bounding box already been applied by transform */
+    layer->transform = SDM_TRANSFORM_NORMAL;
+    /* Get global alpha */
+    layer->plane_alpha = GetGlobalAlpha(ev);
+
+    /* TODO: update property src_config, csc, color_fill, scaler ... */
+    layer->flags.is_cursor = is_cursor;
+    layer->flags.video_present = GetVideoPresenceByFormatFromGbm(format);
+
+    /* compute whether this view has no blending */
+    pixman_region32_init_rect(&r, 0, 0, ev->surface->width, ev->surface->height);
+    pixman_region32_subtract(&r, &r, &ev->surface->opaque);
+
+    if (!pixman_region32_not_empty(&r) && (layer->plane_alpha == 0xFF))
+        layer->blending = SDM_BLENDING_NONE;
+    else
+        layer->blending = SDM_BLENDING_COVERAGE;
+
+    // Video layers are always opaque
+    if (layer->flags.video_present) {
+        layer->blending = SDM_BLENDING_NONE;
+    }
+
+    /* Initialize all views with GPU composition first, SDM will update them after prepare */
+    layer->composition = SDM_COMPOSITION_GPU;
+
+    return 0;
+}
+
+DisplayError SdmDisplay::PrePrepareLayerStack(struct drm_output *output) {
+    DisplayError error = kErrorNone;
+    struct sdm_layer *sdm_layer = NULL;
+    struct LayerGeometry *glayer = NULL;
+    uint32_t gpu_target_index = GET_GPU_TARGET_SLOT(output->view_count);
+    uint32_t index = 0;
+    LayerBufferFlags layerBufferFlags;
+
+    if (shutdown_pending_) {
+	return kErrorShutDown;
+    }
+
+    FreeLayerStack();
+    AllocLayerStackMemory(output);
+    InitializeLayerIds();
+
+    DLOGI("gpu_target_index = %d\n", gpu_target_index);
+
+    /* If no view can be handled by SDM, just skip below and prepare fb target directly. */
+    if (gpu_target_index > 0) {
+        wl_list_for_each_reverse(sdm_layer, &output->sdm_layer_list, link) {
+            glayer = NULL;
+            if(PrepareNormalLayerGeometry(output, &glayer, sdm_layer)) {
+                DLOGE("fail to prepare normal layer geometry.");
+                return kErrorUndefined;
+            }
+
+            error = AddGeometryLayerToLayerStack(output, index, glayer, sdm_layer->is_skip);
+            if (error) {
+                DLOGE("failed add Geometry Layer to LayerStack.");
+                FreeLayerGeometry(glayer);
+                return kErrorUndefined;
+            }
+            FreeLayerGeometry(glayer);
+
+            // Pass the wl_resource handle from sdm layer to layer stack
+            // to use it for egl image creation in tone mapping
+            layerBufferFlags = layer_stack_.layers.at(index)->input_buffer.flags;
+
+            layer_stack_.layers.at(index)->input_buffer.acquire_fence =
+                               Fence::Create(dup(sdm_layer->acquire_fence_fd), "App_Layer_Fence");
+            DLOGD_IF(kTagNone, "Acquire fence fd: %s for layer index %d",
+                 Fence::GetStr(layer_stack_.layers.at(index)->input_buffer.acquire_fence).c_str(),
+                 index);
+            //Acquire fence fd is not received for frame buffer target layer as gl-renderer is not
+            //sending it. Hence not adding acquire fence for frame buffer target
+
+            index++;
+            if (sdm_layer->is_skip)
+                layer_stack_.flags.skip_present = true;
+        }
+    }
+    int err = PrepareFbLayerGeometry(output, &glayer);
+    if (err) {
+        DLOGE("failed to prepare Layer Geometry Fb target\n");
+        return kErrorUndefined;
+    } else {
+        error = AddGeometryLayerToLayerStack(output, index, glayer, false);
+        if (error) {
+            DLOGE("fail to prepare Fb target: Add Geometry failure fb\n");
+            FreeLayerGeometry(glayer);
+            return kErrorUndefined;
+        }
+        FreeLayerGeometry(glayer);
+    }
+
+    return error;
+}
+
+DisplayError SdmDisplay::PrePrepare(struct drm_output *output)
+{
+    DisplayError error = kErrorNone;
+
+    error = PrePrepareLayerStack(output);
+    if (error ) {
+        DLOGE("function failed!\n", error);
+    }
+
+    if (hdr_supported_ && !disable_hdr_handling_ && color_mode_intf_) {
+        ColorMode mode = SelectBestColorSpace(hdr_supported_);
+        DLOGV("Display: %d-%d Setting Best Color Mode: gamut %d gamma %d intent %d",
+                display_id_, display_type_, mode.gamut, mode.gamma, mode.intent);
+        error = color_mode_intf_->SetColorModeWithRenderIntent(mode,
+                    static_cast<bool>(layer_stack_.flags.hdr_present));
+        if (error != kErrorNone) {
+            DLOGE("Setting color mode failed, error %d !",error);
+        }
+    }
+
+    return error;
+}
+
+DisplayError SdmDisplay::PostPrepare(struct drm_output *output)
+{
+    DisplayError error = kErrorNone;
+    int index = 0;
+    struct sdm_layer *sdm_layer = NULL;
+
+    wl_list_for_each_reverse(sdm_layer, &output->sdm_layer_list, link) {
+      Layer *layer = layer_stack_.layers.at(index);
+
+      if (layer->composition == kCompositionGPU) {
+        sdm_layer->composition_type = SDM_COMPOSITION_GPU;
+      } else {
+        sdm_layer->composition_type = SDM_COMPOSITION_OVERLAY;
+      }
+      index++;
+    }
+
+    if (output->backend->use_pixman)
+    {
+        // Pixman uses double buffer,it would repaint FBT after prepare
+        // So need wait pre-reitre_fence here to avoid tearing issue
+        if (prev_layer_stack_.retire_fence) {
+            int ret = -1;
+            ret = Fence::Wait(prev_layer_stack_.retire_fence);
+            if (ret != kErrorNone) {
+                DLOGE("retire_fence wait timeout! ret=%d\n", ret);
+            }
+        }
+    }
+
+    return error;
+}
+
+#if SDM_DISPLAY_DUMP_LAYER_STACK
+static void GetLayerStackDump(void *layerStack, char *buffer, uint32_t length) {
+  if (!buffer || !length) {
+    return;
+  }
+  static int frame_count=0;
+  buffer[0] = '\0';
+  struct LayerStack *layer_stack;
+  layer_stack = reinterpret_cast<struct LayerStack *>(layerStack);
+  DLOGI("\n-------- Display Manager: Layer Stack Dump --------");
+  fprintf(stderr,"Frame:%d LayerStack: NumLayers:%d flags:0x%x\n",
+                frame_count, layer_stack->layers.size(), layer_stack->flags);
+
+  for (uint32_t i = 0; i < layer_stack->layers.size(); i++) {
+      char buf[LEN_LOCAL] = {0};
+
+      struct Layer *layer;
+      struct LayerBuffer buffer;
+      layer = layer_stack->layers.at(i);
+      buffer = layer->input_buffer;
+
+      memset(buf, '\0', LEN_LOCAL);
+      snprintf(buf, sizeof(buf), "Layer: %d\n    width  = %d,     height = %d", i,
+        layer->input_buffer.width, layer->input_buffer.height);
+      snprintf(buf, sizeof(buf), "%s\n LayerComposition = %#x", buf, layer->composition);
+      snprintf(buf, sizeof(buf), "%s\n src_rect (LTRB) = %4.2f, %4.2f, %4.2f, %4.2f",
+        buf, layer->src_rect.left, layer->src_rect.top,
+        layer->src_rect.right, layer->src_rect.bottom);
+      snprintf(buf, sizeof(buf), "%s\n dst_rect (LTRB) = %4.2f, %4.2f, %4.2f, %4.2f", buf,
+        layer->dst_rect.left, layer->dst_rect.top, layer->dst_rect.right,
+        layer->dst_rect.bottom);
+      snprintf(buf, sizeof(buf), "%s\n LayerBlending = %#x", buf, layer->blending);
+      snprintf(buf, sizeof(buf), "%s\n LayerTransform:rotation= %f,flip_horizontal=%s,flip_vertical=%s",
+        buf, layer->transform.rotation, (layer->transform.flip_horizontal? \
+        "true":"false"), (layer->transform.flip_vertical? "true":"false"));
+      snprintf(buf, sizeof(buf), "%s\n Plane Alpha = %#x, frame_rate = %d,  solid_fill_color = %d",
+        buf, layer->plane_alpha, layer->frame_rate, layer->solid_fill_color);
+      snprintf(buf, sizeof(buf), "%s\n LayerFlags = %#x", buf, layer->flags);
+      snprintf(buf, sizeof(buf), "%s\t LayerFlags.skip = %d", buf, layer->flags.skip);
+      snprintf(buf, sizeof(buf), "%s\n LayerBuffer Flags: hdr:%d secure:%d video:%d", buf,
+                    buffer.flags.hdr, buffer.flags.secure, buffer.flags.video);
+
+      fprintf(stderr,"\n%s\n", buf);
+  }
+  frame_count++;
+
+  return;
+}
+#endif
+
+DisplayError SdmDisplay::Prepare(struct drm_output *output)
+{
+    DisplayError error = kErrorNone;
+
+    if (esd_reset_panel_) {
+      return kErrorNotSupported;
+    }
+
+#if SDM_DISPLAY_DUMP_LAYER_STACK
+    char dump_buffer[8192] = {0};
+#endif
+
+    error = PrePrepare(output);
+    if (error != kErrorNone) {
+        DLOGE("failed during PrePrepare");
+    }
+
+#if SDM_DISPLAY_DUMP_LAYER_STACK
+    // Dump all input layers of the layer stack:
+    GetLayerStackDump(&layer_stack_, dump_buffer, sizeof(dump_buffer));
+#endif
+
+    error = display_intf_->Prepare(&layer_stack_);
+    if (error != kErrorNone) {
+        DLOGE("failed during Prepare error:%d\n",error);
+    }
+
+#if SDM_DISPLAY_DUMP_LAYER_STACK
+    DumpInterface::GetDump(dump_buffer, sizeof(dump_buffer));
+#endif
+
+    error = PostPrepare(output);
+    if (error != kErrorNone)
+	DLOGE("function failed Error= %d\n", error);
+
+    return error;
+}
+
+DisplayError SdmDisplay::PreCommit()
+{
+    return kErrorNone;
+}
+
+
+DisplayError SdmDisplay::PostCommit()
+{
+    DisplayError error = kErrorNone;
+
+    //Wait for retire fence fds
+    if (prev_layer_stack_.retire_fence) {
+        int ret = -1;
+        ret = Fence::Wait(prev_layer_stack_.retire_fence);
+        if (ret != kErrorNone) {
+            DLOGE("retire_fence wait timeout! ret=%d\n", ret);
+        }
+    }
+
+    prev_layer_stack_ = layer_stack_;
+    //Iterate through the layer buffer and close release fences
+    for (uint32_t i = 0; i < layer_stack_.layers.size(); i++) {
+        Layer *layer = layer_stack_.layers.at(i);
+        LayerBuffer *layer_buffer = &layer->input_buffer;
+    }
+
+    return error;
+}
+
+DisplayError SdmDisplay::Commit(struct drm_output *output)
+{
+    DTRACE_SCOPED();
+    DisplayError ret = kErrorNone;
+
+    if (esd_reset_panel_) {
+      return kErrorNotSupported;
+    }
+
+    uint32_t layer_count = layer_stack_.layers.size();
+    uint32_t GPUTarget_index = layer_count-1;
+    Layer *GpuTargetlayer;
+
+    if (!output->next_fb) {
+	DLOGE("Scanout state fb not found for output=%d", output->base.id);
+	return kErrorUndefined;
+    }
+
+    GpuTargetlayer = layer_stack_.layers.at(GPUTarget_index);
+    GpuTargetlayer->input_buffer.planes[0].fd = output->next_fb->ion_fd;
+
+    DLOGI("commiting ion fd = %d, layer count=%d", output->next_fb->ion_fd, layer_count);
+
+    PreCommit();
+    prev_output_ = output;
+    ret = display_intf_->Commit(&layer_stack_);
+
+    PostCommit();
+
+    // Caching release fence for buffer synchronization during buffer release.
+    struct sdm_layer *sdm_layer = NULL;
+    uint32_t index = 0;
+    wl_list_for_each_reverse(sdm_layer, &output->sdm_layer_list, link) {
+         Layer *layer = layer_stack_.layers.at(index);
+         sdm_layer->release_fence_fd = Fence::Dup(layer->input_buffer.release_fence);
+    }
+
+    DLOGV("success");
+    return ret;
+}
+
+/* Adding following  support functions */
+LayerBufferFormat SdmDisplay::GetSDMFormat(uint32_t src_fmt, struct LayerGeometryFlags flags)
+{
+    LayerBufferFormat format = kFormatInvalid;
+
+    if (flags.has_ubwc_buf) {
+        switch (src_fmt) {
+            case SDM_BUFFER_FORMAT_RGBA_8888:
+                format = sdm::kFormatRGBA8888Ubwc;
+                break;
+            case SDM_BUFFER_FORMAT_RGBX_8888:
+                format = sdm::kFormatRGBX8888Ubwc;
+                break;
+            case SDM_BUFFER_FORMAT_BGR_565:
+                format = sdm::kFormatBGR565Ubwc;
+                break;
+            case SDM_BUFFER_FORMAT_RGBA_2101010:
+                format = sdm::kFormatRGBA1010102Ubwc;
+                break;
+            case SDM_BUFFER_FORMAT_YCbCr_420_SP_VENUS:
+            case SDM_BUFFER_FORMAT_NV12_ENCODEABLE:
+                format = sdm::kFormatYCbCr420SPVenusUbwc;
+                break;
+            case SDM_BUFFER_FORMAT_YCbCr_420_TP10_UBWC:
+                format = sdm::kFormatYCbCr420TP10Ubwc;
+                break;
+            case SDM_BUFFER_FORMAT_YCbCr_420_P010_UBWC:
+                format = sdm::kFormatYCbCr420P010Ubwc;
+                break;
+            default:
+                DLOGE("Unsupported UBWC format %d\n", src_fmt);
+                return sdm::kFormatInvalid;
+        }
+
+        return format;
+    }
+
+    switch (src_fmt) {
+        case SDM_BUFFER_FORMAT_RGBA_8888:
+            format = sdm::kFormatRGBA8888;
+            break;
+        case SDM_BUFFER_FORMAT_RGBA_5551:
+            format = sdm::kFormatRGBA5551;
+            break;
+        case SDM_BUFFER_FORMAT_RGBA_4444:
+            format = sdm::kFormatRGBA4444;
+            break;
+        case SDM_BUFFER_FORMAT_BGRA_8888:
+            format = sdm::kFormatBGRA8888;
+            break;
+        case SDM_BUFFER_FORMAT_RGBX_8888:
+            format = sdm::kFormatRGBX8888;
+            break;
+        case SDM_BUFFER_FORMAT_BGRX_8888:
+            format = sdm::kFormatBGRX8888;
+            break;
+        case SDM_BUFFER_FORMAT_RGB_888:
+            format = sdm::kFormatRGB888;
+            break;
+        case SDM_BUFFER_FORMAT_RGB_565:
+            format = sdm::kFormatRGB565;
+            break;
+        case SDM_BUFFER_FORMAT_BGR_565:
+            format = sdm::kFormatBGR565;
+            break;
+        case SDM_BUFFER_FORMAT_NV12_ENCODEABLE:
+        case SDM_BUFFER_FORMAT_YCbCr_420_SP_VENUS:
+            format = sdm::kFormatYCbCr420SemiPlanarVenus;
+            break;
+        case SDM_BUFFER_FORMAT_ABGR_2101010:
+            format = sdm::kFormatABGR2101010;
+            break;
+        case SDM_BUFFER_FORMAT_RGBA_2101010:
+            format = sdm::kFormatRGBA1010102;
+            break;
+        case SDM_BUFFER_FORMAT_YCbCr_420_TP10_UBWC:
+            format = sdm::kFormatYCbCr420TP10Ubwc;
+            break;
+        case SDM_BUFFER_FORMAT_YCbCr_420_P010_UBWC:
+            format = sdm::kFormatYCbCr420P010Ubwc;
+            break;
+        case SDM_BUFFER_FORMAT_YV12:
+            format = sdm::kFormatYCrCb420PlanarStride16;
+            break;
+        case SDM_BUFFER_FORMAT_YCrCb_420_SP:
+            format = sdm::kFormatYCrCb420SemiPlanar;
+            break;
+        case SDM_BUFFER_FORMAT_YCbCr_420_SP:
+            format = sdm::kFormatYCbCr420SemiPlanar;
+            break;
+        case SDM_BUFFER_FORMAT_YCbCr_422_SP:
+            format = sdm::kFormatYCbCr422H2V1SemiPlanar;
+            break;
+        case SDM_BUFFER_FORMAT_YCbCr_422_I:
+            format = sdm::kFormatYCbCr422H2V1Packed;
+            break;
+        case SDM_BUFFER_FORMAT_P010:
+            format = sdm::kFormatYCbCr420P010;
+            break;
+        default:
+            DLOGE("Unsupported format %d\n", src_fmt);
+            return sdm::kFormatInvalid;
+    }
+
+    return format;
+}
+
+LayerBlending SdmDisplay::GetSDMBlending(uint32_t source)
+{
+    sdm::LayerBlending blending = sdm::kBlendingPremultiplied;
+
+    switch (source) {
+    case SDM_BLENDING_PREMULTIPLIED:
+         blending = sdm::kBlendingPremultiplied;
+         break;
+    case SDM_BLENDING_COVERAGE:
+         blending = sdm::kBlendingCoverage;
+         break;
+    case SDM_BLENDING_NONE:
+    default:
+         blending = sdm::kBlendingOpaque;
+         break;
+    }
+
+    return blending;
+}
+
+bool SdmDisplay::GetVideoPresenceByFormatFromGbm(uint32_t fmt)
+{
+    bool is_video_present = false;
+
+    switch (fmt) {
+       case GBM_FORMAT_NV12:
+       case GBM_FORMAT_YCbCr_420_TP10_UBWC:
+       case GBM_FORMAT_YCbCr_420_P010_UBWC:
+       case GBM_FORMAT_P010:
+            is_video_present = true;
+            break;
+       default:
+            is_video_present = false;
+            break;
+    }
+
+    return is_video_present;
+}
+
+uint32_t SdmDisplay::GetMappedFormatFromGbm(uint32_t fmt)
+{
+    uint32_t ret = SDM_BUFFER_FORMAT_INVALID;
+
+    switch (fmt) {
+    case GBM_FORMAT_ARGB8888:
+         ret = SDM_BUFFER_FORMAT_BGRA_8888;
+         break;
+    case GBM_FORMAT_XRGB8888:
+         ret = SDM_BUFFER_FORMAT_BGRX_8888;
+         break;
+    case GBM_FORMAT_ABGR8888:
+         ret = SDM_BUFFER_FORMAT_RGBA_8888;
+         break;
+    case GBM_FORMAT_XBGR8888:
+         ret = SDM_BUFFER_FORMAT_RGBX_8888;
+         break;
+    case GBM_FORMAT_BGRA8888:
+    case GBM_FORMAT_RGBA8888:
+         ret = SDM_BUFFER_FORMAT_ARGB_8888;
+         break;
+    case GBM_FORMAT_ARGB4444:
+    case GBM_FORMAT_ABGR4444:
+         ret = SDM_BUFFER_FORMAT_RGBA_4444;
+         break;
+    case GBM_FORMAT_ARGB1555:
+    case GBM_FORMAT_ABGR1555:
+         ret = SDM_BUFFER_FORMAT_RGBA_5551;
+         break;
+    case GBM_FORMAT_RGB565:
+         ret = SDM_BUFFER_FORMAT_BGR_565;
+         break;
+    case GBM_FORMAT_BGR565:
+         ret = SDM_BUFFER_FORMAT_RGB_565;
+         break;
+    case GBM_FORMAT_RGB888:
+         ret = SDM_BUFFER_FORMAT_BGR_888;
+         break;
+    case GBM_FORMAT_BGR888:
+         ret = SDM_BUFFER_FORMAT_RGB_888;
+         break;
+    case GBM_FORMAT_NV12:
+         ret = SDM_BUFFER_FORMAT_YCbCr_420_SP_VENUS;
+         break;
+    case GBM_FORMAT_ABGR2101010:
+         ret = SDM_BUFFER_FORMAT_RGBA_2101010;
+         break;
+    case GBM_FORMAT_YCbCr_420_TP10_UBWC:
+         ret = SDM_BUFFER_FORMAT_YCbCr_420_TP10_UBWC;
+         break;
+    case GBM_FORMAT_YCbCr_420_P010_UBWC:
+        ret = SDM_BUFFER_FORMAT_YCbCr_420_P010_UBWC;
+        break;
+    case GBM_FORMAT_P010:
+        ret = SDM_BUFFER_FORMAT_P010;
+        break;
+    default:
+         DLOGE("Unsupported GBM format %s\n", FourccToString(fmt));
+         break;
+    }
+
+    return ret;
+}
+
+bool SdmDisplay::NeedConvertGbmFormat(struct weston_view *ev, uint32_t format)
+{
+    pixman_region32_t r;
+    bool need_convert = false;
+
+    if (IsTransparentGbmFormat(format)) {
+     pixman_region32_init_rect(&r, 0, 0,
+             ev->surface->width,
+             ev->surface->height);
+     pixman_region32_subtract(&r, &r, &ev->surface->opaque);
+
+     if (!pixman_region32_not_empty(&r))
+         need_convert = true;
+
+     pixman_region32_fini(&r);
+    }
+
+    return need_convert;
+}
+
+uint32_t SdmDisplay::ConvertToOpaqueGbmFormat(uint32_t format)
+{
+    uint32_t ret = GBM_FORMAT_XRGB8888;
+
+    switch (format) {
+    case GBM_FORMAT_ARGB8888:
+     ret = GBM_FORMAT_XRGB8888;
+     break;
+    case GBM_FORMAT_BGRA8888:
+     ret = GBM_FORMAT_BGRX8888;
+     break;
+    case GBM_FORMAT_RGBA8888:
+     ret = GBM_FORMAT_RGBX8888;
+     break;
+    case GBM_FORMAT_ABGR8888:
+     ret = GBM_FORMAT_XBGR8888;
+     break;
+    default:
+     break;
+    }
+
+    return ret;
+}
+
+void SdmDisplay::ComputeSrcDstRect(struct drm_output *output, struct weston_view *ev,
+                    struct Rect *src_ret, struct Rect *dst_ret)
+{
+    pixman_region32_t src_rect, dest_rect;
+    float sx1, sy1, sx2, sy2;
+
+    /* dst rect */
+    pixman_region32_init(&dest_rect);
+    pixman_region32_intersect(&dest_rect, &ev->transform.boundingbox, &output->base.region);
+
+    pixman_region32_translate(&dest_rect, -output->base.x, -output->base.y);
+
+    pixman_box32_t *box, tbox = {0};
+    box = pixman_region32_extents(&dest_rect);
+
+    sdm_weston_transformed_rect(output, &tbox, *box);
+
+    dst_ret->left = tbox.x1;
+    dst_ret->right = tbox.x2;
+    dst_ret->top = tbox.y1;
+    dst_ret->bottom = tbox.y2;
+
+    pixman_region32_fini(&dest_rect);
+
+    /* src rect */
+    pixman_region32_init(&src_rect);
+    pixman_region32_intersect(&src_rect, &ev->transform.boundingbox,
+                              &output->base.region);
+    box = pixman_region32_extents(&src_rect);
+
+    sdm_weston_global_transform_rect(ev, box, &sx1, &sy1, &sx2, &sy2);
+
+    pixman_region32_fini(&src_rect);
+
+    src_ret->left = sx1;
+    src_ret->top = sy1;
+    src_ret->right = sx2;
+    src_ret->bottom = sy2;
+}
+
+int SdmDisplay::ComputeDirtyRegion(struct weston_view *ev,
+                    struct RectArray *dirty) {
+    pixman_region32_t temp;
+    struct weston_surface *es = ev->surface;
+    pixman_box32_t *rectangles = NULL;
+    int n, i;
+
+    pixman_region32_init(&temp);
+    pixman_region32_intersect_rect(&temp, &es->damage, 0,
+                    0, es->width, es->height);
+    rectangles = pixman_region32_rectangles(&temp, &n);
+    if (!n) {
+     pixman_region32_fini(&temp);
+     return 0;
+    }
+
+    dirty->rects = reinterpret_cast<struct Rect *> \
+                    (zalloc(n * sizeof(struct Rect)));
+    if (dirty->rects == NULL) {
+     DLOGE("out of memory for allocating dirty region\n");
+     return -1;
+    }
+    for (i = 0; i < n; i++) {
+     dirty->rects[i].left = (float)rectangles[i].x1;
+     dirty->rects[i].top = (float)rectangles[i].y1;
+     dirty->rects[i].right = (float)rectangles[i].x2;
+     dirty->rects[i].bottom = (float)rectangles[i].y2;
+    }
+    dirty->count = n;
+    pixman_region32_fini(&temp);
+
+    return 0;
+}
+
+uint8_t SdmDisplay::GetGlobalAlpha(struct weston_view *ev)
+{
+    if (ev->alpha > 1.0f)
+     return 0xFF;
+    else if (ev->alpha < 0.0f)
+     return 0;
+    else
+     return (uint8_t)(0xFF * ev->alpha);
+}
+
+int SdmDisplay::GetVisibleRegion(struct drm_output *output, struct weston_view *ev,
+                                         pixman_region32_t *aboved_opaque,
+                                         struct RectArray *visible)
+{
+    pixman_region32_t temp;
+    pixman_box32_t *rectangles = NULL;
+    int n, i;
+
+    pixman_region32_init(&temp);
+    pixman_region32_copy(&temp, &ev->transform.boundingbox);
+    pixman_region32_subtract(&temp, &temp, aboved_opaque);
+    pixman_region32_intersect(&temp, &output->base.region, &temp);
+    pixman_region32_translate(&temp, -output->base.x, -output->base.y);
+
+    rectangles = pixman_region32_rectangles(&temp, &n);
+    if (!n) {
+     pixman_region32_fini(&temp);
+     return 0;
+    }
+
+    visible->rects = reinterpret_cast<struct Rect *> (zalloc(n * sizeof(struct Rect)));
+    if (visible->rects == NULL) {
+     DLOGE("out of memory for allocating visible region\n");
+     return -1;
+    }
+    for (i = 0; i < n; i++) {
+     visible->rects[i].left = (float)rectangles[i].x1;
+     visible->rects[i].top = (float)rectangles[i].y1;
+     visible->rects[i].right = (float)rectangles[i].x2;
+     visible->rects[i].bottom = (float)rectangles[i].y2;
+    }
+    visible->count = n;
+    pixman_region32_fini(&temp);
+
+    return 0;
+}
+
+bool SdmDisplay::IsTransparentGbmFormat(uint32_t format)
+{
+    return false;
+}
+
+const char *SdmDisplay::GetDisplayString() {
+    switch (display_type_) {
+    case kPrimary:
+      return "primary";
+    case kHDMI:
+      return "hdmi";
+    case kVirtual:
+      return "virtual";
+    default:
+      return "invalid";
+  }
+}
+
+DisplayError SdmDisplay::GetHdrInfo(struct DisplayHdrInfo *display_hdr_info) {
+  DisplayError error;
+
+  DisplayConfigFixedInfo fixed_info = {};
+  error = display_intf_->GetConfig(&fixed_info);
+
+  if (error != kErrorNone) {
+      DLOGE("Failed to get fixed info. Error = %d", error);
+      return error;
+  }
+
+  hdr_supported_ = fixed_info.hdr_supported;
+
+  if (!fixed_info.hdr_supported) {
+      DLOGI("HDR is not supported");
+      return error;
+  }
+
+  max_luminance_ = fixed_info.max_luminance;
+  max_average_luminance_ = fixed_info.average_luminance;
+  min_luminance_ = fixed_info.min_luminance;
+
+  display_hdr_info->hdr_supported = fixed_info.hdr_supported;
+  display_hdr_info->hdr_eotf = fixed_info.hdr_eotf;
+  display_hdr_info->hdr_metadata_type_one = fixed_info.hdr_metadata_type_one;
+  display_hdr_info->max_luminance = fixed_info.max_luminance;
+  display_hdr_info->average_luminance = fixed_info.average_luminance;
+  display_hdr_info->min_luminance = fixed_info.min_luminance;
+
+  return error;
+}
+
+SdmNullDisplay::SdmNullDisplay(DisplayType type, CoreInterface *core_intf) {
+}
+
+SdmNullDisplay::~SdmNullDisplay() {
+}
+
+DisplayError SdmNullDisplay::CreateDisplay(uint32_t display_id) {
+  return kErrorNone;
+}
+DisplayError SdmNullDisplay::DestroyDisplay() {
+  return kErrorNone;
+}
+DisplayError SdmNullDisplay::Prepare(struct drm_output *output) {
+  return kErrorNone;
+}
+DisplayError SdmNullDisplay::Commit(struct drm_output *output) {
+  /**
+   * TODO: We need to handle releasing the buffer references such that
+   * the video buffers/frames keep moving forward in time even though
+   * not displayed. This will be done at a later point of time.
+   */
+  return kErrorNone;
+}
+DisplayError SdmNullDisplay::SetDisplayState(DisplayState state, bool teardown,
+                                             shared_ptr<Fence> *release_fence) {
+  return kErrorNone;
+}
+
+DisplayError SdmNullDisplay::SetPanelBrightness(float brightness) {
+  return kErrorNone;
+}
+
+DisplayError SdmNullDisplay::GetPanelBrightness(float *brightness) {
+  return kErrorNone;
+}
+
+DisplayError SdmNullDisplay::SetVSyncState(bool enable, struct drm_output *output) {
+  /**
+   * TODO: drm_output_ needs to be re-initialized based on the preferred supported mode
+   *       of the plugged-in display. The recent Weston release contains better APIs
+   *       to handle this case. Hence this implementation will be improved based upon
+   *       the recent Weston release updates.
+   */
+  drm_output_ = output;
+  return kErrorNone;
+}
+
+DisplayError SdmNullDisplay::GetDisplayConfiguration(struct DisplayConfigInfo *display_config) {
+  uint32_t props_value[3] = {0};
+  char null_display_props[MAX_PROP_STR_SIZE] = {0};
+  char *prop = NULL, *saveptr = NULL;
+
+  // sdm.null.resolution format is width:height:fps
+  SdmDisplayDebugger::Get()->GetProperty(SDM_NULL_DISPLAY_RESOLUTON_PROP_NAME, null_display_props);
+
+  prop = strtok_r(null_display_props, ":", &saveptr);
+  for (int i =0; i<3 && prop != NULL; i++)
+  {
+    props_value[i] = UINT32(atoi(prop));
+    prop = strtok_r(NULL, ":", &saveptr);
+  }
+
+  if (props_value[0] == 0 || props_value[1] == 0) {
+    display_config->x_pixels = SDM_DEAFULT_NULL_DISPLAY_WIDTH;
+    display_config->y_pixels = SDM_DEAFULT_NULL_DISPLAY_HEIGHT;
+  } else {
+    display_config->x_pixels = props_value[0];
+    display_config->y_pixels = props_value[1];
+  }
+
+  if (props_value[2] == 0)
+    display_config->fps = SDM_DEAFULT_NULL_DISPLAY_FPS;
+  else
+    display_config->fps = props_value[2];
+
+  display_config->x_dpi = SDM_DEAFULT_NULL_DISPLAY_X_DPI;
+  display_config->y_dpi = SDM_DEAFULT_NULL_DISPLAY_Y_DPI;
+  display_config->vsync_period_ns = UINT32(1000000000/display_config->fps);
+  display_config->is_yuv = SDM_DEAFULT_NULL_DISPLAY_IS_YUV;
+
+  return kErrorNone;
+}
+DisplayError SdmNullDisplay::RegisterCb(int display_id, vblank_cb_t vbcb) {
+  vblank_cb_   = vbcb;
+
+  return kErrorNone;
+}
+
+DisplayError SdmNullDisplay::GetHdrInfo(struct DisplayHdrInfo *display_hdr_info) {
+  return kErrorNone;
+}
+
+SdmDisplayProxy::SdmDisplayProxy(DisplayType type, CoreInterface *core_intf,
+                                 SdmDisplayBufferAllocator *buffer_allocator)
+  : disp_type_(type), core_intf_(core_intf),
+    sdm_disp_(type, core_intf, buffer_allocator), null_disp_(type, core_intf) {
+
+    display_intf_ = &sdm_disp_;
+    buffer_allocator_ = buffer_allocator;
+    std::thread uevent_thread(UeventThread, this);
+    uevent_thread_.swap(uevent_thread);
+}
+
+SdmDisplayProxy::~SdmDisplayProxy () {
+    uevent_thread_exit_ = true;
+    uevent_thread_.detach();
+}
+
+int SdmDisplayProxy::HandleHotplug(bool connected) {
+  return kErrorNone;
+}
+
+void *SdmDisplayProxy::UeventThread(void *context) {
+  if (context) {
+    return reinterpret_cast<SdmDisplayProxy *>(context)->UeventThreadHandler();
+  }
+
+  return NULL;
+}
+
+#define HAL_PRIORITY_URGENT_DISPLAY (-8)
+
+void *SdmDisplayProxy::UeventThreadHandler() {
+  static char uevent_data[4096];
+  int length = 0;
+  prctl(PR_SET_NAME, uevent_thread_name_, 0, 0, 0);
+  setpriority(PRIO_PROCESS, 0, HAL_PRIORITY_URGENT_DISPLAY);
+  if (!uevent_init()) {
+    DLOGW("Failed to init uevent");
+    pthread_exit(0);
+    return NULL;
+  }
+
+  DLOGI("SdmDisplayProxy::UeventThreadHandler");
+
+  while (!uevent_thread_exit_) {
+    // keep last 2 zeroes to ensure double 0 termination
+    length = uevent_next_event(uevent_data, INT32(sizeof(uevent_data)) - 2);
+    string s(uevent_data, length);
+
+    if (s.find("name=DSI-1") != string::npos) {
+      bool connected = s.find("status=connected") != string::npos;
+      DLOGI("DSI is %s !\n", connected ? "connected" : "removed");
+      HandleHotplug(connected);
+    }
+  }
+  pthread_exit(0);
+
+  return NULL;
+}
+
+}  // namespace sdm
diff --git a/libweston/backend-sdm/sdm-service/sdm_display.h b/libweston/backend-sdm/sdm-service/sdm_display.h
new file mode 100644
index 0000000..233524a
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display.h
@@ -0,0 +1,311 @@
+/*
+* Copyright (c) 2017, 2021 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center, Inc. are provided under the following license:
+* Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*
+*/
+
+#ifndef __SDM_DISPLAY_H__
+#define __SDM_DISPLAY_H__
+
+#include <core/core_interface.h>
+#include <core/display_interface.h>
+#include <debug_handler.h>
+#include <utils/debug.h>
+#include <utils/constants.h>
+#include <utils/formats.h>
+#include <private/color_params.h>
+#include <color_metadata.h>
+#include <stdio.h>
+#include <string>
+#include <utility>
+#include <map>
+#include <vector>
+#include <iostream>
+#include <thread>
+#include <atomic>
+#include <memory>
+
+#include "sdm-service/sdm_display_debugger.h"
+#include "sdm-service/sdm_display_interface.h"
+#include "sdm-service/sdm_display_buffer_allocator.h"
+#include "sdm-service/sdm_display_buffer_sync_handler.h"
+#include "sdm-service/sdm_display_socket_handler.h"
+#include "sdm-service/sdm_color_mode_intf.h"
+#include "sdm-internal.h"
+#include "drm_master.h"
+
+namespace sdm {
+using namespace drm_utils;
+
+using std::vector;
+using std::iterator;
+using std::string;
+using std::to_string;
+using std::map;
+using std::pair;
+using std::fstream;
+
+class SdmDisplayProxy;
+
+enum SdmDisplayIntfType {null_disp, sdm_disp};
+
+typedef std::map<uint32_t, HWDisplayInfo> SdmDisplaysInfo;
+
+// map<display_id, sdm_display>
+typedef std::map<uint32_t, SdmDisplayProxy *> CreatedDisplaysInfo;
+
+class SdmDisplayInterface {
+  public:
+    virtual ~SdmDisplayInterface() {}
+
+    virtual DisplayError CreateDisplay(uint32_t display_id) = 0;
+    virtual DisplayError DestroyDisplay() = 0;
+    virtual DisplayError Prepare(struct drm_output *output) = 0;
+    virtual DisplayError Commit(struct drm_output *output) = 0;
+    virtual DisplayError SetDisplayState(DisplayState state, bool teardown,
+                                         shared_ptr<Fence> *release_fence) = 0;
+    virtual DisplayError SetVSyncState(bool enable, struct drm_output *output) = 0;
+    virtual DisplayError GetDisplayConfiguration(struct DisplayConfigInfo *display_config) = 0;
+    virtual DisplayError RegisterCb(int display_id, vblank_cb_t vbcb) = 0;
+    virtual SdmDisplayIntfType GetDisplayIntfType() = 0;
+    virtual DisplayError SetPanelBrightness(float brightness) = 0;
+    virtual DisplayError GetPanelBrightness(float *brightness) = 0;
+    virtual DisplayError GetHdrInfo(struct DisplayHdrInfo *display_hdr_info) = 0;
+    static int GetDrmMasterFd();
+    static void SetDrmMasterFd(int fd);
+    struct drm_output *drm_output_;
+    struct drm_output *prev_output_;
+};
+
+class SdmNullDisplay : public SdmDisplayInterface {
+  public:
+    SdmNullDisplay(DisplayType type, CoreInterface *core_intf);
+    ~SdmNullDisplay();
+
+    SdmDisplayIntfType GetDisplayIntfType() {
+      return null_disp;
+    }
+    DisplayError CreateDisplay(uint32_t display_id);
+    DisplayError DestroyDisplay();
+    DisplayError Prepare(struct drm_output *output);
+    DisplayError Commit(struct drm_output *output);
+    DisplayError SetDisplayState(DisplayState state, bool teardown,
+                                 shared_ptr<Fence> *release_fence);
+    DisplayError SetVSyncState(bool enable, struct drm_output *output);
+    DisplayError GetDisplayConfiguration(struct DisplayConfigInfo *display_config);
+    DisplayError RegisterCb(int display_id, vblank_cb_t vbcb);
+    DisplayError SetPanelBrightness(float brightness);
+    DisplayError GetPanelBrightness(float *brightness);
+    DisplayError GetHdrInfo(struct DisplayHdrInfo *display_hdr_info);
+};
+
+class SdmDisplay : public SdmDisplayInterface, DisplayEventHandler, SdmDisplayDebugger {
+
+ public:
+    SdmDisplay(DisplayType type, CoreInterface *core_intf,
+                                 SdmDisplayBufferAllocator *buffer_allocator);
+    ~SdmDisplay();
+
+    SdmDisplayIntfType GetDisplayIntfType() {
+      return sdm_disp;
+    }
+
+    DisplayError CreateDisplay(uint32_t display_id);
+    DisplayError DestroyDisplay();
+    DisplayError Prepare(struct drm_output *output);
+    DisplayError Commit(struct drm_output *output);
+    DisplayError SetDisplayState(DisplayState state, bool teardown,
+                                 shared_ptr<Fence> *release_fence);
+    DisplayError SetVSyncState(bool enable, struct drm_output *output);
+    DisplayError GetDisplayConfiguration(struct DisplayConfigInfo *display_config);
+    DisplayError RegisterCb(int display_id, vblank_cb_t vbcb);
+    DisplayError SetPanelBrightness(float brightness);
+    DisplayError GetPanelBrightness(float *brightness);
+
+    int OnMinHdcpEncryptionLevelChange(uint32_t min_enc_level);
+    DisplayError GetHdrInfo(struct DisplayHdrInfo *display_hdr_info);
+
+ protected:
+    virtual DisplayError VSync(const DisplayEventVSync &vsync);
+    virtual DisplayError VSync(int fd, unsigned int sequence,
+                               unsigned int tv_sec, unsigned int tv_usec,
+                               void *data);
+    virtual DisplayError PFlip(int fd, unsigned int sequence,
+                               unsigned int tv_sec, unsigned int tv_usec,
+                               void *data);
+    virtual DisplayError CECMessage(char *message);
+    virtual DisplayError HistogramEvent(int source_fd, uint32_t blob_id);
+
+    /*! @brief Event handler for events received by Display HAL. */
+    virtual DisplayError HandleEvent(DisplayEvent event);
+    virtual DisplayError Refresh();
+    virtual void MMRMEvent(bool restricted){
+      return;
+    }
+
+ private:
+    static const int kBufferDepth = 2;
+    static std::atomic<uint64_t> next_id_;
+    DisplayError FreeLayerStack();
+    DisplayError FreeLayerGeometry(struct LayerGeometry *glayer);
+    DisplayError AllocateMemoryForLayerGeometry(struct drm_output *output,
+                                                uint32_t index,
+                                                struct LayerGeometry *glayer);
+    DisplayError AddGeometryLayerToLayerStack(struct drm_output *output,
+                                              uint32_t index,
+                                              struct LayerGeometry *glayer, bool is_skip);
+    DisplayError AllocLayerStackMemory(struct drm_output *output);
+    DisplayError PopulateLayerGeometryOnToLayerStack(struct drm_output *output,
+                                                     uint32_t index,
+                                                     struct LayerGeometry *glayer, bool is_skip);
+    int PrepareNormalLayerGeometry(struct drm_output *output,
+                                   struct LayerGeometry **glayer,
+                                   struct sdm_layer *sdm_layer);
+    int PrepareFbLayerGeometry(struct drm_output *output,
+                               struct LayerGeometry **fb_glayer);
+    DisplayError PrePrepareLayerStack(struct drm_output *output);
+    DisplayError PrePrepare(struct drm_output *output);
+    DisplayError PostPrepare(struct drm_output *output);
+    DisplayError PreCommit();
+
+    DisplayError PostCommit();
+    LayerBufferFormat GetSDMFormat(uint32_t src_fmt,
+                                   struct LayerGeometryFlags flags);
+    LayerBlending GetSDMBlending(uint32_t source);
+    void DumpInputBuffers(void *compositor_output);
+    void DumpOutputBuffer(const BufferInfo& buffer_info,
+                          void *base, int fence);
+    const char*  GetDisplayString();
+    /* support functions */
+    const char * FourccToString(uint32_t fourcc);
+    uint32_t GetMappedFormatFromGbm(uint32_t fmt);
+    bool GetVideoPresenceByFormatFromGbm(uint32_t fmt);
+    uint32_t GetMappedFormatFromShm(uint32_t fmt);
+    bool NeedConvertGbmFormat(struct weston_view *ev, uint32_t format);
+    uint32_t ConvertToOpaqueGbmFormat(uint32_t format);
+    void ComputeSrcDstRect(struct drm_output *output, struct weston_view *ev,
+                                  struct Rect *src_ret, struct Rect *dst_ret);
+    int  ComputeDirtyRegion(struct weston_view *ev, struct RectArray *dirty);
+    uint8_t GetGlobalAlpha(struct weston_view *ev);
+    int GetVisibleRegion(struct drm_output *output, struct weston_view *ev,
+                         pixman_region32_t *aboved_opaque, struct RectArray *visible);
+    bool IsTransparentGbmFormat(uint32_t format);
+    void HandlePanelDead();
+    void RefreshWithCachedLayerstack();
+    ColorMode SelectBestColorSpace(bool isHdrSupported);
+    ColorMode GetBestHDRColorMode(ColorPrimaries layer_gamut, GammaTransfer layer_gamma);
+    void InitializeLayerIds();
+
+    CoreInterface *core_intf_ = NULL;
+    SdmDisplayBufferAllocator *buffer_allocator_;
+    SdmDisplaySocketHandler socket_handler_;
+    DisplayEventHandler *client_event_handler_ = NULL;
+    DisplayInterface *display_intf_ = NULL;
+    DisplayType display_type_ = kDisplayMax;
+    DisplayConfigVariableInfo variable_info_;
+    HWDisplayInterfaceInfo hw_disp_info_;
+    bool shutdown_pending_ = false;
+    LayerStack layer_stack_;
+    int  display_id_ = -1;
+    uint32_t fps_ = 0;
+    float max_luminance_ = 0.0;
+    float max_average_luminance_ = 0.0;
+    float min_luminance_ = 0.0;
+    LayerStack prev_layer_stack_;
+    bool esd_reset_panel_ = false;
+
+    int disable_hdr_handling_ = 1;
+    bool hdr_supported_ = false;
+    std::unique_ptr<SDMColorModeIntf> color_mode_intf_ = nullptr;
+};
+
+class SdmDisplayProxy {
+  public:
+    SdmDisplayProxy(DisplayType type, CoreInterface *core_intf,
+                    SdmDisplayBufferAllocator *buffer_allocator);
+    ~SdmDisplayProxy();
+
+    DisplayError CreateDisplay(uint32_t display_id) {
+      DisplayError rc = display_intf_->CreateDisplay(display_id);
+      if (rc != kErrorNone)
+        display_intf_ = &null_disp_;
+      return kErrorNone;
+    }
+    DisplayError DestroyDisplay() { return display_intf_->DestroyDisplay(); }
+    DisplayError Prepare(struct drm_output *output) {
+      return display_intf_->Prepare(output);
+    }
+    DisplayError Commit(struct drm_output *output) {
+      return display_intf_->Commit(output);
+    }
+    DisplayError SetDisplayState(DisplayState state, bool teardown,
+                                 shared_ptr<Fence> *release_fence) {
+      return display_intf_->SetDisplayState(state, teardown, release_fence);
+    }
+    DisplayError SetVSyncState(bool enable, struct drm_output *output) {
+      return display_intf_->SetVSyncState(enable, output);
+    }
+    DisplayError GetDisplayConfiguration(struct DisplayConfigInfo *display_config) {
+      return display_intf_->GetDisplayConfiguration(display_config);
+    }
+    DisplayError RegisterCbs(int display_id, sdm_cbs_t *cbs) {
+      // TODO: move vblank_cb up?
+      hotplug_cb_ = cbs->hotplug_cb;
+      return display_intf_->RegisterCb(display_id, cbs->vblank_cb);
+    }
+    DisplayError SetPanelBrightness(float brightness) {
+      return display_intf_->SetPanelBrightness(brightness);
+    }
+    DisplayError GetPanelBrightness(float *brightness) {
+      return display_intf_->GetPanelBrightness(brightness);
+    }
+    int HandleHotplug(bool connected);
+
+    DisplayError OnMinHdcpEncryptionLevelChange(uint32_t min_enc_level);
+    DisplayError GetHdrInfo(struct DisplayHdrInfo *display_hdr_info) {
+      return display_intf_->GetHdrInfo(display_hdr_info);
+    }
+
+  private:
+    // Uevent thread
+    static void *UeventThread(void *context);
+    void *UeventThreadHandler();
+
+    SdmDisplayInterface *display_intf_;
+    DisplayType disp_type_;
+    CoreInterface *core_intf_;
+    SdmNullDisplay null_disp_;
+    SdmDisplayBufferAllocator *buffer_allocator_;
+    SdmDisplay sdm_disp_;
+    std::thread uevent_thread_;
+    bool uevent_thread_exit_ = false;
+    const char *uevent_thread_name_ = "SDM_UeventThread";
+    hotplug_cb_t hotplug_cb_;
+};
+
+}  // namespace sdm
+
+#endif  // __SDM_DISPLAY_H__
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_buffer_allocator.cpp b/libweston/backend-sdm/sdm-service/sdm_display_buffer_allocator.cpp
new file mode 100644
index 0000000..0adf38f
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_buffer_allocator.cpp
@@ -0,0 +1,433 @@
+/*
+* Copyright (c) 2017, 2020-2021, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+*
+* Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#include "sdm-service/sdm_display_debugger.h"
+#include "sdm-service/sdm_display_buffer_allocator.h"
+
+#define __CLASS__ "SdmDisplayBufferAllocator"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+namespace sdm {
+
+SdmDisplayBufferAllocator::SdmDisplayBufferAllocator(bool use_pixman) {
+    int drm_fd = get_drm_master_fd();
+
+    gbm_ = gbm_create_device(drm_fd);
+    int gpu_fd = open("/dev/kgsl-3d0", O_RDWR);
+    if (gpu_fd < 0) {
+      is_gpu_available_ = false;
+    }
+    if (gpu_fd >= 0) {
+      close(gpu_fd);
+      gpu_fd = -1;
+    }
+
+    is_pixman_available_ = use_pixman;
+}
+
+LayerBufferFormat GetLayerBufferFormat(uint32_t format, uint32_t ubwc_status) {
+   LayerBufferFormat layer_buffer_format = kFormatInvalid;
+
+   switch (format) {
+       case GBM_FORMAT_ABGR8888:
+          layer_buffer_format = ubwc_status ? kFormatRGBA8888Ubwc: kFormatRGBA8888;
+          break;
+       case GBM_FORMAT_XBGR8888:
+          layer_buffer_format = ubwc_status ? kFormatRGBX8888Ubwc: kFormatRGBX8888;
+          break;
+       case GBM_FORMAT_BGR888:
+          layer_buffer_format = kFormatRGB888;
+          break;
+       case GBM_FORMAT_BGR565:
+          layer_buffer_format = kFormatRGB565;
+          break;
+       case GBM_FORMAT_RGB565:
+          layer_buffer_format = ubwc_status ? kFormatBGR565Ubwc: kFormatBGR565;
+          break;
+       case GBM_FORMAT_ARGB8888:
+          layer_buffer_format = kFormatBGRA8888;
+          break;
+       case GBM_FORMAT_XRGB8888:
+          layer_buffer_format = kFormatBGRX8888;
+          break;
+       case GBM_FORMAT_NV12:
+          layer_buffer_format =
+            ubwc_status ? kFormatYCbCr420SPVenusUbwc: kFormatYCbCr420SemiPlanarVenus;
+          break;
+       case GBM_FORMAT_YCbCr_420_TP10_UBWC:
+          layer_buffer_format = kFormatYCbCr420TP10Ubwc;
+          break;
+       case GBM_FORMAT_P010:
+          layer_buffer_format = kFormatYCbCr420P010;
+          break;
+       case GBM_FORMAT_YCbCr_420_P010_UBWC:
+          layer_buffer_format = kFormatYCbCr420P010Ubwc;
+          break;
+       case GBM_FORMAT_ABGR2101010:
+         layer_buffer_format = ubwc_status ? kFormatRGBA1010102Ubwc: kFormatRGBA1010102;
+         break;
+       default:
+         layer_buffer_format = kFormatInvalid;
+         break;
+   }
+
+   return layer_buffer_format;
+}
+
+int SdmDisplayBufferAllocator::AllocateBuffer(BufferInfo *buffer_info) {
+  const BufferConfig &buffer_config = buffer_info->buffer_config;
+  AllocatedBufferInfo *alloc_buffer_info = &buffer_info->alloc_buffer_info;
+  uint32_t width = buffer_config.width;
+  uint32_t height = buffer_config.height;
+  uint32_t format;
+  int metadata_fd = -1;
+  uint64_t alloc_flags = 0;
+  uint32_t ubwc_status;
+  int error = SetBufferInfo(buffer_config.format, &format, &alloc_flags);
+  if (error != 0) {
+    return kErrorParameters;
+  }
+
+  if (buffer_info->buffer_config.secure) {
+     alloc_flags |= GBM_BO_USAGE_PROTECTED_QTI;
+  }
+  // CreateBuffer
+  struct gbm_bo *bo = gbm_bo_create(gbm_, width, height, format, alloc_flags);
+
+  if (bo) {
+      alloc_buffer_info->fd = gbm_bo_get_fd(bo);
+      alloc_buffer_info->stride = gbm_bo_get_stride(bo);
+      uint32_t alignedWidth = 0;
+      gbm_perform(GBM_PERFORM_GET_BO_ALIGNED_WIDTH, bo, &alignedWidth);
+      alloc_buffer_info->aligned_width = alignedWidth;
+      uint32_t alignedHeight = 0;
+      gbm_perform(GBM_PERFORM_GET_BO_ALIGNED_HEIGHT, bo, &alignedHeight);
+      alloc_buffer_info->aligned_height = alignedHeight;
+      size_t bo_size = 0;
+      gbm_perform(GBM_PERFORM_GET_BO_SIZE, bo, &bo_size);
+      gbm_perform(GBM_PERFORM_GET_UBWC_STATUS, bo, &ubwc_status);
+      alloc_buffer_info->size = (uint32_t)bo_size;
+      alloc_buffer_info->format = GetLayerBufferFormat(gbm_bo_get_format(bo), ubwc_status);
+
+      gbm_perform(GBM_PERFORM_GET_METADATA_ION_FD, bo, &metadata_fd);
+
+  } else {
+      DLOGE("Failed to allocate memory");
+
+      return kErrorMemory;
+  }
+
+  buffer_info->private_data = reinterpret_cast<void *>(bo);
+
+  return kErrorNone;
+}
+
+int SdmDisplayBufferAllocator::DumpBuffer(void* bo) {
+  int result = gbm_perform(GBM_PERFORM_DUMP_BO_CONTENT, reinterpret_cast<struct gbm_bo *>(bo));
+  if (result != 0) {
+    DLOGE("Failed to dump buffer");
+    return result;
+  }
+
+  return 0;
+}
+
+int SdmDisplayBufferAllocator::FreeBuffer(BufferInfo *buffer_info) {
+  int err = kErrorNone;
+  struct gbm_bo *bo = reinterpret_cast<struct gbm_bo *>(buffer_info->private_data);
+  if (bo)
+      gbm_bo_destroy(bo);
+  else {
+      DLOGE("Unable to destroy bo = NULL.\n");
+      err = kErrorParameters;
+  }
+  buffer_info->private_data = NULL;
+  if (err == kErrorNone) {
+      AllocatedBufferInfo *alloc_buffer_info = &buffer_info->alloc_buffer_info;
+      alloc_buffer_info->fd = -1;
+      alloc_buffer_info->stride = 0;
+      alloc_buffer_info->size = 0;
+      alloc_buffer_info->aligned_height = 0;
+      alloc_buffer_info->aligned_width = 0;
+      alloc_buffer_info->format = kFormatInvalid;
+      buffer_info->private_data = NULL;
+      buffer_info->buffer_config = {};
+  }
+  return err;
+}
+
+uint32_t SdmDisplayBufferAllocator::GetBufferSize(BufferInfo *buffer_info) {
+
+  uint32_t size = 0;
+  const BufferConfig &bufferConfig = buffer_info->buffer_config;
+  uint64_t usageFlags = 0;
+  uint32_t gbmFormat = 0;
+  struct gbm_buf_info bufInfo;
+
+  if (SetBufferInfo(bufferConfig.format, &gbmFormat, &usageFlags) < 0) {
+     return 0;
+  }
+  if (bufferConfig.secure) {
+     usageFlags |= GBM_BO_USAGE_PROTECTED_QTI;
+  }
+  bufInfo.width = INT(bufferConfig.width);
+  bufInfo.height = INT(bufferConfig.height);
+  bufInfo.format = gbmFormat;
+
+  uint32_t alignedWidth = 0;
+  uint32_t alignedHeight = 0;
+
+  gbm_perform(GBM_PERFORM_GET_BUFFER_SIZE_DIMENSIONS, &bufInfo, usageFlags,
+              &alignedWidth, &alignedHeight, &size);
+
+  return size;
+}
+
+int SdmDisplayBufferAllocator::SetBufferInfo(LayerBufferFormat format, uint32_t *target, uint64_t *flags) {
+  switch (format) {
+  case kFormatRGBA8888:                 *target = GBM_FORMAT_ABGR8888;
+                                        break;
+  case kFormatRGBX8888:                 *target = GBM_FORMAT_XBGR8888;
+                                        break;
+  case kFormatRGB888:                   *target = GBM_FORMAT_BGR888;               break;
+  case kFormatRGB565:                   *target = GBM_FORMAT_BGR565;
+                                        break;
+  case kFormatBGR565:                   *target = GBM_FORMAT_RGB565;               break;
+  case kFormatBGRA8888:                 *target = GBM_FORMAT_ARGB8888;             break;
+  case kFormatBGRX8888:                 *target = GBM_FORMAT_XRGB8888;             break;
+  case kFormatYCbCr420SemiPlanarVenus:  *target = GBM_FORMAT_NV12;                 break;
+  case kFormatYCbCr420SPVenusUbwc:      *target = GBM_FORMAT_NV12;
+                                        *flags = GBM_BO_USAGE_UBWC_ALIGNED_QTI;
+                                        break;
+  case kFormatRGBA8888Ubwc:             *target = GBM_FORMAT_ABGR8888;
+                                        *flags = GBM_BO_USAGE_UBWC_ALIGNED_QTI |
+                                                 GBM_BO_USAGE_HW_RENDERING_QTI;
+                                        break;
+  case kFormatRGBX8888Ubwc:             *target = GBM_FORMAT_XBGR8888;
+                                        *flags = GBM_BO_USAGE_UBWC_ALIGNED_QTI |
+                                                 GBM_BO_USAGE_HW_RENDERING_QTI;
+                                        break;
+  case kFormatBGR565Ubwc:              *target = GBM_FORMAT_RGB565;
+                                        *flags = GBM_BO_USAGE_UBWC_ALIGNED_QTI |
+                                                 GBM_BO_USAGE_HW_RENDERING_QTI;
+                                        break;
+  case kFormatABGR2101010:              *target = GBM_FORMAT_ABGR2101010;
+                                        break;
+  case kFormatRGBA1010102:              *target = GBM_FORMAT_ABGR2101010;
+                                        break;
+  case kFormatRGBA1010102Ubwc:          *target = GBM_FORMAT_ABGR2101010;
+                                        *flags = GBM_BO_USAGE_UBWC_ALIGNED_QTI |
+                                                 GBM_BO_USAGE_HW_RENDERING_QTI;
+                                        break;
+  case kFormatYCbCr420TP10Ubwc:         *target = GBM_FORMAT_YCbCr_420_TP10_UBWC;  break;
+  case kFormatYCbCr420P010Ubwc:         *target = GBM_FORMAT_YCbCr_420_P010_UBWC;  break;
+  case kFormatYCbCr420P010:             *target = GBM_FORMAT_P010;  break;
+  default:
+    DLOGE("Unsupported format = 0x%x", format);
+    return -1;
+  }
+
+  return 0;
+}
+
+void SdmDisplayBufferAllocator::GetGbmDeviceHandle(void **userdata) {
+  *userdata = (void *) gbm_;
+}
+
+int SdmDisplayBufferAllocator::GetAllocatedBufferInfo(const BufferConfig \
+                                                      &buffer_config,
+                                                      AllocatedBufferInfo \
+                                                      *allocated_buffer_info) {
+  /* This API does not fill or provide stride to the caller in AllocatedBufferInfo structure */
+  uint64_t usageFlags = 0;
+  uint32_t gbmFormat = 0;
+  struct gbm_buf_info bufInfo;
+  uint32_t alignedWidth = 0;
+  uint32_t alignedHeight = 0;
+  uint32_t size = 0;
+
+  if (SetBufferInfo(buffer_config.format, &gbmFormat, &usageFlags) < 0) {
+     return kErrorParameters;
+  }
+  if (buffer_config.secure) {
+     usageFlags |= GBM_BO_USAGE_PROTECTED_QTI;
+  }
+  bufInfo.width = INT(buffer_config.width);
+  bufInfo.height = INT(buffer_config.height);
+  bufInfo.format = gbmFormat;
+
+  gbm_perform(GBM_PERFORM_GET_BUFFER_SIZE_DIMENSIONS, &bufInfo, usageFlags,
+              &alignedWidth, &alignedHeight, &size);
+  DLOGI("aligned_width:%d, aligned_height:%d, size:%d, gbm_format:0x%x usage_flags:0x%x",
+         alignedWidth, alignedHeight, size, gbmFormat, usageFlags);
+
+  allocated_buffer_info->aligned_width = alignedWidth;
+  allocated_buffer_info->aligned_height = alignedHeight;
+  allocated_buffer_info->size = size;
+  allocated_buffer_info->format = buffer_config.format;
+
+  return kErrorNone;
+}
+
+bool SdmDisplayBufferAllocator::IsFormatVideo(uint32_t fmt)
+{
+   bool is_video_present = false;
+
+   switch (fmt) {
+      case GBM_FORMAT_NV12:
+      case GBM_FORMAT_YCbCr_420_TP10_UBWC:
+      case GBM_FORMAT_P010:
+           is_video_present = true;
+           break;
+      default:
+           is_video_present = false;
+           break;
+   }
+
+   return is_video_present;
+}
+
+bool SdmDisplayBufferAllocator::IsVideoFormatLinear(uint32_t fmt, uint32_t ubwc_status)
+{
+   bool is_videofmt_linear = false;
+
+   if (!ubwc_status) {
+     switch (fmt) {
+      case GBM_FORMAT_NV12:
+      case GBM_FORMAT_P010:
+        is_videofmt_linear = true;
+        break;
+      default:
+        DLOGW("Unsupported format 0x%x\n", fmt);
+        is_videofmt_linear = false;
+        break;
+     }
+   }
+
+  return is_videofmt_linear;
+}
+
+bool SdmDisplayBufferAllocator::IsVideoFormatUBWC(uint32_t fmt, uint32_t ubwc_status)
+{
+   bool is_videofmt_ubwc = false;
+
+   if (ubwc_status) {
+     switch (fmt) {
+      case GBM_FORMAT_NV12:
+      case GBM_FORMAT_YCbCr_420_TP10_UBWC:
+        is_videofmt_ubwc = true;
+        break;
+      default:
+        DLOGW("Unsupported format 0x%x\n", fmt);
+        is_videofmt_ubwc = false;
+        break;
+     }
+   }
+
+  return is_videofmt_ubwc;
+}
+
+int SdmDisplayBufferAllocator::GetBufferLayout(const AllocatedBufferInfo &buf_info,
+                                                 uint32_t stride[4], uint32_t offset[4],
+                                                 uint32_t *num_planes) {
+    struct gbm_bo *bo;
+    struct gbm_import_fd_data import_fd_data;
+    uint32_t format1 = GBM_FORMAT_ARGB8888;
+    uint64_t flags = 0;
+    uint32_t ubwc_status = 0;
+    generic_buf_layout_t buf_layout;
+    uint32_t aligned_width = 0;
+
+    SetBufferInfo(buf_info.format, &format1, &flags);
+
+    import_fd_data.fd = buf_info.fd;
+    import_fd_data.format = format1;
+    import_fd_data.width = buf_info.aligned_width;
+    import_fd_data.height = buf_info.aligned_height;
+
+    // Import gbm bo from buf_info
+    bo = gbm_bo_import(gbm_, GBM_BO_IMPORT_FD, &import_fd_data, flags);
+
+    if (bo == NULL) {
+        return kErrorNone;
+    }
+
+    uint32_t height = gbm_bo_get_height(bo);
+    uint32_t format = gbm_bo_get_format(bo);
+    uint32_t bpp = gbm_bo_get_bpp(bo);
+
+    if (IsFormatVideo(format) == false) {
+      /* Importing bo from mesa-gbm requires stride value to be passed as part of
+      gbm_import_fd_data structure. Our gbm implementation doesn't mandate this requirement.
+      As a result, we get 0 value from gbm_bo_get_stride call for mesa-gbm case. To handle this
+      scenario, we use a custom perform API patched on top of the mesa-gbm code to handle that.
+      */
+      if (!is_gpu_available_ && !is_pixman_available_) {
+          gbm_perform(GBM_PERFORM_GET_BO_ALIGNED_WIDTH, bo, &aligned_width);
+          stride[0] = ((bpp/8)*aligned_width);
+      } else {
+          stride[0] = gbm_bo_get_stride(bo);
+      }
+      offset[0] = 0;
+      *num_planes++;
+      gbm_bo_destroy(bo);
+      return kErrorNone;
+    }
+
+    if (format == GBM_FORMAT_NV12)
+      *num_planes = 2; // for NV12 format
+
+    gbm_perform(GBM_PERFORM_GET_PLANE_INFO, bo, &buf_layout);
+    gbm_perform(GBM_PERFORM_GET_UBWC_STATUS, bo, &ubwc_status);
+
+    if (IsVideoFormatLinear(format, ubwc_status)) {
+      stride[0] = buf_layout.planes[0].v_increment;
+      offset[0] = 0;
+
+      stride[1] = stride[0];
+      offset[1] = stride[0]*height;
+    }
+    if (IsVideoFormatUBWC(format, ubwc_status)) {
+      stride[0] = buf_layout.planes[0].v_increment;
+      stride[1] = buf_layout.planes[1].v_increment;
+      offset[0] = 0;
+      offset[1] = 0;
+    }
+
+  gbm_bo_destroy(bo);
+
+  return kErrorNone;
+}
+
+}  // namespace sdm
+#ifdef __cplusplus
+}
+#endif
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_buffer_allocator.h b/libweston/backend-sdm/sdm-service/sdm_display_buffer_allocator.h
new file mode 100644
index 0000000..51726ad
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_buffer_allocator.h
@@ -0,0 +1,78 @@
+/*
+* Copyright (c) 2017, 2021 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+*
+* Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#ifndef __SDM_DISPLAY_BUFFER_ALLOCATOR_H__
+#define __SDM_DISPLAY_BUFFER_ALLOCATOR_H__
+
+#include <core/buffer_allocator.h>
+#include <gbm.h>
+#include <gbm_priv.h>
+#include "sdm-service/sdm_display_connect.h"
+#include <core/layer_stack.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+namespace sdm {
+
+template <class Type>
+inline Type ALIGN(Type x, Type align) {
+  return (x + align - 1) & ~(align - 1);
+}
+class SdmDisplayBufferAllocator : public BufferAllocator {
+ public:
+  SdmDisplayBufferAllocator(bool use_pixman);
+  ~SdmDisplayBufferAllocator() {
+    gbm_device_destroy(gbm_);
+    gbm_ = NULL;
+  };
+
+  int AllocateBuffer(BufferInfo *buffer_info);
+  int FreeBuffer(BufferInfo *buffer_info);
+  uint32_t GetBufferSize(BufferInfo *buffer_info);
+
+  int GetAllocatedBufferInfo(const BufferConfig &buffer_config,
+                             AllocatedBufferInfo *allocated_buffer_info);
+  int SetBufferInfo(LayerBufferFormat format, uint32_t *target, uint64_t *flags);
+  int GetBufferLayout(const AllocatedBufferInfo &buf_info,
+                      uint32_t stride[4], uint32_t offset[4],
+                      uint32_t *num_planes);
+  void GetGbmDeviceHandle(void **userdata);
+  int DumpBuffer(void* bo);
+ private:
+  bool IsFormatVideo(uint32_t fmt);
+  bool IsVideoFormatLinear(uint32_t fmt, uint32_t ubwc_status);
+  bool IsVideoFormatUBWC(uint32_t fmt, uint32_t ubwc_status);
+  struct gbm_device *gbm_ = NULL;
+  bool is_gpu_available_ = true;
+  bool is_pixman_available_ = false;
+};
+
+}  // namespace sdm
+#endif  // __SDM_DISPLAY_BUFFER_ALLOCATOR_H__
+
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_buffer_sync_handler.cpp b/libweston/backend-sdm/sdm-service/sdm_display_buffer_sync_handler.cpp
new file mode 100644
index 0000000..495b9e9
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_buffer_sync_handler.cpp
@@ -0,0 +1,86 @@
+/*
+* Copyright (c) 2017, 2021 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ *
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#include "sdm-service/sdm_display_debugger.h"
+#include "sdm-service/sdm_display_buffer_sync_handler.h"
+#include "utils/fence.h"
+#include "libsync.h"
+
+#define __CLASS__ "SdmDisplayBufferSyncHandler"
+
+namespace sdm {
+
+SdmDisplayBufferSyncHandler::SdmDisplayBufferSyncHandler() {
+  Fence::Set(this);
+  DLOGW("SdmDisplayBufferSyncHandler: set class point to fence");
+}
+
+int SdmDisplayBufferSyncHandler::SyncMerge(int fd1,
+                                           int fd2,
+                                           int *merged_fd) {
+  DLOGI("SdmDisplayBufferSyncHandler::SyncMerge");
+  // Caller owns fds, hence, if
+  //  one of the fence fd is invalid, create dup of valid fd and set to merged fd.
+  //  both fence fds are same, create dup of one of the fd and set to merged fd.
+  *merged_fd = -1;
+  if (fd1 < 0) {
+    *merged_fd = dup(fd2);
+  } else if ((fd2 < 0) || (fd1 == fd2)) {
+    *merged_fd = dup(fd1);
+  } else {
+    *merged_fd = sync_merge("SyncMerge", fd1, fd2);
+  }
+
+  return kErrorNone;
+}
+
+int SdmDisplayBufferSyncHandler::SyncWait(int fd, int timeout)
+{
+  DLOGI("SdmDisplayBufferSyncHandler::SyncWait, fd = %d, timeout = %d", fd, timeout);
+  // Assume invalid fd as signaled.
+  if (fd < 0) {
+    return 0;
+  }
+
+  int error = 0;
+  if ((error = sync_wait(fd, timeout)) != 0) {
+    if (errno == ETIME) {
+      error = -ETIME;
+    }
+    if (timeout != 0) {
+      DLOGW("sync_wait fd = %d, timeout = %d ms, err = %d : %s", fd, timeout, errno,
+            strerror(errno));
+    }
+    return error;
+  }
+
+  return kErrorNone;
+}
+
+}  // namespace sdm
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_buffer_sync_handler.h b/libweston/backend-sdm/sdm-service/sdm_display_buffer_sync_handler.h
new file mode 100644
index 0000000..afa69cc
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_buffer_sync_handler.h
@@ -0,0 +1,49 @@
+/*
+* Copyright (c) 2017, 2021 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+*
+* Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#ifndef __SDM_DISPLAY_BUFFER_SYNC_HANDLER_H__
+#define __SDM_DISPLAY_BUFFER_SYNC_HANDLER_H__
+#include <sstream>
+#include <core/buffer_sync_handler.h>
+
+namespace sdm {
+
+class SdmDisplayBufferSyncHandler : public BufferSyncHandler {
+ public:
+  SdmDisplayBufferSyncHandler();
+
+  int SyncWait(int fd, int timeout);
+  int SyncMerge(int fd1, int fd2, int *merged_fd);
+  void GetSyncInfo(int fd, std::ostringstream *os) {
+    return;
+  }
+};
+
+}  // namespace sdm
+#endif  // __SDM_DISPLAY_BUFFER_SYNC_HANDLER_H__
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_connect.cpp b/libweston/backend-sdm/sdm-service/sdm_display_connect.cpp
new file mode 100644
index 0000000..f55375c
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_connect.cpp
@@ -0,0 +1,592 @@
+/*
+* Copyright (c) 2017,2020-2021 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+* Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#include <display_properties.h>
+#include <properties.h>
+
+#include "sdm-service/sdm_display.h"
+#include "sdm-service/sdm_display_connect.h"
+#include "sdm-service/uevent.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __CLASS__ "SdmDisplayConnect"
+namespace sdm {
+
+#define SDM_DISPLAY_DEBUG 0
+
+enum {
+       FAIL,
+       SUCCESS
+};
+
+CoreInterface *core_intf_ = NULL;
+SdmDisplayBufferAllocator *buffer_allocator_;
+SdmDisplayBufferSyncHandler buffer_sync_handler_;
+SdmDisplaySocketHandler socket_handler_;
+HWDisplayInterfaceInfo hw_disp_info_;
+
+CreatedDisplaysInfo displays_;
+
+HWDisplaysInfo hw_displays_info_ = {};
+// ordered by output id
+SdmDisplaysInfo sdm_displays_info_ = {};
+
+SdmDisplayProxy *GetDisplayFromId(uint32_t display_id) {
+    auto it = displays_.find(display_id);
+    if (it == displays_.end()) {
+        DLOGE("No display available with display_id: %d.", display_id);
+        return NULL;
+    }
+    return it->second;
+}
+
+bool IsDisplayCreated(uint32_t display_id) {
+    return displays_.find(display_id) != displays_.end();
+}
+
+int GetConnectedDisplaysIds(int num_displays, uint32_t *connector_ids) {
+    if (!connector_ids) {
+        return -1;
+    }
+    SdmDisplaysInfo::iterator iter = sdm_displays_info_.begin();
+    int idx = 0;
+
+    if (num_displays != sdm_displays_info_.size()) {
+        DLOGE("Connected display sizes doesn't match.");
+        return -1;
+    }
+
+    for (iter; iter != sdm_displays_info_.end(); ++iter) {
+        connector_ids[idx++] = iter->first;
+    }
+
+    return 0;
+}
+
+static DisplayError
+SetProperty(const char *property_name, const char *value)
+{
+  if (property_set(property_name, value) == 0) {
+    return kErrorNone;
+  }
+  return kErrorNotSupported;
+}
+
+int CreateCore(bool use_pixman)
+{
+    DisplayError error = kErrorNone;
+    if (core_intf_) {
+        DLOGW("Core was already created.");
+        return kErrorNone;
+    }
+    buffer_allocator_ = new SdmDisplayBufferAllocator(use_pixman);
+
+    // TODO: Check the requirement for this property
+    std::shared_ptr<IPCIntf> ipc_intf = nullptr;
+
+    error = CoreInterface::CreateCore(buffer_allocator_,
+                                      &buffer_sync_handler_,
+                                      &socket_handler_,
+                                      ipc_intf,
+                                      &core_intf_);
+    if (!core_intf_) {
+        DLOGE("function failed. Error = %d", error);
+        return error;
+    }
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("successfully created.");
+    #endif
+
+    return kErrorNone;
+}
+
+int DestroyCore()
+{
+    DisplayError error = kErrorNone;
+
+    if (!core_intf_) {
+        DLOGE("Core was already destroyed => core_intf_ = NULL");
+        return kErrorNone;
+    }
+
+    auto it = displays_.begin();
+    for (it; it != displays_.end(); ++it) {
+        uint32_t connector_id = it->first;
+        delete displays_[connector_id];
+        displays_[connector_id] = NULL;
+        displays_.erase(connector_id);
+    }
+
+    error = CoreInterface::DestroyCore();
+    if (error != kErrorNone) {
+        DLOGE("function failed. Error = %d", error);
+        return error;
+    }
+    core_intf_ = NULL;
+    delete buffer_allocator_;
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("Core was destroyed successfully");
+    #endif
+
+    return kErrorNone;
+}
+
+int GetFirstDisplayType(int *display_id)
+{
+    DisplayError error = kErrorNone;
+
+    *display_id = -1; /* Initialize with invalid display type */
+    if (!core_intf_) {
+        DLOGE("function failed as core was not created.");
+        return kErrorNotSupported;
+    }
+
+    error = core_intf_->GetFirstDisplayInterfaceType(&hw_disp_info_);
+    if (error != kErrorNone) {
+        DLOGE("function GetFirstDisplayInterfaceType failed: error = %d",
+              error);
+        return error;
+    }
+    *display_id = hw_disp_info_.type;
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("function successful: display id = %d", *display_id);
+    #endif
+
+    return kErrorNone;
+}
+
+int CreateDisplay(uint32_t display_id)
+{
+    DisplayError error = kErrorNone;
+    HWDisplayInfo hw_display_info;
+
+    if (IsDisplayCreated(display_id)) {
+        DLOGE("Display(%d) was already created.", display_id);
+        return kErrorNone;
+    }
+
+    auto it = hw_displays_info_.find(display_id);
+    if (it == hw_displays_info_.end()) {
+        DLOGE("No display information available for display_id: %d.", display_id);
+        return kErrorParameters;
+    }
+    hw_display_info = it->second;
+
+    if (core_intf_ == NULL) {
+        DLOGE("Core is not created yet.");
+        return kErrorNotSupported;
+    }
+
+    SetProperty(DISABLE_SINGLE_LM_SPLIT_PROP, "1");
+
+    enum DisplayType display_type = hw_display_info.display_type;
+
+    SdmDisplayProxy *sdm_display = new SdmDisplayProxy(display_type, core_intf_, buffer_allocator_);
+
+    displays_[display_id] = sdm_display;
+    error = displays_[display_id]->CreateDisplay(display_id) ;
+    if (error != kErrorNone) {
+        DLOGE("Failed to create display(%d)", display_id);
+        delete displays_[display_id];
+        displays_[display_id] = NULL;
+        displays_.erase(display_id);
+        return error;
+    }
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("Display(%d) created successfully.", display_id);
+    #endif
+
+    return kErrorNone;
+}
+
+int Prepare(uint32_t display_id, struct drm_output *output)
+{
+    DisplayError error = kErrorNone;
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+
+    error = dpy->Prepare(output);
+    if (error != kErrorNone) {
+        DLOGE("function failed with error = %d", error);
+        return error;
+    }
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("function successful.");
+    #endif
+
+    return kErrorNone;
+}
+
+int Commit(uint32_t display_id, struct drm_output *output)
+{
+    DisplayError error = kErrorNone;
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+
+    error = dpy->Commit(output);
+    if (error != kErrorNone) {
+        DLOGE("function failed with error = %d", error);
+        return error;
+    }
+
+    DLOGV("function successful.");
+
+    return kErrorNone;
+}
+
+int DestroyDisplay(uint32_t display_id)
+{
+    DisplayError error = kErrorNone;
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+
+    error = dpy->DestroyDisplay();
+    if (error != kErrorNone) {
+        DLOGE("function failed with error = %d", error);
+        return error;
+    }
+
+    delete displays_[display_id];
+    displays_[display_id] = NULL;
+    displays_.erase(display_id);
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("function successful.");
+    #endif
+
+    return kErrorNone;
+}
+
+bool GetDisplayConfiguration(uint32_t display_id, struct DisplayConfigInfo *display_config)
+{
+    DisplayError error = kErrorNone;
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+
+    error = dpy->GetDisplayConfiguration(display_config);
+
+    if (error != kErrorNone) {
+        DLOGE("function failed with error = %d", error);
+        return FAIL;
+    }
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("function successful.");
+    #endif
+
+    return SUCCESS;
+}
+
+bool GetDisplayHdrInfo(uint32_t display_id, struct DisplayHdrInfo *display_hdr_info)
+{
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("function successful.");
+    #endif
+
+    return SUCCESS;
+}
+
+int RegisterCbs(uint32_t display_id, sdm_cbs *cbs) {
+    DisplayError error = kErrorNone;
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+
+    error = dpy->RegisterCbs(display_id, cbs);
+
+    if (error != kErrorNone) {
+        DLOGE("function failed with error = %d", error);
+        return error;
+    }
+
+    return kErrorNone;
+}
+
+int get_drm_master_fd(void) {
+
+    int fd = SdmDisplayInterface::GetDrmMasterFd();
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("fd is: %d \n", fd);
+    #endif
+
+    return fd;
+}
+
+
+void set_drm_master_fd(int fd) {
+
+    SdmDisplayInterface::SetDrmMasterFd(fd);
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("master fd is: %d \n", fd);
+    #endif
+}
+
+int SetDisplayState(uint32_t display_id, int power_mode) {
+    DisplayError error = kErrorNone;
+    bool teardown;
+    shared_ptr<Fence> release_fence;
+    sdm::DisplayState disp_state;
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+
+    if (power_mode == WESTON_DPMS_ON) {
+        teardown = false;
+        disp_state = kStateOn;
+    } else {
+        teardown = true;
+        disp_state = kStateOff;
+    }
+    /* When WESTON_DPMS_ON == 0, set state ON (kStateOn)     */
+    /* for all other power modes, i.e. WESTON_DPMS_STANDBY,  */
+    /* WESTON_DPMS_SUSPEND, WESTON_DPMS_OFF turn off display */
+    /* set state off (kStateOff)                             */
+    error = dpy->SetDisplayState(disp_state, teardown,
+                                                  &release_fence);
+    if (error != kErrorNone) {
+        DLOGE("function failed with error = %d", error);
+        return error;
+    }
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("function successful.");
+    #endif
+
+    return kErrorNone;
+}
+
+int SetVSyncState(uint32_t display_id, bool state, struct drm_output *output)
+{
+    DisplayError error = kErrorNone;
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+
+    error = dpy->SetVSyncState(state, output);
+    if (error != kErrorNone) {
+        DLOGE("function failed with error = %d", error);
+        return error;
+    }
+
+    #if SDM_DISPLAY_DEBUG
+    DLOGD("function successful.");
+    #endif
+
+    return kErrorNone;
+}
+
+int SetPanelBrightness(int display_id, float brightness)
+{
+    DisplayError error = kErrorNone;
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+
+    return dpy->SetPanelBrightness(brightness);
+}
+
+int GetPanelBrightness(int display_id, float *brightness)
+{
+    DisplayError error = kErrorNone;
+    SdmDisplayProxy *dpy = GetDisplayFromId(display_id);
+    if (!dpy) {
+        DLOGE("Failed as Display (%d) not created yet.", display_id);
+        return kErrorNotSupported;
+    }
+    return dpy->GetPanelBrightness(brightness);
+}
+
+uint32_t GetDisplayCount(void) {
+  uint32_t count = 0;
+
+  count = sdm_displays_info_.size();
+
+  return count;
+}
+
+
+void HandlePrimaryDisplayInfo() {
+  HWDisplaysInfo::iterator iter = hw_displays_info_.begin();
+  sdm_displays_info_.clear();
+
+  for (iter; iter != hw_displays_info_.end(); ++iter) {
+    if (!iter->second.is_primary)
+      continue;
+    if (iter->second.display_type == sdm::kVirtual)
+      continue;
+    if (!iter->second.is_connected)
+      continue;
+
+    // only one primary display
+    sdm_displays_info_[iter->first] = iter->second;
+    break;
+  }
+}
+
+void HandleExternalDisplayInfos() {
+  HWDisplaysInfo::iterator iter = hw_displays_info_.begin();
+
+  for (iter; iter != hw_displays_info_.end(); ++iter) {
+    if (iter->second.is_primary)
+      continue;
+
+    if (iter->second.display_type == sdm::kVirtual)
+      continue;
+
+    if (!iter->second.is_connected)
+      continue;
+
+    sdm_displays_info_[iter->first] = iter->second;
+  }
+}
+
+int GetDisplayInfos(void) {
+  DisplayError error = kErrorNone;
+
+  error = core_intf_->GetDisplaysStatus(&hw_displays_info_);
+  if (error != kErrorNone) {
+    DLOGE("function GetDisplaysStatus failed. Error = %d", error);
+    return error;
+  }
+
+  // Only create non-virtual display first
+  /* primary display*/
+  HandlePrimaryDisplayInfo();
+  /* pluggable display*/
+  HandleExternalDisplayInfos();
+  return 0;
+}
+
+char *GetConnectorName(uint32_t display_id) {
+  char name[100]={};
+  const char *type_name = NULL;
+  auto iter = sdm_displays_info_.find(display_id);
+
+  switch(iter->second.display_type) {
+    case kBuiltIn:
+      if (iter->second.is_primary) {
+        type_name = "DSI-1";
+      } else {
+        type_name = "DSI-2";
+      }
+      break;
+    case kPluggable:
+      type_name = "DP";
+      break;
+    default:
+      type_name = "unKnown";
+      break;
+  }
+
+  snprintf(name, sizeof name, "%s-%d", type_name, display_id);
+
+  return strdup(name);
+}
+
+uint32_t GetConnectorId(uint32_t display_id) {
+  auto iter = sdm_displays_info_.find(display_id);
+  if (iter == sdm_displays_info_.end()) {
+    return -1;
+  }
+  return iter->second.display_id;
+}
+
+static HWDisplayInfo GetSdmDisplayInfo(int display_id) {
+  auto iter = sdm_displays_info_.find(display_id);
+
+  return iter->second;
+}
+
+int GetDisplayType(uint32_t display_id) {
+
+  auto it = hw_displays_info_.find(display_id);
+  if (it == hw_displays_info_.end()) {
+    DLOGE("No display information available for display_id: %d.", display_id);
+    return -1;
+  }
+
+  return (it->second.display_type);
+}
+
+void ClearSDMLayers(struct drm_output *output) {
+  struct sdm_layer *sdm_layer, *tmp_layer;
+  wl_list_for_each_safe(sdm_layer, tmp_layer, &output->prev_sdm_layer_list, link) {
+    shared_ptr<Fence> release_fence = Fence::Create(INT(sdm_layer->release_fence_fd), "release");
+    if (!Fence::Wait(release_fence)) {
+      destroy_sdm_layer(sdm_layer);
+    }
+  }
+
+  wl_list_init(&output->prev_sdm_layer_list);
+  wl_list_for_each_safe(sdm_layer, tmp_layer, &output->sdm_layer_list, link) {
+    wl_list_insert(output->prev_sdm_layer_list.prev, &sdm_layer->link);
+  }
+
+  wl_list_init(&output->sdm_layer_list);
+}
+
+}// namespace sdm
+#ifdef __cplusplus
+}
+#endif
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_connect.h b/libweston/backend-sdm/sdm-service/sdm_display_connect.h
new file mode 100644
index 0000000..a12298d
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_connect.h
@@ -0,0 +1,278 @@
+/*
+* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+* Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*
+*/
+
+#ifndef SDM_DISPLAY_CONNECT_H
+#define SDM_DISPLAY_CONNECT_H
+
+#include "sdm-service/sdm_display_interface.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*! @brief Method to create and internally store the handle to display core interface.
+
+    @details This method is the entry point into the display core. Client can create
+    and operate on different display devices only after valid interface handle is
+    internally stored after invoking this method. Successfully obtaining valid interface
+    handle and storing internally is indicated by return code kErrorNone. An object of
+    display core is created and handle to this object returned internally by the display
+    core interface via output parameter is internally stored. This interface shall be
+    called only once. Parameters used in this method internally and not exposed to Client
+    are noted below for information purposes only.
+
+    @param[in] use_pixman \link bool \endlink
+    @return \link DisplayError \endlink
+
+    @sa DestroyCore
+*/
+int CreateCore(bool use_pixman);
+
+/*! @brief Method to release internally stored handle to display core interface.
+
+    @details The object of corresponding display core is destroyed when this method is
+    invoked and internally stored handle is released. Client must explicitly destroy
+    all created display device objects associated with this handle before invoking this
+    method even though this method makes a modest effort to destroy all existing and
+    created display device objects.
+
+    @param[in] interface (internally used by this method) \link CoreInterface \endlink
+
+    @return \link DisplayError \endlink
+
+    @sa CreateCore
+*/
+int DestroyCore();
+
+/*! @brief Method to get characteristics of the first display.
+
+    @details Client shall use this method to determine type of the first display.
+
+    @param[in] display_id that this method will fill up with info.
+
+    @return \link DisplayError \endlink
+
+*/
+int GetFirstDisplayType(int *display_id);
+
+/*! @brief Method to create a display device for a given display id.
+
+    @details Client shall use this method to create each of the display id.
+    display_id must be valid to create display.
+
+    @param[in] display_id \link int \endlink
+    @return \link DisplayError \endlink
+
+    @sa DestroyDisplay
+*/
+int CreateDisplay(uint32_t display_id);
+
+/*! @brief Method to destroy a display device.
+
+    @details Client shall use this method to destroy each of the created
+    display device objects.
+
+    @param[in] display_id \link int \endlink
+
+    @return \link DisplayError \endlink
+
+    @sa CreateDisplay
+*/
+int DestroyDisplay(uint32_t display_id);
+
+/*! @brief Method to create a display device for a given display id even if
+    display was already created. This method forces the display to be re-created
+    after destroying the one which was previously created, if so.
+
+    @details Client shall use this method to force create each of the display id.
+    display_id must be valid to create display.
+
+    @param[in] display_id \link int \endlink
+    @return \link DisplayError \endlink
+
+    @sa DestroyDisplay
+*/
+int ReconfigureDisplay(uint32_t display_id);
+
+/*! @brief Method to compose layers associated with given frame.
+
+    @details Client shall send all layers associated with a frame
+    targeted for current display using this method and check the layers
+    which can be handled completely in display manager.
+
+    This method can be called multiple times but only last call prevails. This method must be
+    followed by Commit().
+
+    @param[in] display_id \link int \endlink
+    @param[in] drm_output \link struct drm_output \endlink
+
+    @return \link DisplayError \endlink
+
+    @sa Commit
+*/
+int Prepare(uint32_t display_id, struct drm_output *output);
+
+/*! @brief Method to commit layers of a frame submitted in a former call to Prepare().
+
+    @details Client shall call this method to submit layers for final composition.
+    The composed output shall be displayed on the panel or written in output buffer.
+
+    This method shall be called only once for each frame.
+
+    In the event of an error as well, this call will cause any fences returned in the
+    previous call to Commit() to eventually become signaled, so the client's wait on
+    fences can be released to prevent deadlocks.
+
+    @param[in] display_id \link int \endlink
+    @param[inout] drm_output \link struct drm_output \endlink
+
+    @return \link DisplayError \endlink
+
+    @sa Prepare
+*/
+int Commit(uint32_t display_id, struct drm_output *output);
+
+/*! @brief Method to obtain display property for a display_id requested.
+    @details Client shall use this method to display properties of requested
+    display id.
+
+    @param[in] display_id \link int \endlink
+    @param[in] display_config \link struct DisplayConfigInfo \endlink
+
+    @return \link DisplayError \endlink
+
+    @sa
+*/
+bool GetDisplayConfiguration(uint32_t display_id, struct DisplayConfigInfo *display_config);
+
+/*! @brief Method to register callbacks: VBlank Handler function to be called on
+    enabling VBlank (VSync), and hotplug handler function to be called on hotplug
+    uevent. SDM shall trigger a call back through this interface function.
+
+    @param[in] display_id \link int \endlink
+    @param[in] cbs \link sdm_cbs_t \endlink
+
+    @return \link DisplayError \endlink
+
+    @sa
+*/
+int RegisterCbs(uint32_t display_id, sdm_cbs_t *cbs);
+
+/*! @brief Method to turn on power of display
+
+    @details Client shall use this method to turn on display. DisplayError
+    must have been created previously.
+    to be called by hardware composer.
+
+    @param[in] display_id \link int \endlink
+    @param[in] power_mode \link int \endlink
+
+    @return \link int \endlink
+
+    @sa
+*/
+bool SetDisplayState(uint32_t display_id, int power_mode);
+
+/*! @brief Method to enable VSync State, i.e. whether to generate callback
+    on next frame.
+
+    @details Client shall use this method for enable VSync (VBlank) callback.
+
+    @param[in] display_id \link int \endlink
+    @param[in] enable \link bool \endlink
+    @param[in] b \link (struct drm_backend *) \endlink
+
+    @return \link int \endlink
+
+    @sa
+*/
+int SetVSyncState(uint32_t display_id, bool enable, struct drm_output *output);
+
+/*! @brief Method to set panel brightness..
+
+    @details Client shall use this method to set panel brightness.
+
+    @param[in] display_id \link int \endlink
+    @param[in] brightness \link float \endlink
+
+    @return \link int \endlink
+
+    @sa
+*/
+int SetPanelBrightness(int display_id, float brightness);
+
+/*! @brief Method to get panel brightness
+
+    @details Client shall use this method to get panel brightness.
+
+    @param[in] display_id \link int \endlink
+    @param[in] enable \link bool \endlink
+
+    @return \link int \endlink
+
+    @sa
+*/
+int GetPanelBrightness(int display_id, float *brightness);
+
+/*! @brief Method for obtaining master fd.
+
+    @details client to obtaining master fd.
+
+    @return \link int \endlink
+
+    @sa
+*/
+int get_drm_master_fd(void);
+
+
+/*! @brief Method for setting master fd.
+
+    @details client to set master fd.
+
+    @return \link int \endlink
+
+    @sa
+*/
+void set_drm_master_fd(int fd);
+
+uint32_t GetDisplayCount(void);
+
+int GetDisplayInfos(void);
+
+char* GetConnectorName(uint32_t display_id);
+
+uint32_t GetConnectorId(uint32_t display_id);
+
+void ClearSDMLayers(struct drm_output *output);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // SDM_DISPLAY_CONNECT_H
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_debugger.cpp b/libweston/backend-sdm/sdm-service/sdm_display_debugger.cpp
new file mode 100644
index 0000000..0000820
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_debugger.cpp
@@ -0,0 +1,285 @@
+/*
+* Copyright (c) 2017,2021 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+*
+* Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <display_properties.h>
+#include <properties.h>
+
+extern "C" {
+#include <libweston/libweston.h>
+#include "weston-log-internal.h"
+};
+
+#include "sdm-service/sdm_display_debugger.h"
+
+#define __CLASS__ "SdmDisplayDebugger"
+#define PATH_MAX 256
+#define DISPLAY_TRACE_DEBUG_PROP "persist.display.trace.debug"
+
+using std::string;
+
+namespace sdm {
+
+SdmDisplayDebugger SdmDisplayDebugger::debug_handler_;
+
+void SdmDisplayDebugger::DebugAll(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_ = 0x7FFFFFFF;
+    if (verbose_level) {
+      // Enable verbose scalar logs only when explicitly enabled
+      debug_handler_.log_mask_[kTagScalar] = 0;
+    }
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_ = 0x1;   // kTagNone should always be printed.
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugResources(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagResources] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagResources] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugStrategy(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagStrategy] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagStrategy] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugCompManager(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagCompManager] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagCompManager] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugDriverConfig(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagDriverConfig] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagDriverConfig] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugRotator(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagRotator] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagRotator] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugScalar(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagScalar] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagScalar] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugQdcm(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagQDCM] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagQDCM] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugClient(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagClient] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagClient] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugDisplay(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagDisplay] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagDisplay] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+void SdmDisplayDebugger::DebugQos(bool enable, int verbose_level) {
+  if (enable) {
+    debug_handler_.log_mask_[kTagQOSClient] = 1;
+    debug_handler_.log_mask_[kTagQOSImpl] = 1;
+    debug_handler_.verbose_level_ = verbose_level;
+  } else {
+    debug_handler_.log_mask_[kTagQOSClient] = 0;
+    debug_handler_.log_mask_[kTagQOSImpl] = 0;
+    debug_handler_.verbose_level_ = 0;
+  }
+
+  DebugHandler::SetLogMask(debug_handler_.log_mask_);
+}
+
+static void Log(const char *prefix, const char *format, va_list list) {
+  weston_log_continue("\n%s", prefix);
+  weston_vlog(format, list);
+}
+
+void SdmDisplayDebugger::config_debug_level(void) {
+  FILE *fp = NULL;
+  //file to configure debug level
+  fp = fopen("/var/cache/display/sdm_dbg_cfg.txt", "r");
+  if (fp) {
+      fscanf(fp, "%d", &verbose_level_);
+      DebugAll(true /* enable */, verbose_level_);
+      printf("\n sdm debug level configured to %d\n", verbose_level_);
+      fclose(fp);
+  }
+}
+
+void SdmDisplayDebugger::config_trace_debug(void) {
+  if (GetProperty(DISPLAY_TRACE_DEBUG_PROP, &trace_debug_) == kErrorNone) {
+    printf("found trace prop, set sdm trace debug:%s\n", trace_debug_?"enable":"disable");
+  } else {
+    printf("trace prop not found, default is disable! -%d\n", trace_debug_);
+  }
+}
+
+void SdmDisplayDebugger::Error(const char *format, ...) {
+  if (verbose_level_ > NONE) {
+      va_list list;
+      va_start(list, format);
+      Log("SDM_E: ", format, list);
+      va_end(list);
+  }
+}
+
+void SdmDisplayDebugger::Warning(const char *format, ...) {
+  if (verbose_level_ > ERROR) {
+      va_list list;
+      va_start(list, format);
+      Log("SDM_W: ", format, list);
+      va_end(list);
+  }
+}
+
+void SdmDisplayDebugger::Info(const char *format, ...) {
+  if (verbose_level_ > WARNING) {
+      va_list list;
+      va_start(list, format);
+      Log("SDM_I: ", format, list);
+      va_end(list);
+  }
+}
+
+void SdmDisplayDebugger::Debug(const char *format, ...) {
+  if (verbose_level_ > INFO) {
+      va_list list;
+      va_start(list, format);
+      Log("SDM_D: ", format, list);
+      va_end(list);
+  }
+}
+
+void SdmDisplayDebugger::Verbose(const char *format, ...) {
+  if (verbose_level_ > DEBUG) {
+      va_list list;
+      va_start(list, format);
+      Log("SDM_V: ", format, list);
+      va_end(list);
+  }
+}
+
+int SdmDisplayDebugger::GetProperty(const char *property_name, int *value) {
+  char property[PROP_VALUE_MAX];
+
+  if (property_get(property_name, property, NULL) > 0) {
+    *value = atoi(property);
+    return kErrorNone;
+  }
+
+  return kErrorNotSupported;
+}
+
+int SdmDisplayDebugger::GetProperty(const char *property_name, char *value) {
+  if (property_get(property_name, value, NULL) > 0) {
+    return kErrorNone;
+  }
+
+  return kErrorNotSupported;
+}
+
+SdmDisplayDebugger::SdmDisplayDebugger() {
+  DebugHandler::Set(SdmDisplayDebugger::Get());
+  config_debug_level();
+  config_trace_debug();
+}
+
+}  // namespace sdm
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_debugger.h b/libweston/backend-sdm/sdm-service/sdm_display_debugger.h
new file mode 100644
index 0000000..456422f
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_debugger.h
@@ -0,0 +1,100 @@
+/*
+* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+*
+* Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#ifndef __SDM_DISPLAY_DEBUGGER_H__
+#define __SDM_DISPLAY_DEBUGGER_H__
+
+#include <core/sdm_types.h>
+#include <debug_handler.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include <bitset>
+#include <cstdlib>
+#include <cassert>
+#include <stdint.h>
+
+enum {
+       NONE,
+       ERROR,
+       WARNING,
+       INFO,
+       DEBUG,
+       VERBOSE,
+       SET_GET_PROP
+};
+
+namespace sdm {
+
+using display::DebugHandler;
+
+class SdmDisplayDebugger : public DebugHandler {
+ public:
+  SdmDisplayDebugger();
+  static inline DebugHandler* Get() { return &debug_handler_; }
+  static const char *DumpDir() { return "/data/misc/display"; }
+  void config_debug_level(void);
+  void config_trace_debug(void);
+
+  static void DebugAll(bool enable, int verbose_level);
+  static void DebugResources(bool enable, int verbose_level);
+  static void DebugStrategy(bool enable, int verbose_level);
+  static void DebugCompManager(bool enable, int verbose_level);
+  static void DebugDriverConfig(bool enable, int verbose_level);
+  static void DebugRotator(bool enable, int verbose_level);
+  static void DebugScalar(bool enable, int verbose_level);
+  static void DebugQdcm(bool enable, int verbose_level);
+  static void DebugClient(bool enable, int verbose_level);
+  static void DebugQos(bool enable, int verbose_level);
+  static void DebugDisplay(bool enable, int verbose_level);
+  static void DebugAllocator(bool enable, int verbose_level);
+  static int  GetIdleTimeoutMs();
+
+  // DebugHandler methods
+  virtual void Error(const char *format, ...);
+  virtual void Warning(const char *format, ...);
+  virtual void Info(const char *format, ...);
+  virtual void Debug(const char *format, ...);
+  virtual void Verbose(const char *format, ...);
+  virtual void BeginTrace(const char *class_name, const char *function_name,
+                          const char *custom_string) {}
+  virtual void EndTrace() {}
+  virtual int GetProperty(const char *property_name, int *value);
+  virtual int GetProperty(const char *property_name, char *value);
+
+ private:
+  static SdmDisplayDebugger debug_handler_;
+  std::bitset<32> log_mask_;
+  int verbose_level_ = ERROR;
+  int trace_debug_ = 0;
+};
+
+}  // namespace sdm
+
+#endif  // __SDM_DISPLAY_DEBUGGER_H__
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_interface.h b/libweston/backend-sdm/sdm-service/sdm_display_interface.h
new file mode 100644
index 0000000..208849a
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_interface.h
@@ -0,0 +1,241 @@
+/*
+* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+*
+* Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#ifndef SDM_DISPLAY_INTERFACE_H
+#define SDM_DISPLAY_INTERFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <color_metadata.h>
+
+#define MAX_SDE_Layers          16
+#define MAX_PIPE_WIDTH          2560
+#define MAX_MIXER_WIDTH         2560
+
+/* Buffer format enum */
+enum {
+       SDM_BUFFER_FORMAT_ARGB_8888,
+       SDM_BUFFER_FORMAT_ABGR_8888,
+       SDM_BUFFER_FORMAT_RGBA_8888,
+       SDM_BUFFER_FORMAT_BGRA_8888,
+       SDM_BUFFER_FORMAT_XRGB_8888,
+       SDM_BUFFER_FORMAT_XBGR_8888,
+       SDM_BUFFER_FORMAT_RGBX_8888,
+       SDM_BUFFER_FORMAT_BGRX_8888,
+       SDM_BUFFER_FORMAT_RGBA_5551,
+       SDM_BUFFER_FORMAT_RGBA_4444,
+       SDM_BUFFER_FORMAT_RGB_888,
+       SDM_BUFFER_FORMAT_BGR_888,
+       SDM_BUFFER_FORMAT_RGB_565,
+       SDM_BUFFER_FORMAT_BGR_565,
+       SDM_BUFFER_FORMAT_ABGR_2101010,
+       SDM_BUFFER_FORMAT_RGBA_2101010,
+       SDM_BUFFER_FORMAT_RGBA_8888_Ubwc,
+       SDM_BUFFER_FORMAT_RGBX_8888_Ubwc,
+       SDM_BUFFER_FORMAT_BGR565_Ubwc,
+       SDM_BUFFER_FORMAT_YCbCr_420_P,
+       SDM_BUFFER_FORMAT_YCrCb_420_P,
+       SDM_BUFFER_FORMAT_YV12,
+       SDM_BUFFER_FORMAT_YCbCr_420_SP,
+       SDM_BUFFER_FORMAT_YCrCb_420_SP,
+       SDM_BUFFER_FORMAT_NV12_ENCODEABLE,
+       SDM_BUFFER_FORMAT_YCbCr_420_TP10_UBWC,
+       SDM_BUFFER_FORMAT_YCbCr_420_P010_UBWC,
+       SDM_BUFFER_FORMAT_P010,
+       SDM_BUFFER_FORMAT_YCbCr_420_SP_VENUS,
+       SDM_BUFFER_FORMAT_YCbCr_420_SP_VENUS_UBWC,
+       SDM_BUFFER_FORMAT_YCbCr_422_SP,
+       SDM_BUFFER_FORMAT_YCbCr_422_I,
+       SDM_BUFFER_FORMAT_INVALID = 0xFFFFFFFF,
+};
+
+
+
+/*****************Prepare*****************/
+/* Composition type for each layer*/
+enum {
+       SDM_COMPOSITION_GPU = 0,
+       SDM_COMPOSITION_OVERLAY,
+       SDM_COMPOSITION_HW_CURSOR,
+       SDM_COMPOSITION_FB_TARGET
+
+};
+
+/* Blending type for each layer, now only support premultiplied blending */
+enum {
+       SDM_BLENDING_NONE = 0,
+       SDM_BLENDING_PREMULTIPLIED,
+       SDM_BLENDING_COVERAGE,
+};
+
+/* Rotation type*/
+enum {
+       SDM_TRANSFORM_NORMAL = 0x00,
+       SDM_TRANSFORM_FLIP_H = 0x01,
+       SDM_TRANSFORM_FLIP_V = 0x02,
+       SDM_TRANSFORM_90 = 0x04,
+       SDM_TRANSFORM_180 = 0x03,
+       SDM_TRANSFORM_270 = 0x07,
+};
+
+struct Rect {
+       float left;
+       float top;
+       float right;
+       float bottom;
+};
+
+struct  RectArray {
+       struct Rect *rects;
+       uint32_t count;
+};
+
+/*
+ * Layer flag which only be configurated by compositor. It will affect the SDM
+ * strategy result.
+ */
+struct LayerGeometryFlags {
+       uint32_t skip : 1;
+       uint32_t is_cursor : 1;
+       uint32_t has_ubwc_buf : 1;
+       uint32_t video_present: 1;
+       uint32_t secure_present: 1;
+       uint32_t hdr_present: 1;
+};
+
+
+/* Layer geometry information filled by compositor */
+/* TODO: Check if LayerGeometry from sdm layer could be re-used  */
+struct LayerGeometry {
+       /* Buffer information */
+       uint32_t               width;
+       uint32_t               height;
+       uint32_t               unaligned_width;
+       uint32_t               unaligned_height;
+       uint32_t               format;
+       uint32_t               fb_id;
+       uint32_t               ion_fd;
+       /* Layer information */
+       uint32_t               composition; /*GPU, Overlay, HWCursor*/
+       struct Rect            src_rect; /* srouce rectangle */
+       struct Rect            dst_rect; /* destination rectangle */
+       struct RectArray       visible_regions;
+       struct RectArray       dirty_regions;
+       uint32_t               blending;
+       uint32_t               transform;
+       uint8_t                plane_alpha; /* global alpha */
+       struct LayerGeometryFlags        flags;
+       ColorMetaData color_metadata;
+
+       /*Hook for storing information relative to compositor. DO NOT MODIFY IT!!!*/
+       const void *usr_data;
+};
+
+/* Scaling property */
+struct ScalingInfo {
+       struct Rect src;
+       struct Rect dst;
+       bool rotate_90;
+};
+
+/* Cursor position property */
+struct CursorPosition {
+       int x;
+       int y;
+};
+
+
+
+/* SDM property data shared by SDM display interface for compositor backend: start */
+/**
+ * List of properties attached to SDM CRTCs
+ */
+enum wsdm_crtc_property {
+     WSDM_CRTC_MODE_ID = 0,
+     WSDM_CRTC_ACTIVE,
+     WSDM_CRTC__COUNT
+};
+
+/**
+ * List of properties attached to SDM connectors
+ */
+enum wsdm_connector_property {
+     WSDM_CONNECTOR_CRTC_ID = 0,
+     WSDM_CONNECTOR__COUNT
+};
+
+/**
+ * List of HDR capabilities of display
+ */
+
+struct DisplayHdrInfo{
+  bool hdr_supported; //!< if HDR is enabled
+  uint32_t hdr_eotf; //!< Electro optical transfer function
+  bool hdr_metadata_type_one; //!< Metadata type one obtained from HDR block of content
+  uint32_t max_luminance; //!< From Panel's peak luminance
+  uint32_t average_luminance; //!< From Panel's average luminance
+  uint32_t min_luminance; //!< From Panel's blackness level
+};
+
+/**
+ * List of HDCP capabilities of display
+ */
+struct DisplayHdcpProtocol{
+  uint32_t hdcp_version; //!< HDCP version number
+  uint32_t hdcp_interface_type; //!< HDCP phycical-layer interface
+};
+
+struct DisplayConfigInfo {
+  uint32_t x_pixels;          //!< Total number of pixels in X-direction on the display panel.
+  uint32_t y_pixels;          //!< Total number of pixels in Y-direction on the display panel.
+  float    x_dpi;             //!< Dots per inch in X-direction.
+  float    y_dpi;             //!< Dots per inch in Y-direction.
+  uint32_t fps;               //!< Frame rate per second.
+  uint32_t vsync_period_ns;   //!< VSync period in nanoseconds.
+  bool     is_yuv;            //!< If the display output is in YUV format.
+  int32_t  aspect_ratio;      //!< Aspect ratio enum value
+  bool     is_connected;      //!< If the hdmi connector is plugged in.
+};
+
+typedef void (*vblank_cb_t)(unsigned int display_id,
+                            int64_t timestamp, struct drm_output *data);
+
+typedef void (*hotplug_cb_t)(int disp, bool connected, struct drm_output *data);
+
+typedef struct sdm_cbs {
+  vblank_cb_t vblank_cb;
+  hotplug_cb_t hotplug_cb;
+} sdm_cbs_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // SDM_DISPLAY_INTERFACE_H
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_socket_handler.cpp b/libweston/backend-sdm/sdm-service/sdm_display_socket_handler.cpp
new file mode 100644
index 0000000..7a6ef86
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_socket_handler.cpp
@@ -0,0 +1,46 @@
+/*
+* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+*
+* Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#include "sdm-service/sdm_display_debugger.h"
+#include "sdm-service/sdm_display_socket_handler.h"
+
+#define __CLASS__ "SdmDisplaySocketHandler"
+
+namespace sdm {
+
+SdmDisplaySocketHandler::SdmDisplaySocketHandler() {
+  DLOGW("Not supported.");
+}
+int SdmDisplaySocketHandler::GetSocketFd(SocketType socket_type) {
+  DLOGW("Not supported.");
+
+  return 0;
+}
+
+}  // namespace sdm
diff --git a/libweston/backend-sdm/sdm-service/sdm_display_socket_handler.h b/libweston/backend-sdm/sdm-service/sdm_display_socket_handler.h
new file mode 100644
index 0000000..caf8e42
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/sdm_display_socket_handler.h
@@ -0,0 +1,46 @@
+/*
+* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted
+* provided that the following conditions are met:
+*    * Redistributions of source code must retain the above copyright notice, this list of
+*      conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above copyright notice, this list of
+*      conditions and the following disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its contributors may be used to
+*      endorse or promote products derived from this software without specific prior written
+*      permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+* NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Changes from Qualcomm Innovation Center are provided under the following license:
+*
+* Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+* SPDX-License-Identifier: BSD-3-Clause-Clear
+*/
+
+#ifndef __SDM_DISPLAY_SOCKET_HANDLER_H__
+#define __SDM_DISPLAY_SOCKET_HANDLER_H__
+
+#include <core/socket_handler.h>
+
+namespace sdm {
+
+class SdmDisplaySocketHandler : public SocketHandler {
+ public:
+  SdmDisplaySocketHandler();
+
+  int GetSocketFd(SocketType socket_type);
+};
+
+}  // namespace sdm
+
+#endif  // __SDM_DISPLAY_SOCKET_HANDLER_H__
diff --git a/libweston/backend-sdm/sdm-service/uevent.c b/libweston/backend-sdm/sdm-service/uevent.c
new file mode 100644
index 0000000..7860222
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/uevent.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ *
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#include "sdm-service/uevent.h"
+#include <malloc.h>
+#include <string.h>
+#include <unistd.h>
+#include <poll.h>
+#include <pthread.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/queue.h>
+#include <linux/netlink.h>
+
+
+LIST_HEAD(uevent_handler_head, uevent_handler) uevent_handler_list;
+pthread_mutex_t uevent_handler_list_lock = PTHREAD_MUTEX_INITIALIZER;
+
+struct uevent_handler {
+    void (*handler)(void *data, const char *msg, int msg_len);
+    void *handler_data;
+    LIST_ENTRY(uevent_handler) list;
+};
+
+static int fd = -1;
+
+/* Returns 0 on failure, 1 on success */
+int uevent_init()
+{
+    struct sockaddr_nl addr;
+    int sz = 64*1024;
+    int s;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.nl_family = AF_NETLINK;
+    addr.nl_pid = getpid();
+    addr.nl_groups = 0xffffffff;
+
+    s = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
+    if(s < 0)
+        return 0;
+
+    setsockopt(s, SOL_SOCKET, SO_RCVBUFFORCE, &sz, sizeof(sz));
+
+    if(bind(s, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+        close(s);
+        return 0;
+    }
+
+    fd = s;
+    return (fd > 0);
+}
+
+int uevent_next_event(char* buffer, int buffer_length)
+{
+    while (1) {
+        struct pollfd fds;
+        int nr;
+
+        fds.fd = fd;
+        fds.events = POLLIN;
+        fds.revents = 0;
+        nr = poll(&fds, 1, -1);
+
+        if(nr > 0 && (fds.revents & POLLIN)) {
+            int count = recv(fd, buffer, buffer_length, 0);
+            if (count > 0) {
+                struct uevent_handler *h;
+                pthread_mutex_lock(&uevent_handler_list_lock);
+                LIST_FOREACH(h, &uevent_handler_list, list)
+                    h->handler(h->handler_data, buffer, buffer_length);
+                pthread_mutex_unlock(&uevent_handler_list_lock);
+
+                return count;
+            }
+        }
+    }
+
+    // won't get here
+    return 0;
+}
+
+int uevent_add_native_handler(void (*handler)(void *data, const char *msg, int msg_len),
+                             void *handler_data)
+{
+    struct uevent_handler *h;
+
+    h = malloc(sizeof(struct uevent_handler));
+    if (h == NULL)
+        return -1;
+    h->handler = handler;
+    h->handler_data = handler_data;
+
+    pthread_mutex_lock(&uevent_handler_list_lock);
+    LIST_INSERT_HEAD(&uevent_handler_list, h, list);
+    pthread_mutex_unlock(&uevent_handler_list_lock);
+
+    return 0;
+}
+
+int uevent_remove_native_handler(void (*handler)(void *data, const char *msg, int msg_len))
+{
+    struct uevent_handler *h;
+    int err = -1;
+
+    pthread_mutex_lock(&uevent_handler_list_lock);
+    LIST_FOREACH(h, &uevent_handler_list, list) {
+        if (h->handler == handler) {
+            LIST_REMOVE(h, list);
+            err = 0;
+            break;
+       }
+    }
+    pthread_mutex_unlock(&uevent_handler_list_lock);
+
+    return err;
+}
diff --git a/libweston/backend-sdm/sdm-service/uevent.h b/libweston/backend-sdm/sdm-service/uevent.h
new file mode 100644
index 0000000..caea329
--- /dev/null
+++ b/libweston/backend-sdm/sdm-service/uevent.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ *
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#ifndef _HARDWARE_UEVENT_H
+#define _HARDWARE_UEVENT_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+int uevent_init();
+int uevent_next_event(char* buffer, int buffer_length);
+int uevent_add_native_handler(void (*handler)(void *data, const char *msg, int msg_len),
+                              void *handler_data);
+int uevent_remove_native_handler(void (*handler)(void *data, const char *msg, int msg_len));
+
+#if __cplusplus
+} // extern "C"
+#endif
+
+#endif // _HARDWARE_UEVENT_H
+
diff --git a/libweston/backend-sdm/sdm.c b/libweston/backend-sdm/sdm.c
new file mode 100644
index 0000000..dd78a65
--- /dev/null
+++ b/libweston/backend-sdm/sdm.c
@@ -0,0 +1,1888 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2017, 2018 Collabora, Ltd.
+ * Copyright © 2017, 2018 General Electric Company
+ * Copyright (c) 2018 DisplayLink (UK) Ltd.
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ * Copyright (c) 2022-2023, 2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ *
+ */
+
+#include <sys/eventfd.h>
+#include <poll.h>
+#include <gbm_priv.h>
+#include "sdm-internal.h"
+#include "shared/timespec-util.h"
+#include "shared/string-helpers.h"
+#include "pixman-renderer.h"
+#include "pixel-formats.h"
+#include "libinput-seat.h"
+#include "launcher-util.h"
+#include "presentation-time-server-protocol.h"
+#include "linux-dmabuf.h"
+#include "linux-dmabuf-unstable-v1-server-protocol.h"
+#include "linux-explicit-synchronization.h"
+
+#include "sdm-service/sdm_display_connect.h"
+
+
+static const char default_seat[] = "seat0";
+#define FENCE_TIMEOUT 1000
+
+enum {
+    PRIMARY_DISPLAY_ID,
+    EXTERNAL_DISPLAY_ID
+};
+
+static int sync_wait(int fd, int timeout)
+{
+    struct pollfd fds;
+    int ret;
+
+    if (fd < 0) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    fds.fd = fd;
+    fds.events = POLLIN;
+
+    do {
+        ret = poll(&fds, 1, timeout);
+        if (ret > 0) {
+            if (fds.revents & (POLLERR | POLLNVAL)) {
+                errno = EINVAL;
+                return -1;
+            }
+            return 0;
+        } else if (ret == 0) {
+            errno = ETIME;
+            return -1;
+        }
+    } while (ret == -1 && (errno == EINTR || errno == EAGAIN));
+
+    return ret;
+}
+
+static void
+vblank_handler(int display_id, int64_t timestamp, void *data)
+{
+	struct drm_output *output = (struct drm_output *) data;
+	uint64_t v = 1;
+
+	output->last_vblank.sec = timestamp / 1000000000LL;
+	output->last_vblank.usec = (timestamp % 1000000000LL) / 1000;
+
+	write(output->vblank_ev_fd, &v, sizeof v);
+}
+
+static void
+hotplug_handler(int disp, bool connected, void *data)
+{
+       weston_log("Hotplug connected = %d called\n", connected);
+}
+
+static int
+on_vblank(int fd, uint32_t mask, void *data)
+{
+	struct drm_output *output = (struct drm_output *) data;
+	/* During the initial modeset, we can disable CRTCs which we don't
+	 * actually handle during normal operation; this will give us events
+	 * for unknown outputs. Ignore them. */
+	if (!output || !output->base.enabled)
+		return -1;
+
+	struct drm_backend *b = to_drm_backend(output->base.compositor);;
+	unsigned int sec, usec;
+	uint64_t v = 0;
+
+	read(fd, &v, sizeof(v));
+
+	uint32_t flags = WP_PRESENTATION_FEEDBACK_KIND_VSYNC |
+			 WP_PRESENTATION_FEEDBACK_KIND_HW_COMPLETION |
+			 WP_PRESENTATION_FEEDBACK_KIND_HW_CLOCK;
+	if (!output->atomic_complete_pending) {
+		SetVSyncState(output->display_id, false, output);
+	}
+	if (output->atomic_complete_pending) {
+		drm_output_update_msc(output, output->last_vblank.frame);
+		output->atomic_complete_pending = false;
+
+		assert(b->atomic_modeset);
+
+		usec = output->last_vblank.usec;
+		sec = output->last_vblank.sec;
+		drm_output_update_complete(output, flags, sec, usec);
+	}
+	return 0;
+}
+
+void
+sdm_weston_transformed_rect(struct drm_output *output,
+				 pixman_box32_t *tbox, pixman_box32_t box)
+{
+	*tbox = weston_transformed_rect(output->base.width,
+					output->base.height,
+					output->base.transform,
+					output->base.current_scale,
+					box);
+}
+
+void
+sdm_weston_global_transform_rect(struct weston_view *ev,
+				pixman_box32_t *box, float *x1, float *y1,
+				float *x2, float *y2)
+{
+	float sx1, sy1, sx2, sy2;
+	weston_view_from_global_float(ev, box->x1, box->y1, &sx1, &sy1);
+	weston_surface_to_buffer_float(ev->surface, sx1, sy1, &sx1, &sy1);
+	weston_view_from_global_float(ev, box->x2, box->y2, &sx2, &sy2);
+	weston_surface_to_buffer_float(ev->surface, sx2, sy2, &sx2, &sy2);
+
+	*x1 = sx1;
+	*y1 = sy1;
+	*x2 = sx2;
+	*y2 = sy2;
+}
+
+static int
+drm_output_enable_vblank(struct drm_output *output)
+{
+     struct wl_event_loop *loop;
+
+     output->vblank_ev_fd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
+     if (output->vblank_ev_fd < 0)
+        return -1;
+
+     loop = wl_display_get_event_loop(output->base.compositor->wl_display);
+     output->vblank_ev_source =
+		 wl_event_loop_add_fd(loop, output->vblank_ev_fd,
+					WL_EVENT_READABLE, on_vblank, output);
+     return 0;
+}
+
+static void
+drm_output_disable_vblank(struct drm_output *output)
+{
+	if (output->vblank_ev_source != NULL) {
+	        wl_event_source_remove(output->vblank_ev_source);
+	        output->vblank_ev_source = NULL;
+	}
+
+	if (output->vblank_ev_fd != -1) {
+		close(output->vblank_ev_fd);
+		output->vblank_ev_fd = -1;
+	}
+
+	SetVSyncState(output->display_id, false, output);
+}
+
+static int
+pageflip_timeout(void *data) {
+	/*
+	 * Our timer just went off, that means we're not receiving drm
+	 * page flip events anymore for that output. Let's gracefully exit
+	 * weston with a return value so devs can debug what's going on.
+	 */
+	struct drm_output *output = data;
+	struct weston_compositor *compositor = output->base.compositor;
+
+	weston_log("Pageflip timeout reached on output %s, your "
+	           "driver is probably buggy!  Exiting.\n",
+		   output->base.name);
+	weston_compositor_exit_with_code(compositor, EXIT_FAILURE);
+
+	return 0;
+}
+
+/* Creates the pageflip timer. Note that it isn't armed by default */
+static int
+drm_output_pageflip_timer_create(struct drm_output *output)
+{
+	struct wl_event_loop *loop = NULL;
+	struct weston_compositor *ec = output->base.compositor;
+
+	loop = wl_display_get_event_loop(ec->wl_display);
+	assert(loop);
+	output->pageflip_timer = wl_event_loop_add_timer(loop,
+	                                                 pageflip_timeout,
+	                                                 output);
+
+	if (output->pageflip_timer == NULL) {
+		weston_log("creating drm pageflip timer failed: %s\n",
+			   strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static void
+drm_output_destroy(struct weston_output *output_base);
+
+/**
+ * Mark a drm_output_state (the output's last state) as complete. This handles
+ * any post-completion actions such as updating the repaint timer, disabling the
+ * output, and finally freeing the state.
+ */
+void
+drm_output_update_complete(struct drm_output *output, uint32_t flags,
+			   unsigned int sec, unsigned int usec)
+{
+	struct timespec ts;
+	struct sdm_layer *sdm_layer, *tmp_layer;
+
+	/* Stop the pageflip timer instead of rearming it here */
+	if (output->pageflip_timer)
+		wl_event_source_timer_update(output->pageflip_timer, 0);
+
+	drm_fb_unref(output->next_fb);
+	output->next_fb = NULL;
+
+        ClearSDMLayers(output);
+
+	if (output->dpms != WESTON_DPMS_ON) {
+		if (output->destroy_pending) {
+			output->destroy_pending = false;
+			output->disable_pending = false;
+			output->dpms_off_pending = false;
+			drm_output_destroy(&output->base);
+			return;
+		} else if (output->disable_pending) {
+			output->disable_pending = false;
+			output->dpms_off_pending = false;
+			weston_output_disable(&output->base);
+			return;
+		} else if (output->dpms_off_pending) {
+			output->dpms_off_pending = false;
+		}
+	}
+
+	ts.tv_sec = sec;
+	ts.tv_nsec = usec * 1000;
+
+	if (output->base.repaint_status == REPAINT_AWAITING_COMPLETION)
+		weston_output_finish_frame(&output->base, &ts, flags);
+
+}
+
+static struct drm_fb *
+drm_output_render_pixman(struct drm_output *output,
+			 pixman_region32_t *damage)
+{
+	struct weston_compositor *ec = output->base.compositor;
+	struct drm_backend *b = to_drm_backend(ec);
+
+	output->current_image ^= 1;
+
+	pixman_renderer_output_set_buffer(&output->base,
+					  output->image[output->current_image]);
+	pixman_renderer_output_set_hw_extra_damage(&output->base,
+						   &output->previous_damage);
+
+	ec->renderer->repaint_output(&output->base, damage);
+
+	pixman_region32_copy(&output->previous_damage, damage);
+
+	return drm_fb_get_from_bo(output->dumb_bo[output->current_image],
+						b, true, BUFFER_PIXMAN_GBM);
+}
+
+static void
+drm_output_render(struct drm_output *output, pixman_region32_t *damage)
+{
+	struct weston_compositor *c = output->base.compositor;
+	struct drm_backend *b = to_drm_backend(c);
+	struct drm_fb *fb;
+
+	if (b->use_pixman) {
+		fb = drm_output_render_pixman(output, damage);
+	} else {
+		fb = drm_output_render_gl(output, damage);
+	}
+
+	if (!fb) {
+		output->next_fb = NULL;
+		weston_log("ERROR: No repaint framebuffer, \
+				output=%s expect crashs\n", output->base.name);
+		return;
+	}
+
+	output->next_fb = fb;
+	pixman_region32_subtract(&c->primary_plane.damage,
+				 &c->primary_plane.damage, damage);
+}
+
+/* returns a value between 0-255 range, where higher is brighter */
+static uint32_t
+drm_get_backlight(int disp_id)
+{
+	float brightness = -1.0f;
+	uint32_t level = 0;
+	int ret = 0;
+
+	ret = GetPanelBrightness(disp_id, &brightness);
+	if (ret) {
+		weston_log("%s: failed error=%d\n", __func__, ret);
+		return ret;
+	}
+
+	if (brightness == -1.0f) {
+		level = 0;
+	} else {
+		level = (uint32_t)(254.0f*brightness + 1);
+	}
+
+	weston_log("%s: backlight value:%d brightness:%f \n", __func__, level, brightness);
+	return level;
+}
+
+/* values accepted are between 0-255 range */
+static int
+drm_set_backlight(struct weston_output *output_base, uint32_t value)
+{
+	int ret = 0;
+	struct drm_output *output = to_drm_output(output_base);
+	int disp_id = output->display_id;
+
+	if (!(0 <= value && value <= 255)) {
+		weston_log("%s: not in supported range, backlight = %d\n", __func__, value);
+		return -1;
+	}
+
+	if (value == drm_get_backlight(disp_id)) {
+		weston_log("%s: already in same state, backlight = %d\n", __func__, value);
+		return 0;
+	}
+
+	if (value == 0) {
+		ret = SetPanelBrightness(disp_id, -1.0f);
+	} else {
+		ret = SetPanelBrightness(disp_id, (value - 1)/254.0f);
+	}
+
+	if (ret) {
+		weston_log("%s: backlight setting failed error = %d\n", __func__, ret);
+		return ret;
+	}
+	output_base->backlight_current = drm_get_backlight(disp_id);
+
+	weston_log("%s: backlight set to value: %d \n", __func__, value);
+	return ret;
+}
+
+static int
+drm_output_repaint(struct weston_output *output_base,
+		   pixman_region32_t *damage,
+		   void *repaint_data)
+{
+	struct drm_output *output = to_drm_output(output_base);
+
+	if (output->disable_pending || output->destroy_pending)
+		return -1;
+
+	if (output->next_fb)
+		return 0;
+
+	drm_output_render(output, damage);
+	if (!output->next_fb) {
+		weston_log("error: framebuffer not created\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+drm_output_start_repaint_loop(struct weston_output *output_base)
+{
+	struct drm_output *output = to_drm_output(output_base);
+
+	if (output->disable_pending || output->destroy_pending)
+		return 0;
+
+	//SDM will handle vblank. Finish frame immediately.
+	weston_output_finish_frame(output_base, NULL,
+				   WP_PRESENTATION_FEEDBACK_INVALID);
+	return 0;
+}
+
+/**
+ * Begin a new repaint cycle
+ *
+ * Called by the core compositor at the beginning of a repaint cycle. Creates
+ * a new pending_state structure to own any output state created by individual
+ * output repaint functions until the repaint is flushed or cancelled.
+ */
+static void *
+drm_repaint_begin(struct weston_compositor *compositor)
+{
+	struct drm_backend *b = to_drm_backend(compositor);
+	struct drm_pending_state *ret = NULL;
+
+	b->repaint_data = NULL;
+
+	if (weston_log_scope_is_enabled(b->debug)) {
+		char *dbg = weston_compositor_print_scene_graph(compositor);
+		drm_debug(b, "[repaint] Beginning repaint; pending_state %p\n",
+			  ret);
+		drm_debug(b, "%s", dbg);
+		free(dbg);
+	}
+
+	return ret;
+}
+
+/**
+ * Flush a repaint set
+ *
+ * Called by the core compositor when a repaint cycle has been completed
+ * and should be flushed. Frees the pending state, transitioning ownership
+ * of the output state from the pending state, to the update itself. When
+ * the update completes (see drm_output_update_complete), the output
+ * state will be freed.
+ */
+static int
+drm_repaint_flush(struct weston_compositor *compositor, void *repaint_data)
+{
+	struct drm_backend *b = to_drm_backend(compositor);
+	struct weston_output *output = NULL;
+	int ret = 0;
+
+	wl_list_for_each(output, &compositor->output_list, link) {
+		struct drm_output *drm_output = to_drm_output(output);
+
+		if (!drm_output->next_fb)
+			continue;
+
+		ret = SetVSyncState(drm_output->display_id, true, drm_output);
+
+		if (ret != 0) {
+			weston_log("Vsync failed\n");
+			return -1;
+		}
+
+		ret = Commit(drm_output->display_id, drm_output);
+
+		if (ret != 0) {
+			weston_log("%s : commit failed err = %d\n", __func__, ret);
+			return -2;
+		}
+
+		drm_output->atomic_complete_pending = true;
+	}
+
+	b->repaint_data = NULL;
+
+	return 0;
+}
+
+/**
+ * Cancel a repaint set
+ *
+ * Called by the core compositor when a repaint has finished, so the data
+ * held across the repaint cycle should be discarded.
+ */
+static void
+drm_repaint_cancel(struct weston_compositor *compositor, void *repaint_data)
+{
+	struct drm_backend *b = to_drm_backend(compositor);
+
+	if (b->repaint_data) {
+		free(b->repaint_data);
+		b->repaint_data = NULL;
+	}
+}
+
+static int
+drm_output_init_pixman(struct drm_output *output, struct drm_backend *b);
+static void
+drm_output_fini_pixman(struct drm_output *output);
+
+static int
+drm_output_switch_mode(struct weston_output *output_base, struct weston_mode *mode)
+{
+	struct drm_output *output = to_drm_output(output_base);
+	struct drm_backend *b = to_drm_backend(output_base->compositor);
+	struct drm_mode *drm_mode = drm_output_choose_mode(output, mode);
+
+	if (!drm_mode) {
+		weston_log("%s: invalid resolution %dx%d\n",
+			   output_base->name, mode->width, mode->height);
+		return -1;
+	}
+
+	if (&drm_mode->base == output->base.current_mode)
+		return 0;
+
+	output->base.current_mode->flags = 0;
+
+	output->base.current_mode = &drm_mode->base;
+	output->base.current_mode->flags =
+		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
+
+	/* XXX: This drops our current buffer too early, before we've started
+	 *      displaying it. Ideally this should be much more atomic and
+	 *      integrated with a full repaint cycle, rather than doing a
+	 *      sledgehammer modeswitch first, and only later showing new
+	 *      content.
+	 */
+	b->state_invalid = true;
+
+	if (b->use_pixman) {
+		drm_output_fini_pixman(output);
+		if (drm_output_init_pixman(output, b) < 0) {
+			weston_log("failed to init output pixman state with "
+				   "new mode\n");
+			return -1;
+		}
+	} else {
+		drm_output_fini_egl(output);
+		if (drm_output_init_egl(output, b) < 0) {
+			weston_log("failed to init output egl state with "
+				   "new mode");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static struct gbm_device *
+create_gbm_device(int fd)
+{
+	struct gbm_device *gbm;
+
+	gbm = gbm_create_device(fd);
+
+	return gbm;
+}
+
+static int
+init_pixman(struct drm_backend *b)
+{
+	b->gbm = create_gbm_device(b->drm.fd);
+
+	if (!b->gbm)
+		return -1;
+
+	return pixman_renderer_init(b->compositor);
+}
+
+/**
+ * Power output on or off
+ *
+ * The DPMS/power level of an output is used to switch it on or off. This
+ * is DRM's hook for doing so, which can called either as part of repaint,
+ * or independently of the repaint loop.
+ *
+ * If we are called as part of repaint, we simply set the relevant bit in
+ * state and return.
+ *
+ * This function is never called on a virtual output.
+ */
+static void
+drm_set_dpms(struct weston_output *output_base, enum dpms_enum level)
+{
+	struct drm_output *output = to_drm_output(output_base);
+	int ret;
+
+	weston_log("%s: SDM DPMS level = %d\n", __func__, level);
+	ret = SetDisplayState(output->display_id, level);
+
+	if (ret) {
+		weston_log("%s: SDM DPMS ON failed error = %d\n", __func__, ret);
+		return ret;
+	}
+
+	output->dpms = level;
+	/* As we throw everything away when disabling, just send us back through
+	 * a repaint cycle. */
+	if (level == WESTON_DPMS_ON) {
+		if (output->dpms_off_pending)
+			output->dpms_off_pending = false;
+		weston_output_schedule_repaint(output_base);
+		return;
+	}
+}
+
+static int
+drm_output_init_pixman(struct drm_output *output, struct drm_backend *b)
+{
+	int w = output->base.current_mode->width;
+	int h = output->base.current_mode->height;
+	uint32_t format = output->gbm_format;
+	uint32_t pixman_format;
+	unsigned int i;
+	const struct pixman_renderer_output_options options = {
+		.use_shadow = b->use_pixman_shadow,
+		.gbm_handle = b->gbm
+	};
+
+	switch (format) {
+		case GBM_FORMAT_ABGR8888:
+			pixman_format = PIXMAN_a8b8g8r8;
+			break;
+		case GBM_FORMAT_ARGB8888:
+			pixman_format = PIXMAN_a8r8g8b8;
+			break;
+		case GBM_FORMAT_XRGB8888:
+			pixman_format = PIXMAN_x8r8g8b8;
+			break;
+		case GBM_FORMAT_RGB565:
+			pixman_format = PIXMAN_r5g6b5;
+			break;
+		default:
+			weston_log("Unsupported pixman format 0x%x\n", format);
+			return -1;
+	}
+
+	/* FIXME error checking */
+	for (i = 0; i < ARRAY_LENGTH(output->dumb_bo); i++) {
+		output->dumb_bo[i] = gbm_bo_create(b->gbm, w, h, format, output->gbm_bo_flags);
+		if (!output->dumb_bo[i])
+			goto err;
+
+		// Use gbm buffer as pixman image
+		uint8_t *bo_mmap = NULL;
+		int ret = -1;
+		ret = gbm_perform(GBM_PERFORM_CPU_MAP_FOR_BO, output->dumb_bo[i], &bo_mmap);
+		if (ret != GBM_ERROR_NONE) {
+			weston_log("gbm bo map failed with ret = %d\n", ret);
+			goto err;
+		}
+
+		weston_log("gbm bo [%d] map = %p\n", i, bo_mmap);
+
+		output->image[i] =
+		pixman_image_create_bits(pixman_format, w, h,
+						 bo_mmap, gbm_bo_get_stride(output->dumb_bo[i]));
+		if (!output->image[i])
+			goto err;
+	}
+
+	if (pixman_renderer_output_create(&output->base, &options) < 0)
+		goto err;
+
+	weston_log("DRM: output %s %s shadow framebuffer.\n", output->base.name,
+		   b->use_pixman_shadow ? "uses" : "does not use");
+
+	pixman_region32_init_rect(&output->previous_damage,
+				  output->base.x, output->base.y, output->base.width, output->base.height);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_LENGTH(output->dumb_bo); i++) {
+		if (output->image[i])
+			pixman_image_unref(output->image[i]);
+		if (output->dumb_bo[i])
+			gbm_bo_destroy(output->dumb_bo[i]);
+
+		output->image[i] = NULL;
+		output->dumb_bo[i] = NULL;
+	}
+
+	return -1;
+}
+
+static void
+drm_output_fini_pixman(struct drm_output *output)
+{
+	unsigned int i;
+
+	pixman_renderer_output_destroy(&output->base);
+	pixman_region32_fini(&output->previous_damage);
+
+	for (i = 0; i < ARRAY_LENGTH(output->dumb_bo); i++) {
+		pixman_image_unref(output->image[i]);
+		output->image[i] = NULL;
+		gbm_bo_destroy(output->dumb_bo[i]);
+		output->dumb_bo[i] = NULL;
+	}
+}
+
+static void
+setup_output_seat_constraint(struct drm_backend *b,
+			     struct weston_output *output,
+			     const char *s)
+{
+	if (strcmp(s, "") != 0) {
+		struct weston_pointer *pointer;
+		struct udev_seat *seat;
+
+		seat = udev_seat_get_named(&b->input, s);
+		if (!seat)
+			return;
+
+		seat->base.output = output;
+
+		pointer = weston_seat_get_pointer(&seat->base);
+		if (pointer)
+			weston_pointer_clamp(pointer,
+					     &pointer->x,
+					     &pointer->y);
+	}
+}
+
+static int
+drm_output_attach_head(struct weston_output *output_base,
+		       struct weston_head *head_base)
+{
+	struct drm_backend *b = to_drm_backend(output_base->compositor);
+
+	if (wl_list_length(&output_base->head_list) >= MAX_CLONED_CONNECTORS)
+		return -1;
+
+	if (!output_base->enabled)
+		return 0;
+
+	/* XXX: ensure the configuration will work.
+	 * This is actually impossible without major infrastructure
+	 * work. */
+
+	/* Need to go through modeset to add connectors. */
+	/* XXX: Ideally we'd do this per-output, not globally. */
+	/* XXX: Doing it globally, what guarantees another output's update
+	 * will not clear the flag before this output is updated?
+	 */
+	b->state_invalid = true;
+
+	weston_output_schedule_repaint(output_base);
+
+	return 0;
+}
+
+static void
+drm_output_detach_head(struct weston_output *output_base,
+		       struct weston_head *head_base)
+{
+	struct drm_backend *b = to_drm_backend(output_base->compositor);
+
+	if (!output_base->enabled)
+		return;
+
+	/* Need to go through modeset to drop connectors that should no longer
+	 * be driven. */
+	/* XXX: Ideally we'd do this per-output, not globally. */
+	b->state_invalid = true;
+
+	weston_output_schedule_repaint(output_base);
+}
+
+int
+parse_gbm_format(const char *s, uint32_t default_value, uint32_t *gbm_format)
+{
+	const struct pixel_format_info *pinfo;
+
+	if (s == NULL) {
+		*gbm_format = default_value;
+
+		return 0;
+	}
+
+	pinfo = pixel_format_get_info_by_drm_name(s);
+	if (!pinfo) {
+		weston_log("fatal: unrecognized pixel format: %s\n", s);
+
+		return -1;
+	}
+
+	/* GBM formats and DRM formats are identical. */
+	*gbm_format = pinfo->format;
+
+	return 0;
+}
+
+static void
+drm_output_set_gbm_format(struct weston_output *base,
+			  const char *gbm_format)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (parse_gbm_format(gbm_format, b->gbm_format, &output->gbm_format) == -1)
+		output->gbm_format = b->gbm_format;
+}
+
+static void
+drm_output_set_seat(struct weston_output *base,
+		    const char *seat)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	setup_output_seat_constraint(b, &output->base,
+				     seat ? seat : "");
+}
+
+static int
+drm_output_enable(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (b->pageflip_timeout) {
+		drm_output_pageflip_timer_create(output);
+	}
+
+	if (b->use_pixman) {
+		if (drm_output_init_pixman(output, b) < 0) {
+			weston_log("Failed to init output pixman state\n");
+			return -1;
+		}
+	} else if (drm_output_init_egl(output, b) < 0) {
+		weston_log("Failed to init output gl state\n");
+		return -1;
+	}
+
+	output->base.start_repaint_loop = drm_output_start_repaint_loop;
+	output->base.repaint = drm_output_repaint;
+	output->base.assign_planes = drm_assign_planes;
+	output->base.set_dpms = drm_set_dpms;
+	output->base.switch_mode = drm_output_switch_mode;
+	output->base.set_backlight = drm_set_backlight;
+	output->base.backlight_current = drm_get_backlight(output->display_id);
+	output->base.set_gamma = NULL;
+
+	if (drm_output_enable_vblank(output)) {
+		weston_log("Failed to create vblank event\n");
+		return -1;
+	}
+
+	drm_output_print_modes(output);
+
+       // weston treats 255 as max brightness setting initial brightness to ~50% on builtin display
+
+        uint32_t disp_id = output->display_id;
+        int type = GetDisplayType(disp_id);
+        if (type == 0) {
+               int ret = drm_set_backlight(base, 127);
+               if (ret != 0) {
+                       weston_log("Failed to Init backlight\n");
+                       return -1;
+                }
+       }
+
+	return 0;
+}
+
+static void
+drm_output_deinit(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (b->use_pixman)
+		drm_output_fini_pixman(output);
+	else
+		drm_output_fini_egl(output);
+}
+
+static void
+drm_head_output_power_off(struct drm_head *head);
+
+static void
+drm_head_destroy(struct drm_head *head);
+
+static void
+drm_output_destroy(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (output->base.enabled)
+		drm_output_deinit(&output->base);
+
+	drm_mode_list_destroy(b, &output->base.mode_list);
+
+	if (output->pageflip_timer)
+		wl_event_source_remove(output->pageflip_timer);
+
+	drm_output_disable_vblank(output);
+	weston_output_release(&output->base);
+
+	free(output);
+}
+
+static int
+drm_output_disable(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+
+	if (output->page_flip_pending || output->atomic_complete_pending) {
+		output->disable_pending = true;
+		return -1;
+	}
+
+	weston_log("Disabling output %s\n", output->base.name);
+
+	if (output->base.enabled)
+		drm_output_deinit(&output->base);
+
+	output->disable_pending = false;
+
+	SetVSyncState(output->display_id, false, output);
+
+	return 0;
+}
+
+static void
+drm_head_log_info(struct drm_head *head, const char *msg)
+{
+	if (head->base.connected) {
+		weston_log("DRM: head '%s' %s, connector %d is connected, "
+			   "EDID make '%s', model '%s', serial '%s'\n",
+			   head->base.name, msg, head->connector_id,
+			   head->base.make, head->base.model,
+			   head->base.serial_number ?: "");
+	} else {
+		weston_log("DRM: head '%s' %s, connector %d is disconnected.\n",
+			   head->base.name, msg, head->connector_id);
+	}
+}
+
+/**
+ * Create a Weston head for a connector
+ *
+ * Given a DRM connector, create a matching drm_head structure and add it
+ * to Weston's head list.
+ *
+ * @param backend Weston backend structure
+ * @param connector_id DRM connector ID for the head
+ * @param drm_device udev device pointer
+ * @returns The new head, or NULL on failure.
+ */
+static struct drm_head *
+drm_head_create(struct drm_backend *backend, struct udev_device *drm_device, int display_id)
+{
+	struct drm_head *head;
+	char *name;
+	const char *make = "unknown";
+	const char *model = "unknown";
+	const char *serial_number = "unknown";
+	int width = 0, height = 0, refresh = 0;
+
+	if (!IsDisplayCreated(display_id)) {
+		sdm_cbs_t sdm_cbs;
+		int rc = CreateDisplay(display_id);
+		if (rc != 0) {
+			weston_log("SDM failed to create display id: %d, error = %d\n",
+						display_id, rc);
+			return NULL;
+		} else {
+			weston_log("%s: SDM display (id: %d) created\n", __func__, display_id);
+		}
+
+		/* Now register callbacks with SDM services */
+		sdm_cbs.vblank_cb = vblank_handler;
+		sdm_cbs.hotplug_cb = hotplug_handler;
+		RegisterCbs(display_id, &sdm_cbs);
+	} else {
+		weston_log("%s: SDM display created already\n", __func__);
+	}
+
+	head = zalloc(sizeof *head);
+	if (!head)
+		return NULL;
+
+	name = GetConnectorName(display_id);
+	if (!name)
+		goto err_alloc;
+	weston_log("display_id:%d and connector name:%s\n",display_id, name);
+
+	weston_head_init(&head->base, name);
+
+	free(name);
+
+	head->connector_id = display_id;
+	head->backend = backend;
+
+	weston_head_set_monitor_strings(&head->base, make, model, serial_number);
+	weston_head_set_non_desktop(&head->base, false);
+	weston_head_set_subpixel(&head->base, WL_OUTPUT_SUBPIXEL_UNKNOWN);
+
+	struct DisplayConfigInfo display_config;
+	display_config.x_pixels        = 0;
+	display_config.y_pixels        = 0;
+	display_config.x_dpi           = 96.0f;
+	display_config.y_dpi           = 96.0f;
+	display_config.fps             = 0;
+	display_config.vsync_period_ns = 0;
+	display_config.is_yuv          = false;
+
+	bool rc = GetDisplayConfiguration(display_id, &display_config);
+
+	if (rc != 0) {
+		width   = display_config.x_pixels;
+		height  = display_config.y_pixels;
+		refresh = display_config.fps*1000;
+		weston_log("Display configuration w*h:%d %d\n", width, height);
+	} else { /* default 1080p, 60 fps */
+		weston_log("Fail to get preferred mode, use default mode instead!\n");
+		width   = 1920;
+		height  = 1080;
+		refresh = 60*1000;
+	}
+
+	weston_head_set_physical_size(&head->base, width, height);
+
+	weston_head_set_connection_status(&head->base, true);
+
+	/* Disable HDCP for now */
+	weston_head_set_content_protection_status(&head->base,
+							 WESTON_HDCP_DISABLE);
+	weston_head_set_internal(&head->base);
+	weston_compositor_add_head(backend->compositor, &head->base);
+
+	drm_head_log_info(head, "found");
+
+	return head;
+
+err_alloc:
+	free(head);
+
+	return NULL;
+}
+
+static void
+drm_head_output_power_off(struct drm_head *head) {
+	struct weston_output *output_base = weston_head_get_output(&head->base);
+	if (output_base) {
+		drm_set_dpms(output_base, WESTON_DPMS_OFF);
+	}
+}
+
+static void
+drm_head_destroy(struct drm_head *head)
+{
+	weston_head_release(&head->base);
+	if (DestroyDisplay(head->connector_id)) {
+		weston_log("DestroyDisplay: failed for head '%s' (connector %d).\n",
+					head->base.name, head->connector_id);
+	}
+	free(head);
+}
+
+/**
+ * Create a Weston output structure
+ *
+ * Create an "empty" drm_output. This is the implementation of
+ * weston_backend::create_output.
+ *
+ * Creating an output is usually followed by drm_output_attach_head()
+ * and drm_output_enable() to make use of it.
+ *
+ * @param compositor The compositor instance.
+ * @param name Name for the new output.
+ * @returns The output, or NULL on failure.
+ */
+static struct weston_output *
+drm_output_create(struct weston_compositor *compositor, const char *name)
+{
+	struct drm_backend *b = to_drm_backend(compositor);
+	struct drm_output *output;
+
+	output = zalloc(sizeof *output);
+	if (output == NULL)
+		return NULL;
+
+	output->backend = b;
+#ifdef BUILD_DRM_GBM
+	output->gbm_bo_flags = GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING;
+#endif
+
+	weston_output_init(&output->base, compositor, name);
+
+	wl_list_init(&output->sdm_layer_list);
+	wl_list_init(&output->prev_sdm_layer_list);
+
+	output->base.enable = drm_output_enable;
+	output->base.destroy = drm_output_destroy;
+	output->base.disable = drm_output_disable;
+	output->base.attach_head = drm_output_attach_head;
+	output->base.detach_head = drm_output_detach_head;
+
+	output->destroy_pending = false;
+	output->disable_pending = false;
+
+	weston_compositor_add_pending_output(&output->base, b->compositor);
+
+	return &output->base;
+}
+
+struct drm_head *
+drm_head_find_by_connector(struct drm_backend *backend, uint32_t connector_id)
+{
+	struct weston_head *base;
+	struct drm_head *head;
+
+	wl_list_for_each(base,
+			 &backend->compositor->head_list, compositor_link) {
+		head = to_drm_head(base);
+		if (head->connector_id == connector_id)
+			return head;
+	}
+
+	return NULL;
+}
+
+static int
+drm_backend_create_heads(struct drm_backend *b, struct udev_device *drm_device)
+{
+	struct drm_head *head;
+	int i = 0, rc = 0, num_displays;
+	uint32_t *display_ids = NULL;
+
+	rc = GetDisplayInfos();
+	if (rc) {
+		weston_log("Failed to get display information from SDM!\n");
+		return -1;
+	}
+
+	// Collect connectors list
+	num_displays = GetDisplayCount();
+	display_ids = calloc(num_displays, sizeof(uint32_t));
+	if (!display_ids) {
+		return -1;
+	}
+	rc = GetConnectedDisplaysIds(num_displays, display_ids);
+	if (rc) {
+		goto err_connector;
+	}
+
+	/* collect new connectors that have appeared, e.g. MST */
+	for (i = 0; i < num_displays; i++) {
+		uint32_t display_id = display_ids[i];
+
+		head = drm_head_find_by_connector(b, display_id);
+		if (head) {
+			weston_log("Head (with display_id: %d) already available.\n", display_id);
+		} else {
+			head = drm_head_create(b, drm_device, display_id);
+			if (!head) {
+				weston_log("DRM: failed to create head for hot-added"
+						   " connector %d.\n", display_id);
+				continue;
+			}
+		}
+
+		rc = SetDisplayState(display_id, WESTON_DPMS_ON);
+		if (rc) {
+			weston_log("%s: SDM failed to turn on display (%d), error=%d\n",
+					   __func__, display_id, rc);
+			goto err_connector;
+		}
+	}
+
+err_connector:
+	free(display_ids);
+	return rc;
+}
+
+static int
+udev_event_is_disconnected(struct drm_backend *b, struct udev_device *device) {
+    const char *status = udev_device_get_property_value(device, "status");
+
+    if (!status)
+        return 0;
+
+    return strcmp(status, "disconnected") == 0;
+}
+
+static int
+udev_event_is_connected(struct drm_backend *b, struct udev_device *device) {
+    const char *status = udev_device_get_property_value(device, "status");
+
+    if (status == NULL)
+        return 0;
+
+    return strcmp(status, "connected") == 0;
+}
+
+static void
+drm_backend_update_heads(struct drm_backend *b, struct udev_device *drm_device)
+{
+	struct weston_head *base, *next;
+	struct drm_head *head;
+	int i, rc = 0, num_displays = 0;
+	uint32_t *display_ids = NULL;
+
+	rc = GetDisplayInfos();
+	if (rc) {
+		weston_log("Failed to get display information from SDM!\n");
+		return;
+	}
+
+	// Collect connectors list
+	num_displays = GetDisplayCount();
+	display_ids = calloc(num_displays, sizeof(uint32_t));
+	if (!display_ids) {
+		return;
+	}
+	rc = GetConnectedDisplaysIds(num_displays, display_ids);
+	if (rc) {
+		goto err_connector;
+	}
+
+	/* collect new connectors that have appeared, e.g. MST */
+	for (i = 0; i < num_displays; i++) {
+		uint32_t display_id = display_ids[i];
+
+		head = drm_head_find_by_connector(b, display_id);
+		if (head) {
+			weston_log("Head (with display_id: %d) already available.\n", display_id);
+			// TODO: Implement functionality to update display config
+			// drm_head_update_info(head);
+		} else {
+			head = drm_head_create(b, drm_device, display_id);
+			if (!head) {
+				weston_log("DRM: failed to create head for hot-added"
+						   " connector %d.\n", display_id);
+				continue;
+			}
+		}
+		SetDisplayState(display_id, WESTON_DPMS_ON);
+		weston_log("%s: CONNECT done for display_id: %d\n", __func__, display_id);
+	}
+
+	/* Remove connectors that have disappeared. */
+	wl_list_for_each_safe(base, next, &b->compositor->head_list, compositor_link) {
+		bool removed = true;
+
+		head = to_drm_head(base);
+
+		for (i = 0; i < num_displays; i++) {
+			if (display_ids[i] == head->connector_id) {
+				removed = false;
+				break;
+			}
+		}
+
+		if (!removed)
+			continue;
+
+		weston_log("DRM: head '%s' (connector %d) disappeared.\n",
+			   head->base.name, head->connector_id);
+		drm_head_output_power_off(head);
+		drm_head_destroy(head);
+	}
+
+err_connector:
+	free(display_ids);
+}
+
+static int
+udev_event_is_hotplug(struct drm_backend *b, struct udev_device *device)
+{
+	const char *sysnum;
+	const char *val;
+
+	sysnum = udev_device_get_sysnum(device);
+	if (!sysnum || atoi(sysnum) != b->drm.id)
+		return 0;
+
+	val = udev_device_get_property_value(device, "ACTION");
+	if (!val)
+		return 0;
+
+	return strcmp(val, "change") == 0;
+}
+
+static int
+udev_drm_event(int fd, uint32_t mask, void *data)
+{
+	struct drm_backend *b = data;
+	struct udev_device *event = udev_monitor_receive_device(b->udev_monitor);;
+	int hpd = udev_event_is_hotplug(b, event);
+	int connected = udev_event_is_connected(b, event);
+	int disconnected = udev_event_is_disconnected(b, event);
+	int expect_hpd = hpd && (connected || disconnected);
+
+	if (expect_hpd) {
+		weston_log("expected hpd event,connected=[%d] disconnected=[%d]\n",
+				connected, disconnected);
+		drm_backend_update_heads(b, event);
+	}
+
+	udev_device_unref(event);
+
+	return 1;
+}
+
+static void
+drm_destroy(struct weston_compositor *ec)
+{
+	struct drm_backend *b = to_drm_backend(ec);
+	struct weston_head *base, *next;
+
+	udev_input_destroy(&b->input);
+
+	wl_event_source_remove(b->udev_drm_source);
+	//wl_event_source_remove(b->drm_source);
+
+	b->shutting_down = true;
+
+	weston_log_scope_destroy(b->debug);
+	b->debug = NULL;
+	weston_compositor_shutdown(ec);
+
+
+	wl_list_for_each_safe(base, next, &ec->head_list, compositor_link)
+		drm_head_destroy(to_drm_head(base));
+
+	DestroyCore();
+
+#ifdef BUILD_DRM_GBM
+	if (b->gbm)
+		gbm_device_destroy(b->gbm);
+#endif
+
+	udev_monitor_unref(b->udev_monitor);
+	udev_unref(b->udev);
+
+	weston_launcher_destroy(ec->launcher);
+
+	wl_array_release(&b->unused_crtcs);
+
+	close(b->drm.fd);
+	free(b->drm.filename);
+	free(b);
+}
+
+static void
+session_notify(struct wl_listener *listener, void *data)
+{
+	struct weston_compositor *compositor = data;
+	struct drm_backend *b = to_drm_backend(compositor);
+
+	if (compositor->session_active) {
+		weston_log("activating session\n");
+		weston_compositor_wake(compositor);
+		weston_compositor_damage_all(compositor);
+		b->state_invalid = true;
+		udev_input_enable(&b->input);
+	} else {
+		weston_log("deactivating session\n");
+		udev_input_disable(&b->input);
+
+		weston_compositor_offscreen(compositor);
+	}
+}
+
+
+/**
+ * Handle KMS GPU being added/removed
+ *
+ * If the device being added/removed is the KMS device, we activate/deactivate
+ * the compositor session.
+ *
+ * @param compositor The compositor instance.
+ * @param device The device being added/removed.
+ * @param added Whether the device is being added (or removed)
+ */
+static void
+drm_device_changed(struct weston_compositor *compositor,
+		dev_t device, bool added)
+{
+	struct drm_backend *b = to_drm_backend(compositor);
+
+	if (b->drm.fd < 0 || b->drm.devnum != device ||
+	    compositor->session_active == added)
+		return;
+
+	compositor->session_active = added;
+	wl_signal_emit(&compositor->session_signal, compositor);
+}
+
+/**
+ * Determines whether or not a device is capable of modesetting. If successful,
+ * sets b->drm.fd and b->drm.filename to the opened device.
+ */
+static bool
+drm_device_is_kms(struct drm_backend *b, struct udev_device *device)
+{
+	const char *filename = udev_device_get_devnode(device);
+	const char *sysnum = udev_device_get_sysnum(device);
+	dev_t devnum = udev_device_get_devnum(device);
+	drmModeRes *res;
+	int id = -1, fd;
+
+	if (!filename)
+		return false;
+
+	fd = weston_launcher_open(b->compositor->launcher, filename, O_RDWR);
+	if (fd < 0)
+		return false;
+
+	res = drmModeGetResources(fd);
+	if (!res)
+		goto out_fd;
+	if (res->count_crtcs <= 0 || res->count_connectors <= 0 ||
+	    res->count_encoders <= 0)
+		goto out_res;
+
+	if (sysnum)
+		id = atoi(sysnum);
+	if (!sysnum || id < 0) {
+		weston_log("couldn't get sysnum for device %s\n", filename);
+		goto out_res;
+	}
+
+	/* We can be called successfully on multiple devices; if we have,
+	 * clean up old entries. */
+	if (b->drm.fd >= 0)
+		weston_launcher_close(b->compositor->launcher, b->drm.fd);
+	free(b->drm.filename);
+
+	b->drm.fd = fd;
+	b->drm.id = id;
+	b->drm.filename = strdup(filename);
+	b->drm.devnum = devnum;
+
+	drmModeFreeResources(res);
+	set_drm_master_fd(fd);
+	return true;
+
+out_res:
+	drmModeFreeResources(res);
+out_fd:
+	weston_launcher_close(b->compositor->launcher, fd);
+	return false;
+}
+
+/*
+ * Find primary GPU
+ * Some systems may have multiple DRM devices attached to a single seat. This
+ * function loops over all devices and tries to find a PCI device with the
+ * boot_vga sysfs attribute set to 1.
+ * If no such device is found, the first DRM device reported by udev is used.
+ * Devices are also vetted to make sure they are are capable of modesetting,
+ * rather than pure render nodes (GPU with no display), or pure
+ * memory-allocation devices (VGEM).
+ */
+static struct udev_device*
+find_primary_gpu(struct drm_backend *b, const char *seat)
+{
+	struct udev_enumerate *e;
+	struct udev_list_entry *entry;
+	const char *path, *device_seat, *id;
+	struct udev_device *device, *drm_device, *pci;
+
+	e = udev_enumerate_new(b->udev);
+	udev_enumerate_add_match_subsystem(e, "drm");
+	udev_enumerate_add_match_sysname(e, "card[0-9]*");
+
+	udev_enumerate_scan_devices(e);
+	drm_device = NULL;
+	udev_list_entry_foreach(entry, udev_enumerate_get_list_entry(e)) {
+		bool is_boot_vga = false;
+
+		path = udev_list_entry_get_name(entry);
+		device = udev_device_new_from_syspath(b->udev, path);
+		if (!device)
+			continue;
+		device_seat = udev_device_get_property_value(device, "ID_SEAT");
+		if (!device_seat)
+			device_seat = default_seat;
+		if (strcmp(device_seat, seat)) {
+			udev_device_unref(device);
+			continue;
+		}
+
+		pci = udev_device_get_parent_with_subsystem_devtype(device,
+								"pci", NULL);
+		if (pci) {
+			id = udev_device_get_sysattr_value(pci, "boot_vga");
+			if (id && !strcmp(id, "1"))
+				is_boot_vga = true;
+		}
+
+		/* If we already have a modesetting-capable device, and this
+		 * device isn't our boot-VGA device, we aren't going to use
+		 * it. */
+		if (!is_boot_vga && drm_device) {
+			udev_device_unref(device);
+			continue;
+		}
+
+		/* Make sure this device is actually capable of modesetting;
+		 * if this call succeeds, b->drm.{fd,filename} will be set,
+		 * and any old values freed. */
+		if (!drm_device_is_kms(b, device)) {
+			udev_device_unref(device);
+			continue;
+		}
+
+		/* There can only be one boot_vga device, and we try to use it
+		 * at all costs. */
+		if (is_boot_vga) {
+			if (drm_device)
+				udev_device_unref(drm_device);
+			drm_device = device;
+			break;
+		}
+
+		/* Per the (!is_boot_vga && drm_device) test above, we only
+		 * trump existing saved devices with boot-VGA devices, so if
+		 * we end up here, this must be the first device we've seen. */
+		assert(!drm_device);
+		drm_device = device;
+	}
+
+	/* If we're returning a device to use, we must have an open FD for
+	 * it. */
+	assert(!!drm_device == (b->drm.fd >= 0));
+
+	udev_enumerate_unref(e);
+	return drm_device;
+}
+
+static struct udev_device *
+open_specific_drm_device(struct drm_backend *b, const char *name)
+{
+	struct udev_device *device;
+
+	device = udev_device_new_from_subsystem_sysname(b->udev, "drm", name);
+	if (!device) {
+		weston_log("ERROR: could not open DRM device '%s'\n", name);
+		return NULL;
+	}
+
+	if (!drm_device_is_kms(b, device)) {
+		udev_device_unref(device);
+		weston_log("ERROR: DRM device '%s' is not a KMS device.\n", name);
+		return NULL;
+	}
+
+	/* If we're returning a device to use, we must have an open FD for
+	 * it. */
+	assert(b->drm.fd >= 0);
+
+	return device;
+}
+
+static void
+planes_binding(struct weston_keyboard *keyboard, const struct timespec *time,
+	       uint32_t key, void *data)
+{
+	struct drm_backend *b = data;
+
+	switch (key) {
+	case KEY_C:
+		b->cursors_are_broken ^= true;
+		break;
+	case KEY_V:
+		/* We don't support overlay-plane usage with legacy KMS. */
+		if (b->atomic_modeset)
+			b->sprites_are_broken ^= true;
+		break;
+	default:
+		break;
+	}
+}
+
+static const struct weston_drm_output_api api = {
+	drm_output_set_mode,
+	drm_output_set_gbm_format,
+	drm_output_set_seat,
+};
+
+static struct drm_backend *
+drm_backend_create(struct weston_compositor *compositor,
+		   struct weston_drm_backend_config *config)
+{
+	struct drm_backend *b;
+	struct udev_device *drm_device;
+	struct wl_event_loop *loop;
+	const char *seat_id = default_seat;
+	const char *session_seat;
+	sdm_cbs_t sdm_cbs;
+	int ret;
+	bool is_gpu_available = true;
+
+	session_seat = getenv("XDG_SEAT");
+	if (session_seat)
+		seat_id = session_seat;
+
+	if (config->seat_id)
+		seat_id = config->seat_id;
+
+	weston_log("initializing SDM backend\n");
+
+	b = zalloc(sizeof *b);
+	if (b == NULL)
+		return NULL;
+
+	b->state_invalid = true;
+	b->drm.fd = -1;
+	wl_array_init(&b->unused_crtcs);
+
+	b->compositor = compositor;
+	b->use_pixman = config->use_pixman;
+	b->pageflip_timeout = config->pageflip_timeout;
+	b->use_pixman_shadow = config->use_pixman_shadow;
+
+	b->debug = weston_compositor_add_log_scope(compositor->weston_log_ctx,
+						   "drm-backend",
+						   "Debug messages from DRM/KMS backend\n",
+						    NULL, NULL, NULL);
+
+	compositor->backend = &b->base;
+	int fd = open("/dev/kgsl-3d0", O_RDWR);
+	if (fd < 0) {
+		is_gpu_available = false;
+	}
+	if (fd >= 0) {
+		close(fd);
+		fd = -1;
+	}
+	if (!is_gpu_available) {
+		if (parse_gbm_format(config->gbm_format, GBM_FORMAT_ARGB8888, &b->gbm_format) < 0)
+		/* Mesa GBM doesn't support GBM_FORMAT_ABGR8888, passing format supported by mesa.*/
+			goto err_compositor;
+	} else {
+		if (parse_gbm_format(config->gbm_format, GBM_FORMAT_ABGR8888, &b->gbm_format) < 0)
+			goto err_compositor;
+	}
+
+	if (b->use_pixman || !is_gpu_available) {
+		b->use_pixman = true;
+		weston_log("Use Pixman Rendering - SDM backend\n");
+	}
+
+	/* Check if we run drm-backend using weston-launch */
+	compositor->launcher = weston_launcher_connect(compositor, config->tty,
+						       seat_id, true);
+	if (compositor->launcher == NULL) {
+		weston_log("fatal: drm backend should be run using "
+			   "weston-launch binary, or your system should "
+			   "provide the logind D-Bus API.\n");
+		goto err_compositor;
+	}
+
+	b->udev = udev_new();
+	if (b->udev == NULL) {
+		weston_log("failed to initialize udev context\n");
+		goto err_launcher;
+	}
+
+	b->session_listener.notify = session_notify;
+	wl_signal_add(&compositor->session_signal, &b->session_listener);
+
+	if (config->specific_device)
+		drm_device = open_specific_drm_device(b, config->specific_device);
+	else
+		drm_device = find_primary_gpu(b, seat_id);
+
+	if (drm_device == NULL) {
+		weston_log("no drm device found\n");
+		goto err_udev;
+	}
+
+	if (init_kms_caps(b) < 0)
+		goto err_udev_dev;
+
+	if (b->use_pixman) {
+		if (init_pixman(b) < 0) {
+			weston_log("failed to initialize pixman renderer\n");
+			goto err_udev_dev;
+		}
+	} else {
+		if (init_egl(b) < 0) {
+			weston_log("failed to initialize egl\n");
+			goto err_udev_dev;
+		}
+	}
+
+	b->base.destroy = drm_destroy;
+	b->base.repaint_begin = drm_repaint_begin;
+	b->base.repaint_flush = drm_repaint_flush;
+	b->base.repaint_cancel = drm_repaint_cancel;
+	b->base.create_output = drm_output_create;
+	b->base.device_changed = drm_device_changed;
+	b->base.can_scanout_dmabuf = drm_can_scanout_dmabuf;
+
+	weston_setup_vt_switch_bindings(compositor);
+
+	if (udev_input_init(&b->input,
+			    compositor, b->udev, seat_id,
+			    config->configure_device) < 0) {
+		weston_log("failed to create input devices\n");
+		goto err_sprite;
+	}
+
+	/* A this point we have some idea of whether or not we have a working
+	 * cursor plane. */
+	if (!b->cursors_are_broken)
+		compositor->capabilities |= WESTON_CAP_CURSOR_PLANE;
+
+	loop = wl_display_get_event_loop(compositor->wl_display);
+
+	b->udev_monitor = udev_monitor_new_from_netlink(b->udev, "udev");
+	if (b->udev_monitor == NULL) {
+		weston_log("failed to initialize udev monitor\n");
+		goto err_drm_source;
+	}
+	udev_monitor_filter_add_match_subsystem_devtype(b->udev_monitor,
+							"drm", NULL);
+	b->udev_drm_source =
+		wl_event_loop_add_fd(loop,
+				     udev_monitor_get_fd(b->udev_monitor),
+				     WL_EVENT_READABLE, udev_drm_event, b);
+	if (b->udev_drm_source == NULL) {
+		weston_log("failed to add wl event loop\n");
+		udev_monitor_unref(b->udev_monitor);
+		goto err_drm_source;
+	}
+
+	if (udev_monitor_enable_receiving(b->udev_monitor) < 0) {
+		weston_log("failed to enable udev-monitor receiving\n");
+		goto err_udev_monitor;
+	}
+
+	udev_device_unref(drm_device);
+
+	weston_compositor_add_debug_binding(compositor, KEY_O,
+					    planes_binding, b);
+	weston_compositor_add_debug_binding(compositor, KEY_C,
+					    planes_binding, b);
+	weston_compositor_add_debug_binding(compositor, KEY_V,
+					    planes_binding, b);
+	weston_compositor_add_debug_binding(compositor, KEY_W,
+					    renderer_switch_binding, b);
+
+	/* begin SDM initialization */
+	int rc = CreateCore(b->use_pixman);
+	if (rc != 0) {
+		weston_log("Creating SDM core failed");
+		return rc;
+	}
+
+	if (drm_backend_create_heads(b, drm_device) < 0) {
+		weston_log("Failed to create heads for %s\n", b->drm.filename);
+		goto err_udev_input;
+	}
+
+	if (compositor->renderer->import_dmabuf) {
+		if (linux_dmabuf_setup(compositor) < 0)
+			weston_log("Error: initializing dmabuf "
+				   "support failed.\n");
+		if (weston_direct_display_setup(compositor) < 0)
+			weston_log("Error: initializing direct-display "
+				   "support failed.\n");
+	}
+
+	if (compositor->renderer->import_gbm_buffer) {
+		if (gbm_buffer_backend_setup(compositor) < 0)
+			weston_log("Error: gbm buffer backend setup failed\n");
+
+	}
+
+	if (weston_qti_extn_setup(compositor) < 0)
+		weston_log("Error: weston_qti_extn_setup failed\n");
+
+	if (compositor->capabilities & WESTON_CAP_EXPLICIT_SYNC) {
+		if (linux_explicit_synchronization_setup(compositor) < 0)
+			weston_log("Error: initializing explicit "
+				   " synchronization support failed.\n");
+	}
+
+	if (b->atomic_modeset)
+		if (weston_compositor_enable_content_protection(compositor) < 0)
+			weston_log("Error: initializing content-protection "
+				   "support failed.\n");
+
+	ret = weston_plugin_api_register(compositor, WESTON_DRM_OUTPUT_API_NAME,
+					 &api, sizeof(api));
+
+	if (ret < 0) {
+		weston_log("Failed to register output API.\n");
+		goto err_udev_monitor;
+	}
+
+	return b;
+
+err_udev_monitor:
+	wl_event_source_remove(b->udev_drm_source);
+	udev_monitor_unref(b->udev_monitor);
+err_drm_source:
+	wl_event_source_remove(b->drm_source);
+err_udev_input:
+	udev_input_destroy(&b->input);
+err_sprite:
+#ifdef BUILD_DRM_GBM
+	if (b->gbm)
+		gbm_device_destroy(b->gbm);
+#endif
+err_udev_dev:
+	udev_device_unref(drm_device);
+err_launcher:
+	weston_launcher_destroy(compositor->launcher);
+err_udev:
+	udev_unref(b->udev);
+err_compositor:
+	weston_compositor_shutdown(compositor);
+	free(b);
+	return NULL;
+}
+
+static void
+config_init_to_defaults(struct weston_drm_backend_config *config)
+{
+	config->use_pixman_shadow = true;
+}
+
+WL_EXPORT int
+weston_backend_init(struct weston_compositor *compositor,
+		    struct weston_backend_config *config_base)
+{
+	struct drm_backend *b;
+	struct weston_drm_backend_config config = {{ 0, }};
+
+	if (config_base == NULL ||
+	    config_base->struct_version != WESTON_DRM_BACKEND_CONFIG_VERSION ||
+	    config_base->struct_size > sizeof(struct weston_drm_backend_config)) {
+		weston_log("drm backend config structure is invalid\n");
+		return -1;
+	}
+
+	config_init_to_defaults(&config);
+	memcpy(&config, config_base, config_base->struct_size);
+
+	b = drm_backend_create(compositor, &config);
+	if (b == NULL)
+		return -1;
+
+	return 0;
+}
+
+void NotifyOnRefresh(struct drm_output *drm_output) {
+  drm_output->base.repaint_status = REPAINT_AWAITING_COMPLETION;
+  drm_output->atomic_complete_pending = true;
+}
diff --git a/libweston/backend-sdm/state-propose.c b/libweston/backend-sdm/state-propose.c
new file mode 100644
index 0000000..b63e568
--- /dev/null
+++ b/libweston/backend-sdm/state-propose.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2017, 2018 Collabora, Ltd.
+ * Copyright © 2017, 2018 General Electric Company
+ * Copyright (c) 2018 DisplayLink (UK) Ltd.
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Changes from Qualcomm Innovation Center are provided under the following license:
+ *
+ * Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause-Clear
+ */
+
+#include "config.h"
+
+#include <libweston/libweston.h>
+#include <libweston/pixel-formats.h>
+
+#include "sdm-internal.h"
+#include "linux-dmabuf.h"
+#include "presentation-time-server-protocol.h"
+
+void
+destroy_sdm_layer(struct sdm_layer *layer)
+{
+	pixman_region32_fini(&layer->overlap);
+	weston_buffer_reference(&layer->buffer_ref, NULL);
+	wl_list_remove(&layer->link);
+	if (layer->fb) {
+		drm_fb_unref(layer->fb);
+	}
+	free(layer);
+}
+
+static struct sdm_layer *
+create_sdm_layer(struct drm_output *output, struct weston_view *ev,
+		 pixman_region32_t *overlap, bool is_cursor, bool is_skip)
+{
+	struct sdm_layer *layer;
+
+	layer = zalloc(sizeof(*layer));
+	if (layer == NULL) {
+	    return NULL;
+	}
+
+	layer->view = ev;
+	layer->acquire_fence_fd = ev->surface->acquire_fence_fd;
+	layer->is_cursor = is_cursor;
+	layer->is_skip = is_skip;
+	if (!is_skip)
+		layer->fb = drm_fb_get_from_view(output, ev);
+
+	pixman_region32_init(&layer->overlap);
+	pixman_region32_copy(&layer->overlap, overlap);
+	weston_buffer_reference(&layer->buffer_ref, ev->surface->buffer_ref.buffer);
+
+	return layer;
+}
+
+void
+drm_assign_planes(struct weston_output *output_base, void *repaint_data)
+{
+	struct drm_backend *b = to_drm_backend(output_base->compositor);
+	struct drm_output *output = to_drm_output(output_base);
+	struct weston_view *ev;
+	struct weston_plane *primary = &output_base->compositor->primary_plane, *next_plane;
+	struct sdm_layer *sdm_layer, *next_sdm_layer;
+	bool is_skip = false;
+	struct weston_surface *es;
+	pixman_region32_t overlap, surface_overlap;
+
+	pixman_region32_init(&overlap);
+
+	output->view_count = 0;
+	wl_list_init(&output->sdm_layer_list);
+	wl_list_for_each(ev, &output_base->compositor->view_list, link) {
+
+		/* If this view doesn't touch our output at all, there's no
+		 * reason to do anything with it. */
+		if (!(ev->output_mask & (1u << output->base.id)))
+			continue;
+
+		/* Test whether this buffer can ever go into a plane:
+		 * non-shm, or small enough to be a cursor.
+		 *
+		 * Also, keep a reference when using the pixman renderer.
+		 * That makes it possible to do a seamless switch to the GL
+		 * renderer and since the pixman renderer keeps a reference
+		 * to the buffer anyway, there is no side effects.
+		 */
+		if (b->use_pixman ||
+		    (weston_view_has_valid_buffer(ev) &&
+		    (!wl_shm_buffer_get(ev->surface->buffer_ref.buffer->resource) ||
+		     (ev->surface->width <= b->cursor_width &&
+		      ev->surface->height <= b->cursor_height))))
+			ev->surface->keep_buffer = true;
+		else
+			ev->surface->keep_buffer = false;
+
+		pixman_region32_init(&surface_overlap);
+		pixman_region32_intersect(&surface_overlap, &overlap,
+						&ev->transform.boundingbox);
+
+		es = ev->surface;
+		if (!es->buffer_ref.buffer) {
+		    is_skip = true;
+		} else if (linux_dmabuf_buffer_get(es->buffer_ref.buffer->resource)) {
+		    is_skip = false;
+		} else if (gbm_buffer_get(es->buffer_ref.buffer->resource)) {
+                    is_skip = false;
+		} else if (wl_shm_buffer_get(es->buffer_ref.buffer->resource)) {
+		    is_skip = true;
+		} else {
+		    is_skip = true;
+		}
+
+		sdm_layer = create_sdm_layer(output, ev, &surface_overlap, false, is_skip);
+		if (!sdm_layer)
+			return;
+
+		wl_list_insert(output->sdm_layer_list.prev, &sdm_layer->link);
+		output->view_count++;
+	}
+
+	output->view_count++;
+
+	int ret = Prepare(output->display_id, output);
+	if (ret != 0) {
+		weston_log("%s: Assigning planes failed\n", __func__);
+		return;
+	}
+
+	pixman_region32_fini(&overlap);
+
+	wl_list_for_each_safe(sdm_layer, next_sdm_layer, &output->sdm_layer_list, link) {
+		next_plane = primary;
+		ev = sdm_layer->view;
+		/* Move to primary plane if Strategy set it to GPU composition */
+		if (sdm_layer->composition_type == SDM_COMPOSITION_GPU) {
+			weston_view_move_to_plane(ev, next_plane);
+				pixman_region32_union(&overlap, &overlap, &ev->transform.boundingbox);
+			ev->psf_flags = 0;
+			destroy_sdm_layer(sdm_layer);
+		} else {
+			/* Composed by Display Hardware directly */
+			/* ToDo(User): handle scenarios if SDE composition is not possible */
+			ev->psf_flags = WP_PRESENTATION_FEEDBACK_KIND_ZERO_COPY;
+			/* Set the view's plane back to NULL so that it is not composed by GPU */
+			sdm_layer->view->plane = NULL;
+		}
+	}
+}
diff --git a/libweston/compositor.c b/libweston/compositor.c
index eebc22b..f705a2f 100644
--- a/libweston/compositor.c
+++ b/libweston/compositor.c
@@ -8276,6 +8276,7 @@ weston_compositor_get_user_data(struct weston_compositor *compositor)
 
 static const char * const backend_map[] = {
 	[WESTON_BACKEND_DRM] =		"drm-backend.so",
+        [WESTON_BACKEND_SDM] =		"sdm-backend.so",
 	[WESTON_BACKEND_FBDEV] =	"fbdev-backend.so",
 	[WESTON_BACKEND_HEADLESS] =	"headless-backend.so",
 	[WESTON_BACKEND_RDP] =		"rdp-backend.so",
diff --git a/libweston/launcher-direct.c b/libweston/launcher-direct.c
index c04ba85..c6befbc 100644
--- a/libweston/launcher-direct.c
+++ b/libweston/launcher-direct.c
@@ -70,23 +70,28 @@ is_drm_master(int drm_fd)
 
 #else
 
+#include <xf86drm.h>
 static inline int
-drmDropMaster(int drm_fd)
+is_drm_master(int drm_fd)
 {
-	return 0;
-}
+        drm_magic_t magic;
 
-static inline int
-drmSetMaster(int drm_fd)
-{
-	return 0;
+        return drmGetMagic(drm_fd, &magic) == 0 &&
+                drmAuthMagic(drm_fd, magic) == 0;
 }
 
-static inline int
-is_drm_master(int drm_fd)
+#endif
+
+#ifdef BUILD_DRM_COMPOSITOR
+static int get_drm_master_fd(void)
 {
-	return 0;
+  	weston_log("launcher: DRM FD is not derived from SDM compositor\n");
+		return -1;
 }
+#else
+
+#include "sdm-service/sdm_display_connect.h"
+
 
 #endif
 
diff --git a/libweston/meson.build b/libweston/meson.build
index 7ae3aa1..ffdab47 100644
--- a/libweston/meson.build
+++ b/libweston/meson.build
@@ -157,10 +157,19 @@ deps_session_helper = [
 	dep_libweston_private,
 ]
 
+deps_session_helper = [
+dep_libweston_private_h,
+dep_libweston_private,
+]
+		
 if get_option('backend-drm')
 	deps_session_helper += dep_libdrm
 endif
 
+if get_option('backend-sdm')
+deps_session_helper += [dep_libdrm, dep_libsdmcore, dep_libsdmutils, dep_libsdmdal]
+endif
+
 systemd_dep = dependency('', required: false)
 if get_option('launcher-logind')
 	systemd_dep = dependency('libsystemd', version: '>= 209', required: false)
@@ -204,7 +213,7 @@ endif
 lib_session_helper = static_library(
 	'session-helper',
 	srcs_session_helper,
-	include_directories: common_inc,
+	include_directories: [common_inc, ('backend-sdm')],
 	dependencies: deps_session_helper,
 	install: false
 )
@@ -268,6 +277,7 @@ install_headers(
 subdir('color-lcms')
 subdir('renderer-gl')
 subdir('backend-drm')
+subdir('backend-sdm')
 subdir('backend-fbdev')
 subdir('backend-headless')
 subdir('backend-rdp')
diff --git a/meson.build b/meson.build
index 2b8f8a8..9d55ac3 100644
--- a/meson.build
+++ b/meson.build
@@ -1,9 +1,11 @@
 project('weston',
 	'c',
+        'cpp',
 	version: '10.0.2',
 	default_options: [
 		'warning_level=3',
 		'c_std=gnu99',
+                'cpp_std=c++11',
 		'b_lundef=true',
 	],
 	meson_version: '>= 0.52.1',
@@ -74,6 +76,7 @@ foreach a : global_args_maybe
 	endif
 endforeach
 add_global_arguments(global_args, language: 'c')
+add_global_arguments(global_args, language: 'cpp')
 
 if cc.has_header_symbol('sys/sysmacros.h', 'major')
 	config_h.set('MAJOR_IN_SYSMACROS', 1)
@@ -121,10 +124,12 @@ config_h.set_quoted('LIBWESTON_MODULEDIR', dir_module_libweston)
 
 config_h.set10('TEST_GL_RENDERER', get_option('test-gl-renderer'))
 
+message('before setting default')
 backend_default = get_option('backend-default')
 if backend_default == 'auto'
-	foreach b : [ 'headless', 'x11', 'wayland', 'drm' ]
+	foreach b : [ 'headless', 'x11', 'wayland', 'drm', 'sdm' ]
 		if get_option('backend-' + b)
+		        message('backend ' + b)
 			backend_default = b
 		endif
 	endforeach
@@ -157,6 +162,15 @@ dep_libdl = cc.find_library('dl')
 dep_libdrm = dependency('libdrm', version: '>= 2.4.95')
 dep_libdrm_headers = dep_libdrm.partial_dependency(compile_args: true)
 dep_threads = dependency('threads')
+dep_gbm = dependency('gbm')
+if get_option('backend-sdm')
+dep_glib = dependency('glib-2.0')
+dep_property = cc.find_library('propertyvault', required: true)
+dep_libsdmcore = cc.find_library('sdmcore')
+dep_libsdmutils = cc.find_library('sdmutils')
+dep_libsdmdal = cc.find_library('sdmdal')
+dep_libdrmutils = cc.find_library('drmutils')
+endif
 
 dep_libdrm_version = dep_libdrm.version()
 if dep_libdrm_version.version_compare('>=2.4.107')
diff --git a/meson_options.txt b/meson_options.txt
index 8a527d7..c84a1f5 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -1,7 +1,18 @@
 # This option is not implemented:
 #  --with-cairo=[image|gl|glesv2] Which Cairo renderer to use for the clients
 # It is hardcoded to cairo-image for now.
-
+option(
+       'backend-sdm',
+       type: 'boolean',
+       value: true,
+       description: 'Weston backend with MSM SDM compositor'
+)
+option(
+       'disable-power-key',
+       type: 'boolean',
+       value: false,
+       description: 'Weston backend: disable power key handling'
+)
 option(
 	'backend-drm',
 	type: 'boolean',
